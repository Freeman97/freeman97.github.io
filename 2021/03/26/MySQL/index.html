<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="[] MVCC彻底理解清楚 [] 分库分表 [] MySQL Cluster在CAP中的定位  数据库3大范式是什么 函数依赖：对于X, Y, 如果不存在关系，使得X上的属性值相等而Y的属性值不等，称Y函数依赖于X。此时X称为决定因素。 完全函数依赖：对于X的任何一个真子集X’，都不满足X’ -&gt; Y，说明Y完全函数依赖与X 部分函数依赖：如果存在X的真子集X’，满足X’-&gt;Y，说">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://yoursite.com/2021/03/26/MySQL/index.html">
<meta property="og:site_name" content="Freeman&#39;s Blog">
<meta property="og:description" content="[] MVCC彻底理解清楚 [] 分库分表 [] MySQL Cluster在CAP中的定位  数据库3大范式是什么 函数依赖：对于X, Y, 如果不存在关系，使得X上的属性值相等而Y的属性值不等，称Y函数依赖于X。此时X称为决定因素。 完全函数依赖：对于X的任何一个真子集X’，都不满足X’ -&gt; Y，说明Y完全函数依赖与X 部分函数依赖：如果存在X的真子集X’，满足X’-&gt;Y，说">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2021/03/26/MySQL/pics/binlog-vs-redolog.png">
<meta property="article:published_time" content="2021-03-26T15:30:01.000Z">
<meta property="article:modified_time" content="2021-03-26T15:33:42.103Z">
<meta property="article:author" content="Freeman Huang">
<meta property="article:tag" content="2021春招">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/03/26/MySQL/pics/binlog-vs-redolog.png">

<link rel="canonical" href="http://yoursite.com/2021/03/26/MySQL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL | Freeman's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Freeman's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个菜鸡心血来潮搭建的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:33:42" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <a id="more"></a>
<ul>
<li>[] MVCC彻底理解清楚</li>
<li>[] 分库分表</li>
<li>[] MySQL Cluster在CAP中的定位</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="3大范式是什么"><a href="#3大范式是什么" class="headerlink" title="3大范式是什么"></a>3大范式是什么</h2><ul>
<li>函数依赖：对于X, Y, 如果不存在关系，使得X上的属性值相等而Y的属性值不等，称Y函数依赖于X。此时X称为决定因素。</li>
<li>完全函数依赖：对于X的任何一个真子集X’，都不满足X’ -&gt; Y，说明Y完全函数依赖与X</li>
<li>部分函数依赖：如果存在X的真子集X’，满足X’-&gt;Y，说明Y对X部分函数依赖</li>
<li>如果X-&gt;Y, Y不属于X（防止Y-&gt;X）, Y -&gt; Z, Z不属于Y（防止Z-&gt;Y），称Z对X传递函数依赖。</li>
<li>码：如果K -F-&gt; U（完全函数确定），K是R的候选码。</li>
<li>1NF: 关系模式中的每一个分量是不可分的数据项</li>
<li>2NF: 如果某个关系满足1NF，并且任何一个非主属性都完全函数依赖于任何一个候选码，则该关系模式满足2NF</li>
<li>3NF: 如果任何一个非主属性既不部分依赖于码，也不传递依赖于码，说明该关系模式满足3NF</li>
<li>BCNF: 如果每一个决定因素都包含码，说明该关系模式满足BCNF</li>
</ul>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h1 id="MyISAM-vs-InnoDB"><a href="#MyISAM-vs-InnoDB" class="headerlink" title="MyISAM vs InnoDB"></a>MyISAM vs InnoDB</h1><ul>
<li>是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
<li>是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li>MyISAM不支持外键，InnoDB支持外键</li>
<li>是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h2><ul>
<li>创建唯一性索引可以保证每行数据的唯一性</li>
<li>加快数据检索速度</li>
<li>帮助服务器避免排序和临时表（？）</li>
<li>将随机IO变为顺序IO</li>
<li>加速表之间的连接<h2 id="为什么不为每一个列创建索引"><a href="#为什么不为每一个列创建索引" class="headerlink" title="为什么不为每一个列创建索引"></a>为什么不为每一个列创建索引</h2></li>
<li>索引需要维护，加入索引会降低对数据更新的速度</li>
<li>索引要占据物理空间</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>在经常需要搜索的列上，可以加快搜索的速度；</p>
</li>
<li><p>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
</li>
<li><p>在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
</li>
<li><p>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</p>
</li>
<li><p>在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；</p>
</li>
<li><p>避免 where 子句中对字段施加函数，这会造成无法命中索引。</p>
</li>
<li><p>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</p>
</li>
<li><p>单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用，以提升效率。</p>
</li>
<li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序 I/O 不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。</li>
<li>索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就 不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访 问是很慢的。</li>
</ul>
<h2 id="BTree索引"><a href="#BTree索引" class="headerlink" title="BTree索引"></a>BTree索引</h2><ul>
<li>数据结构：B+树<h3 id="B树-vs-B-树"><a href="#B树-vs-B-树" class="headerlink" title="B树 vs B+树"></a>B树 vs B+树</h3></li>
<li>B树的所有节点既存放key也存放data，但B+树只有叶子节点存放key和data，其它节点只存放key</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程。<h3 id="MyISAM实现"><a href="#MyISAM实现" class="headerlink" title="MyISAM实现"></a>MyISAM实现</h3></li>
<li>非聚簇索引，在索引数据结构（叶子节点的data域）上存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</li>
<li>MyISAM使用前缀压缩以减少索引，可以让更多的索引进入内存以减少磁盘IO的时间。MyISAM压缩索引库的方法是完全保存索引块中的第一个值，后续的值只保存和第一个值相同前缀的字节数和后续的不同部分。这样每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描，这会影响某些操作的性能，例如倒序扫描。</li>
<li>硬要说的话适合<code>UPDATE</code>密集的表<h3 id="InnoDB实现"><a href="#InnoDB实现" class="headerlink" title="InnoDB实现"></a>InnoDB实现</h3></li>
<li>聚簇索引，表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。其它的索引都作为辅助索引，辅助索引的data域保存的是主键的值而不是地址。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
<li>MyISAM索引按照行存储的物理位置引用被索引的行，但是InnoDB按照主键值引用行。如果使用DML对表中数据进行操作（插入、删除、修改…），行的存储位置可能会发生变化，如果使用主键值引用行，此时就不需要对索引进行更新。</li>
</ul>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><ul>
<li>数据结构：哈希表</li>
<li>对于哈希索引来说，底层的数据结构就是哈希表，因此在<strong>绝大多数需求为单条记录查询</strong>的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。哈希索引无法支持范围查询和顺序查询。</li>
</ul>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。<br><strong>问题</strong>：对于<code>(a, b, c)</code>上的联合索引，对于条件<code>where a = &#39;xx&#39; and c = &#39;yy&#39;</code>，是否可以利用索引？<br><strong>问题</strong>：MySQL 8.0还需要遵守最左匹配原则吗？</p>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><ul>
<li>事务是逻辑上的一组操作，要么都执行，要么都不执行。</li>
<li>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性（Consistency）： 执行事务后，数据库从一个正确的状态变化到另一个正确的状态；</li>
<li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><ul>
<li>脏读（Dirty read）：事务修改了数据但是还没有将修改提交到数据库中，另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没来得及提交的旧数据，读取的事务读到的是脏数据，根据这样的脏数据做的操作可能是不正确的</li>
<li>丢失修改（Lost to modify）：两个事务同时读取一个数据，并同时修改这个数据。第一个事务修改了这个数据后第二个事务也修改了这个数据，导致第一个事务的修改被丢失。</li>
<li>不可重复读（Unrepeatableread）：在一个事务内多次读同一数据。在这个事务还没结束时另一个事务也访问这个数据，并且可能对这个数据进行修改。这样，一个事务内的多次读取到的同一数据的值可能不一样，这种情况称为不可重复读</li>
<li>幻读（Phantom read）：在一个事务内用相同的条件查询多次数据，在这个事务查询一次数据之后，另一个并发的事务插入或删除了一些数据，因此事务后续用相同的条件进行查询时结果集会发生变化。</li>
</ul>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul>
<li>READ-UNCOMMITTED（读取未提交）：最低的隔离级别，允许读取尚未提交的数据变更。可能会导致脏读、幻读、不可重复读。</li>
<li>READ-COMMITTED（读取已提交）：允许读取并发事务已经提交的数据，可以阻止脏读，但是无法阻止幻读和不可重复读。</li>
<li>REPEATABLE-READ（可重复读）：默认的隔离级别。一个事务内对同一字段的多次读取结果是一致的，除非数据本身已经被事务自己改变。可以阻止脏读和不可重复读，但是仍然可能发生<strong>幻读</strong>。</li>
<li>SERIALIZABLE（可串行化）：最高的隔离级别，分布式事务的情况下一般使用可串行化的隔离级别，完全满足ACID性质，所有的事务依次逐个执行，互不干扰。可以防止脏读、不可重复读和幻读。</li>
</ul>
<h1 id="MySQL-锁机制"><a href="#MySQL-锁机制" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h1><h2 id="按照锁的粒度分类"><a href="#按照锁的粒度分类" class="headerlink" title="按照锁的粒度分类"></a>按照锁的粒度分类</h2><ul>
<li>表级锁：对整张表加锁，实现简单，消耗资源少，加锁快，不会出现死锁，粒度最大，并发度最低。</li>
<li>行级锁：粒度最小的锁，减少数据库操作的锁冲突，并发度高，但加锁开销大，加锁慢，可能出现死锁。</li>
</ul>
<h2 id="共享-排他锁"><a href="#共享-排他锁" class="headerlink" title="共享/排他锁"></a>共享/排他锁</h2><ul>
<li>S锁：可以是行级也可以是表级</li>
<li>X锁：可以实行级也可以是表级</li>
<li>IS锁：表级</li>
<li>IX锁：表级</li>
</ul>
<h2 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h2><h3 id="记录锁-Record-locks"><a href="#记录锁-Record-locks" class="headerlink" title="记录锁(Record locks)"></a>记录锁(Record locks)</h3><ul>
<li>记录锁是施加在索引记录上的锁。（是指主索引吗？）</li>
<li>记录锁永远只会对索引记录施加，即使表没有定义任何索引。在这种情况下，InnoDB会创建一个隐藏的聚簇索引，用该索引实现记录锁。</li>
</ul>
<h3 id="间隙锁-Gap-locks-lt"><a href="#间隙锁-Gap-locks-lt" class="headerlink" title="间隙锁(Gap locks) &lt;- ?"></a>间隙锁(Gap locks) &lt;- ?</h3><ul>
<li>间隙锁是施加在索引记录之间间隙、在第一个索引记录之前和最后一个索引记录之后的锁。例如查询<br><code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE</code>会阻止其他事务插入一个<code>t.c1 = 15</code>的行，因为在这个范围内的间隙都已被加锁。（一个间隙指的是一个区间）</li>
<li>间隙锁是性能和并发性之间权衡的一部分，在某些事务隔离级别中使用（目测是为了防止幻读），而在其他级别中则不使用。</li>
<li>当使用唯一索引搜索唯一行时，不需要使用间隙锁。但是使用多列唯一索引的部分列进行搜索时，间隙锁会发生作用。</li>
<li>不同事务可以持有互相冲突的间隙锁。</li>
<li>InnoDB中的间隙锁是纯禁止性的，间隙锁的唯一目的就是防止其它事务向间隙中插入数据。</li>
</ul>
<h3 id="邻键锁-Next-Key-locks-lt"><a href="#邻键锁-Next-Key-locks-lt" class="headerlink" title="邻键锁(Next-Key locks) &lt;- ?"></a>邻键锁(Next-Key locks) &lt;- ?</h3><ul>
<li>邻键锁是记录锁和在索引记录之前的间隙锁的结合（a combination of a record lock on the index record and a gap lock on the gap before the index record）。</li>
<li>InnoDB是这样实现行级锁的：当搜索或扫描表的索引时，InnoDB在它遇到的索引记录上施加共享锁或排他锁。因此行级锁实际上是索引记录锁。</li>
<li>邻键锁对索引记录加锁，同时对索引记录之前的(一个)间隙加锁。</li>
<li>在<code>REPEATABLE_READ</code>事务隔离级别下，InnoDB使用邻键锁来进行搜索和索引扫描，避免<strong>幻读</strong>的出现(-&gt;因此REPEATABLE_READ隔离级别不存在幻读问题？</li>
</ul>
<h3 id="插入意向锁-Insert-Intension-locks"><a href="#插入意向锁-Insert-Intension-locks" class="headerlink" title="插入意向锁(Insert Intension locks)"></a>插入意向锁(Insert Intension locks)</h3><ul>
<li>插入意图锁是一种间隙锁，是由<code>INSERT</code>操作在行插入之前设置的。该锁表明插入数据的意向，多个事务向同一个间隙(区间)插入数据时，如果他们插入的位置不同，则不需要互相等待。</li>
</ul>
<h3 id="自增锁-AUTO-INC-locks"><a href="#自增锁-AUTO-INC-locks" class="headerlink" title="自增锁(AUTO-INC locks)"></a>自增锁(AUTO-INC locks)</h3><ul>
<li>自增锁是一种特殊的表级锁，当事务需要向包含<code>AUTO_INCREMENT</code>列的表插入数据时自增锁会发挥作用。如果一个事务正在向表中插入数据，另一个需要插入数据的事务必须等待，这样插入表中的行才能有连续的自增主键。</li>
<li>通过更改<code>innodb_autoinc_lock_mode</code>配置项可以选择用于自增锁的算法，更改该选项用户可以自由地在自增值的可预测性和插入操作的并发性之间进行权衡取舍。</li>
</ul>
<h1 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h1><h2 id="限定数据范围，禁止不带任何限制范围条件的查询语句"><a href="#限定数据范围，禁止不带任何限制范围条件的查询语句" class="headerlink" title="限定数据范围，禁止不带任何限制范围条件的查询语句"></a>限定数据范围，禁止不带任何限制范围条件的查询语句</h2><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主库写、从库读</p>
<h2 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h2><p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。<br>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。<br>优点：列数据变小，减少读取的block数，减少IO次数，简化表的结构，易于维护。<br>缺点：主键冗余，增加join操作，让事务变得更复杂。</p>
<h2 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h2><p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中（比如，按时间区间水平分区，按ID水平分区），达到了分布式的目的。 水平拆分可以支撑非常大的数据量。<br>分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分<strong>最好分库</strong> 。<br>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。</p>
<ul>
<li>分片的常见方案:<ul>
<li>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或封装JDBC层来实现。（？）</li>
<li>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。（？）<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2></li>
</ul>
</li>
<li>使用慢查询日志找出较慢的SQL</li>
<li>不做列运算：<code>SELECT id WHERE age + 1 = 10</code>，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</li>
<li>对列进行函数操作可能会导致无法使用索引 -&gt; 函数索引。隐式类型转换也会导致索引失效。</li>
<li>尽量不用<code>SELECT *</code>，而是显式指定需要的列</li>
<li>不用函数和触发器，在应用程序实现（？）</li>
<li>少用JOIN</li>
<li>尽量避免在<code>WHERE</code>中使用<code>!=</code>, <code>&lt;&gt;</code>, 这类条件无法利用索引，而只能使用全表扫描。</li>
</ul>
<h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><ul>
<li>频繁的查询优先考虑使用覆盖索引（包含了所查询字段的索引），这样可以必满InnoDB表进行索引的二次查询。<ul>
<li>例如，要通过某个建立了二级索引的列<code>A</code>上的条件查询列<code>B</code>的值，如果只使用<code>A</code>上的索引，由于该索引的叶子节点只保存了主键的值，因此此时需要回表，即在主键索引上再次进行查找，才能找到对应行的<code>B</code>的值。如果在<code>A</code>和<code>B</code>上建立一个联合索引，在叶子节点处就会存在<code>B</code>列的值，不需要进行回表。</li>
</ul>
</li>
<li>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</li>
</ul>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><ul>
<li>严禁左模糊（例如，<code>a like &#39;%123&#39;</code>。形如<code>a like &#39;123%&#39;</code>，即左侧具体的条件，是可以使用列上的索引的）或者全模糊，有这种需求的时候需要使用搜索引擎。B树索引有最左前缀匹配的特性，最左边的值不确定时无法使用。</li>
</ul>
<h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><ul>
<li>对于外键和级联的一种好的方式是在应用层实现。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风 险;外键影响数据库的插入速度。并且分库分表的情况下数据库级别的外键也无法生效。</li>
<li>外键也有一定的好处：在DB层面就保证了数据的一致性和完整性，并且由数据库自动完成级联操作也可以减少代码量。</li>
<li>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</li>
</ul>
<h1 id="池化（数据库连接池）"><a href="#池化（数据库连接池）" class="headerlink" title="池化（数据库连接池）"></a>池化（数据库连接池）</h1><p>建立连接是需要消耗时间的，如果有较多的任务陆续提交而不进行任何特殊处理，就需要重复建立连接-关闭连接的过程，浪费时间。因此池化技术的思想就是复用这些创建的连接。（数据库连接的本质可以视为一个socket连接）。</p>
<h1 id="SQL语句的执行过程"><a href="#SQL语句的执行过程" class="headerlink" title="SQL语句的执行过程"></a>SQL语句的执行过程</h1><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><ul>
<li>Server层<ul>
<li>连接器： 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li>查询缓存:  执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。</li>
<li>分析器:  没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。词法分析提取关键字，语法分析校验SQL语法是否正确。</li>
<li>优化器： 按照 MySQL 认为最优的方案，生成查询计划去执行。 比如决定如何选择索引。</li>
<li>执行器:  执行语句，然后从存储引擎返回数据。执行器在执行前会首先检查用户有没有权限。</li>
</ul>
</li>
<li>存储引擎：InnoDB包括Redolog模块</li>
</ul>
<h2 id="更新语句的执行流程"><a href="#更新语句的执行流程" class="headerlink" title="更新语句的执行流程"></a>更新语句的执行流程</h2><p>执行更新语句时要记录日志。MySQL使用binlog进行日志记录，InnoDB还自带一个日志模块redo log。</p>
<ol>
<li>拿到待修改的数据，进行修改，然后调用引擎API接口写入修改后的数据。InnoDB会将数据保存在内存中，同时记录Redo log，此时redo log进入prepare状态，然后告诉执行器执行完成，随时可以提交。</li>
<li>执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为提交状态。</li>
<li>更新完成。</li>
</ol>
<ul>
<li><p>为什么要用两个日志模块？</p>
<ul>
<li>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</li>
</ul>
</li>
<li><p>为什么要先让redo log进入prepare状态，然后记录binlog，最后commit redo log？</p>
<ul>
<li>先写 redo log 直接提交，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li>先写 binlog，然后写 redo log，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。<br>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</li>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。<br>这样就解决了数据一致性的问题。</li>
</ul>
</li>
</ul>
<h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><ul>
<li>binlog：二进制日志</li>
<li>redo log、undo log：事务日志<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2>binlog 用于记录数据库执行的<strong>写入性操作</strong>(不包括查询)信息，以二进制的形式保存在磁盘中。 binlog 是 mysql的<strong>逻辑日志</strong>，并且由 Server 层进行记录，使用任何存储引擎的 mysql 数据库都会记录 binlog 日志。</li>
<li>逻辑日志： 可以简单理解为记录的就是sql语句 。</li>
<li>物理日志： mysql 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>主从复制 ：在 Master 端开启 binlog ，然后将 binlog 发送到各个 Slave 端， Slave 端重放 binlog 从而达到主从数据一致。</li>
<li>数据恢复 ：通过使用 mysqlbinlog 工具来恢复数据。</li>
</ul>
<h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p>对于 InnoDB 存储引擎而言，只有在事务提交时才会记录 binlog ，此时记录还在内存中。mysql 通过 sync_binlog 参数控制 biglog 的刷盘时机，取值范围是 0-N：</p>
<ul>
<li>0：不去强制要求，由系统自行判断何时写入磁盘；</li>
<li>1（默认）：每次 commit 的时候都要将 binlog 写入磁盘；</li>
<li>N：每N个事务，才会将 binlog 写入磁盘。</li>
</ul>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>事务的持久性：只要提交成功，对数据库的修改就要永久保存。<br>内存与硬盘数据的一致性如何保证？最简单的方法是每次事务提交的时候就把涉及到的数据页全部刷写到磁盘中。可能每次事务只会改一个页里的几个字节，却要把整个页完整地刷新到磁盘（InnoDB以页为单位与磁盘交互），而且一个事务可能涉及多个数据页，这样性能太差。</p>
<ul>
<li>redo log：记录事务对数据页做了哪些修改。<br>redo log 包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo logfile)。 mysql 每执行一条 DML 语句，先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到 redo log file 。这种 先写日志，再写磁盘 的技术就是 MySQL里经常说到的 WAL(Write-Ahead Logging) 技术。</li>
<li>redo log记录数据页的变更（物理日志？）redo log采用大小固定、循环写入的方式，到达结尾时会回到开头循环写日志。日志上的记录在数据落盘后会被覆盖掉。（可以看出redo log和binlog的一些区别）</li>
</ul>
<p>binlog 和redo log的区别？<br><img src="./pics/binlog-vs-redolog.png" alt="BinlogVSRedolog"></p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>数据库事务四大特性中有一个是 原子性 ，具体来说就是 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。实际上， 原子性 底层就是通过 undo log 实现的。 undo log 主要记录了数据的逻辑变化，比如一条INSERT语句，对应一条 DELETE 的 undo log ，对于每个UPDATE 语句，对应一条相反的 UPDATE 的undo log ，这样在发生错误时，就能回滚到事务之前的数据状态。同时， undo log 也是 MVCC(多版本并发控制)实现的关键。</p>
<h1 id="MVCC（多版本并发控制）"><a href="#MVCC（多版本并发控制）" class="headerlink" title="MVCC（多版本并发控制）"></a>MVCC（多版本并发控制）</h1><ul>
<li>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。</li>
<li>只在<code>READ COMMITTED</code>和<code>READ REPEATABLE</code>隔离级别下工作。因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。<h2 id="MVCC在InnoDB中的实现"><a href="#MVCC在InnoDB中的实现" class="headerlink" title="MVCC在InnoDB中的实现"></a>MVCC在InnoDB中的实现</h2>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：<br>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。<br>INSERT时，保存当前事务版本号为行的创建版本号<br>DELETE时，保存当前事务版本号为行的删除版本号<br>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/2021%E6%98%A5%E6%8B%9B/" rel="tag"># 2021春招</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/26/redis/" rel="prev" title="Redis">
      <i class="fa fa-chevron-left"></i> Redis
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/26/%E9%A1%B9%E7%9B%AE/" rel="next" title="项目">
      项目 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E5%A4%A7%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.</span> <span class="nav-text">3大范式是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACID"><span class="nav-number">1.2.</span> <span class="nav-text">ACID</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MyISAM-vs-InnoDB"><span class="nav-number">2.</span> <span class="nav-text">MyISAM vs InnoDB</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">3.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">为什么要用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%B8%BA%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.</span> <span class="nav-text">为什么不为每一个列创建索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.3.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BTree%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.</span> <span class="nav-text">BTree索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B%E6%A0%91-vs-B-%E6%A0%91"><span class="nav-number">3.4.1.</span> <span class="nav-text">B树 vs B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.4.2.</span> <span class="nav-text">MyISAM实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.4.3.</span> <span class="nav-text">InnoDB实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">3.5.</span> <span class="nav-text">哈希索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-number">3.6.</span> <span class="nav-text">最左前缀原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">查询缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">事务的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">5.2.</span> <span class="nav-text">并发事务的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">事务的隔离级别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">MySQL 锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E7%85%A7%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">按照锁的粒度分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB-%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-number">6.2.</span> <span class="nav-text">共享&#x2F;排他锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%94%81"><span class="nav-number">6.3.</span> <span class="nav-text">其他锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81-Record-locks"><span class="nav-number">6.3.1.</span> <span class="nav-text">记录锁(Record locks)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81-Gap-locks-lt"><span class="nav-number">6.3.2.</span> <span class="nav-text">间隙锁(Gap locks) &lt;- ?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E9%94%AE%E9%94%81-Next-Key-locks-lt"><span class="nav-number">6.3.3.</span> <span class="nav-text">邻键锁(Next-Key locks) &lt;- ?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81-Insert-Intension-locks"><span class="nav-number">6.3.4.</span> <span class="nav-text">插入意向锁(Insert Intension locks)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81-AUTO-INC-locks"><span class="nav-number">6.3.5.</span> <span class="nav-text">自增锁(AUTO-INC locks)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="nav-number">7.</span> <span class="nav-text">大表优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%AE%9A%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%EF%BC%8C%E7%A6%81%E6%AD%A2%E4%B8%8D%E5%B8%A6%E4%BB%BB%E4%BD%95%E9%99%90%E5%88%B6%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="nav-number">7.1.</span> <span class="nav-text">限定数据范围，禁止不带任何限制范围条件的查询语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">7.2.</span> <span class="nav-text">读写分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%8C%BA"><span class="nav-number">7.3.</span> <span class="nav-text">垂直分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%8C%BA"><span class="nav-number">7.4.</span> <span class="nav-text">水平分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL"><span class="nav-number">7.5.</span> <span class="nav-text">SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95-1"><span class="nav-number">7.6.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="nav-number">7.7.</span> <span class="nav-text">模糊查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E9%94%AE"><span class="nav-number">7.8.</span> <span class="nav-text">外键</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%A0%E5%8C%96%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">池化（数据库连接池）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">SQL语句的执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="nav-number">9.1.</span> <span class="nav-text">主要组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">更新语句的执行流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E6%97%A5%E5%BF%97"><span class="nav-number">10.</span> <span class="nav-text">MySQL日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#binlog"><span class="nav-number">10.1.</span> <span class="nav-text">binlog</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">10.1.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="nav-number">10.1.2.</span> <span class="nav-text">刷盘时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redo-log"><span class="nav-number">10.2.</span> <span class="nav-text">redo log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undo-log"><span class="nav-number">10.3.</span> <span class="nav-text">undo log</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVCC%EF%BC%88%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">MVCC（多版本并发控制）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC%E5%9C%A8InnoDB%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.1.</span> <span class="nav-text">MVCC在InnoDB中的实现</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Freeman Huang</p>
  <div class="site-description" itemprop="description">Self-talking of a noob</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Freeman Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
