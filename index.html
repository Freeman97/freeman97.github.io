<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Self-talking of a noob">
<meta property="og:type" content="website">
<meta property="og:title" content="Freeman&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Freeman&#39;s Blog">
<meta property="og:description" content="Self-talking of a noob">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Freeman Huang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Freeman's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Freeman's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个菜鸡心血来潮搭建的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/06/HR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/06/HR/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-06 09:54:34 / 修改时间：10:36:35" itemprop="dateCreated datePublished" datetime="2021-04-06T09:54:34+08:00">2021-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="东方财富"><a href="#东方财富" class="headerlink" title="东方财富"></a>东方财富</h1><h2 id="用户角度"><a href="#用户角度" class="headerlink" title="用户角度"></a>用户角度</h2><ul>
<li>首先是一个互联网财经金融媒体，可以为投资者提供实时的财经资讯、市场行情咨询、投资产品的报价等。</li>
<li>运营有投资者互相交流的社区股吧，用户可以在股吧进行互动交流心得。</li>
<li>是一个金融交易平台，东方财富获得有一些基金销售牌照、期货经纪业务牌照等金融产品交易的牌照，用户可以直接通过东方财富提供的平台进行交易。</li>
<li>提供专业的金融数据服务，为用户提供财经数据、金融信息和分析结果等全方位的数据支持，也可以让用户实现个性化的信息查询和统计分析等需求。</li>
<li>一站式服务，东方财富这一平台可以实现用户的资讯获取、与其它投资者交流、数据分析和实际交易操作等需求。</li>
</ul>
<h2 id="企业角度"><a href="#企业角度" class="headerlink" title="企业角度"></a>企业角度</h2><ul>
<li>金融咨询和股吧可以积累用户流量，积累用户基数。</li>
<li>为用户提供交易服务，收取交易佣金。</li>
<li>拥有庞大的用户基数，为合作伙伴提供广告投放服务</li>
<li>为用户提供定制化、个性化服务：投资顾问、数据服务</li>
</ul>
<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>面试官您好我叫黄炽丰，本科毕业于华南理工大学数学学院信息管理与信息系统专业，现就读于南京大学软件学院电子信息专业（软件工程方向）。我本科期间参与了一些与计算机相关的课程，对计算机软件开发产生了一定的兴趣。于是在本科期间除了理论课程方面的学习，我还参与到了百步梯学生创新中心这个校级学生组织的技术部门中，参与了一些校内的项目研发工作，在期间积累了一些开发方面的技能和团队合作开发的经验。不过我本科期间主要积累了前端开发方面的经验，在本科生涯的后期发现自己更喜欢后端开发一些，于是决定继续攻读研究生，在后端开发方面积累更多的知识和经验。研究生期间，我除了在实验室跟导师进行偏向理论方面的项目研究之外，还自行完成了一些课内外的实践项目，进一步积累Java后端方面的开发技能。现在我的求职方向是后端开发方面的工作职位，我的自我介绍就是这些，谢谢。</p>
<h1 id="个人规划"><a href="#个人规划" class="headerlink" title="个人规划"></a>个人规划</h1><ul>
<li>我对我自己的期望是成长为技术骨干类型的角色。</li>
<li>首先我认为在工作的初期我会以技术积累为主。因为我对软件开发这个方向还是比较感兴趣比较喜欢的，如果希望在这个领域进一步发展，过硬的技术积累是必须的。</li>
<li>其次我认为在工作了一定时间之后，我认为我会尝试理解我当前负责的项目或就职的公司的业务特征。我对业务系统的实现比较感兴趣，并且我认为在企业的技术部门中，技术是很难脱离业务而存在的。理解了业务的程序员才能够更好的开发出能解决问题和产生价值的软件，同时在项目管理和技术选型方面，面对一些决策时能够做出更合理的决策。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/31/BigData/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/BigData/" class="post-title-link" itemprop="url">大数据相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-31 16:03:39" itemprop="dateCreated datePublished" datetime="2021-03-31T16:03:39+08:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-01 23:42:07" itemprop="dateModified" datetime="2021-04-01T23:42:07+08:00">2021-04-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><ul>
<li>大数据解决方案，分布式系统基础架构，主要包括HDFS和MapReduce。</li>
</ul>
<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><h3 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h3><ul>
<li>Master节点<ul>
<li>负责管理HDFS中的文件元信息、例如目录树、各个数据节点的可用空间、每个文件的备份情况等等。<ul>
<li>目录树</li>
<li>权限信息</li>
<li>记录HDFS中有哪些块</li>
<li>块到DataNode的映射</li>
</ul>
</li>
<li>负责监控各个DataNode的健康状况，如果发现无法连接到DataNode，会将该DataNode移出HDFS并重新备份该节点相关的数据，以满足集群中文件的备份数要求（默认每个文件每块都要有3个副本）。</li>
</ul>
</li>
<li>这些信息以两种形式保存在本地磁盘<ul>
<li>fsimage: HDFS元数据镜像文件，相当于全量备份</li>
<li>editlog: HDFS文件改动日志，相当于增量备份（对执行的修改进行备份）</li>
</ul>
</li>
</ul>
<h3 id="Secondary-NameNode（Hadoop-1-X的思路）"><a href="#Secondary-NameNode（Hadoop-1-X的思路）" class="headerlink" title="Secondary NameNode（Hadoop 1.X的思路）"></a>Secondary NameNode（Hadoop 1.X的思路）</h3><ul>
<li>定期合并fsimage和editlog并传输给NameNode，以减小editlog的体积。Secondary NameNode为了减轻NameNode的负担会帮其完成这项工作。</li>
<li>可以作为备份节点作为NameNode的元数据进行热备份<ul>
<li>云玩家方案：定期备份，但是两次备份期间的修改会被丢失</li>
<li>真实方案：的确是定期备份。。。<ul>
<li>每隔1小时会进行一次合并，editlog中的事务条数达到某个数字也会进行一次合并。<h4 id="合并fsimage和editlog的流程"><a href="#合并fsimage和editlog的流程" class="headerlink" title="合并fsimage和editlog的流程"></a>合并fsimage和editlog的流程</h4></li>
</ul>
</li>
</ul>
</li>
<li>生成一个新文件<code>edits.new</code>，用于记录合并过程中产生的日志信息</li>
<li>Secondary NameNode从NameNode上读取edits文件和fsimage文件，并进行合并操作，生成一个<code>fsimage.ckpt</code>文件。</li>
<li>将生成的合并后的文件发送到NameNode上，让NameNode替换原本的fsimage</li>
<li>用<code>edits.new</code>成为新的edits文件。</li>
</ul>
<h3 id="Standby-NameNode-共享存储-since-Hadoop-2-X"><a href="#Standby-NameNode-共享存储-since-Hadoop-2-X" class="headerlink" title="Standby NameNode + 共享存储(since Hadoop 2.X)"></a>Standby NameNode + 共享存储(since Hadoop 2.X)</h3><ul>
<li>只有主NameNode可以对外提供读写服务，StandBy NameNode作为备份。</li>
<li>ZKFailOverController：检测到NameNode的健康状况，在主NameNode故障时，借助Zookeeper实现自动的主备选举和切换。</li>
<li>ZK集群：提供选举支持</li>
<li>共享存储系统：保证Active NameNode和Standby NameNode能够实现元数据同步。主备切换时新的主NameNode需要确认元数据能够完全同步。</li>
</ul>
<h4 id="QJM-Quorum-Journal-Manager"><a href="#QJM-Quorum-Journal-Manager" class="headerlink" title="QJM(Quorum Journal Manager)"></a>QJM(Quorum Journal Manager)</h4><ul>
<li>HDFS的默认共享存储方案</li>
<li>ActiveNameNode每次写Editlog时都需要向JournalNode集群的每一个JournalNode发送写请求，让每个JournalNode写入相同的内容，只要大多数JournalNode节点返回成功就认为向集群写入EditLog成功。对于2N + 1台JournalNode，最多可以有N台机器挂掉。剩下的N + 1台机器如果能够保持一致，仍然能够构成“大多数”。</li>
<li>向JournalNode提交Editlog是同步阻塞的，但是只需要接收到大多数JournalNode的返回就可以了。</li>
<li>如果没有收到大多数的Editlog返回，则认为提交EditLog失败了。（如果借鉴Paxos算法的经验，此处应该有一个版本号，提交失败的时候，说明当前NameNode的数据版本可能落后于JournalNode集群，不应该继续对外提供服务了）此时NameNode会停止服务。</li>
<li>Editlog的分代和分段同步：每个JournalNode只会接收比自身代数大的Editlog同步请求。<ul>
<li>增量同步：存在跨度问题，如果本地和最新版本差了不止一代，只添加一个增量也是错误的EditLog</li>
<li>全量同步：每次都传一个最新版本的EditLog，EditLog文件可能会很大。</li>
<li>分段全量同步：fsimage：当前元信息的完整快照。Active NameNode定期完成fsimage和editlog的合并（借助Secondary NameNode），将旧的editlog截断并只同步最新一段的editlog。Standby NameNode也需要进行fsimage和editlog的合并</li>
</ul>
</li>
<li>主备切换<ul>
<li>ZK方式：让NameNode和ZK维持会话，使ZK能够监控NameNode的健康状况。发生主备切换时，多个StandBy NameNode可能会竞争成为Active NameNode，此时让ZK支持主节点的选举（本质是获得一个分布式锁？）。</li>
<li>只有代数高的节点能够对元信息进行写，但是客户端有可能读到旧的信息。HDFS提供fencing机制，当完成主备切换时，使用一定的机制让原本的Active NameNode停止对外服务。默认是通过ssh的方式发送一条命令，杀掉原本的NameNode进程。</li>
</ul>
</li>
</ul>
<h4 id="StandBy-NameNode"><a href="#StandBy-NameNode" class="headerlink" title="StandBy NameNode"></a>StandBy NameNode</h4><ul>
<li>Standby NameNode会从JournalNode定期同步editlog，当需要转换为NameNode时需要将落后的Editlog补回来。</li>
</ul>
<h3 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h3><ul>
<li>完成实际的数据存储，并向NameNode定期发送心跳便于双方感知对方存在。HDFS以固定大小的块存储文件内容。文件会被切分为若干块存储到不同的DataNode中，同时会将同一个块写到3个不同的DataNode上。文件切割需要由客户端完成，但是文件块的复制对用户透明。</li>
<li>DataNode把每个数据块存在单独的文件中。它不在同一个目录创建所有的文件，而是通过试探的方法确定每个目录的最佳文件数目。</li>
<li>DataNode的状态报告：本地文件对应HDFS数据块的列表，作为报告发送到NameNode。</li>
</ul>
<h3 id="HDFS上传文件的流程"><a href="#HDFS上传文件的流程" class="headerlink" title="HDFS上传文件的流程"></a>HDFS上传文件的流程</h3><ol>
<li>Client向NameNode请求数据上传，先告知NameNode自己需要上传的元数据信息（包括大小吗）</li>
<li>NameNode对上传文件的请求进行检查。例如重名校验和权限校验等。如果检查通过，NameNode会写Editlog，然后修改内存中的元数据信息。</li>
<li>NameNode向客户端响应可以上传文件。</li>
<li>Client在本地将文件进行分割，分割成固定大小的块。按顺序向NameNode请求上传块。</li>
<li>NameNode向Client返回可以上传的节点信息。节点信息是顺序返回的。</li>
<li>Client向返回的DataNode发出传输通道建立请求。第一位的DataNode在收到通道建立请求后也会递归地向下一位DataNode发送通道建立请求。之后DataNode递归地应答通道建立请求，收到所有的通道建立应答后，第一为的DataNode会返回信息示意Client可以开始传输文件。</li>
<li>Client会将每个Block上传到通道第一位的DataNode上，通道中的DataNode按顺序完成Block的复制。（这里不清楚是同步的还是异步的，但是肯定会有确认）。<ul>
<li>想要异步复制，可以设置<code>dfs.replication.min</code>，只让最低限度的DataNode先建立通道并完成复制。然后再让NameNode检测到该块未达到复制因子时决定DataNode怎么复制。</li>
</ul>
</li>
<li>重复以上流程，Client将所有分块传输完毕会向NameNode进行报告。</li>
</ol>
<h3 id="HDFS下载文件的流程"><a href="#HDFS下载文件的流程" class="headerlink" title="HDFS下载文件的流程"></a>HDFS下载文件的流程</h3><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><ul>
<li>同样使用Master-Slave架构：JobTracker - TaskTracker。Slave节点向Master节点发送心跳消息以让双方感知对方存在。</li>
<li>只有Map和Reduce函数，更高级的计算范式需要用户手动根据Map和Reduce进行构造。</li>
<li>所有的计算中间结果都需要保存在HDFS上，计算过程需要反复地读写磁盘。</li>
</ul>
<h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><ul>
<li>主要提供一个全面、统一的框架来管理有不同性质的数据集和数据源的大数据处理需求。</li>
<li>更多的计算范式，不局限于Map和Reduce</li>
<li>优化的磁盘使用方式：相比于Hadoop MapReduce，尽可能少地读写磁盘。（只有Shuffle的时候将数据完全存放在磁盘？）</li>
<li>DAG计算模型：根据RDD的依赖关系先计算得到DAG，如果不涉及与其它节点进行数据交换（Shuffle），Spark可以尽可能地在内存中完成这些操作。（减少不了Shuffle，这个是由计算的依赖关系决定的）</li>
<li>Spark Core：定义RDD的API，操作。</li>
<li>Spark Streaming: 允许程序像处理普通RDD一样处理实时数据（流数据）</li>
<li>Spark GraphX：控制图、并行图操作和计算的一组算法和工具的集合。</li>
</ul>
<h2 id="Cluster-Manager"><a href="#Cluster-Manager" class="headerlink" title="Cluster Manager"></a>Cluster Manager</h2><ul>
<li>Master节点，控制整个集群，监控Worker<h2 id="Worker：控制计算节点，启动Executor或者Driver"><a href="#Worker：控制计算节点，启动Executor或者Driver" class="headerlink" title="Worker：控制计算节点，启动Executor或者Driver"></a>Worker：控制计算节点，启动Executor或者Driver</h2><ul>
<li>Driver：运行Application的main函数</li>
<li>Executor: 为某个Application运行在Worker Node上的一个进程。</li>
</ul>
</li>
</ul>
<h2 id="Spark计算模型"><a href="#Spark计算模型" class="headerlink" title="Spark计算模型"></a>Spark计算模型</h2><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>最小的计算单元</li>
<li>RDD不会将<strong>所有的</strong>中间结果存放在硬盘上，只会在内存不足时将部分中间结果存放在内存。</li>
<li>弹性：<ul>
<li>存储的弹性：内存和磁盘可以进行自动切换</li>
<li>容错：数据丢失可以自动回复（Linage？）</li>
<li>计算：计算出错可以重试</li>
<li>分片：根据需要重新分片</li>
</ul>
</li>
<li>分布式：数据存储在集群的不同节点</li>
<li>封装计算逻辑而不是持有数据</li>
<li>不可变：逻辑不可改变，如果需要执行新逻辑需要创建新RDD。（转换…）</li>
<li>可分区、并行计算。</li>
</ul>
<h4 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h4><ul>
<li>分区列表：用于执行任务时进行并行计算</li>
<li>分区计算函数：每个分区的数据不同，但是计算逻辑是一样的。计算逻辑对每个分区的数据进行计算</li>
<li>依赖关系：依赖的所有RDD</li>
<li>分区器：可选、决定对数据进行分区的方式</li>
<li>首选位置：确定计算发送给哪个节点。（让效率最优）<ul>
<li>移动计算胜过移动数据</li>
</ul>
</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol>
<li>从HDFS/与HDFS兼容的其它持久化存储系统如Hive、Canssandra、HBase输入创建</li>
<li>从本地文件创建</li>
<li>从父RDD转换得到新RDD</li>
<li>通过parallelize或makeRDD将单机数据转换为RDD</li>
</ol>
<h4 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h4><ul>
<li>Transformation：延迟计算，等到Action操作才会触发计算。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/30/linux/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-30 23:45:25" itemprop="dateCreated datePublished" datetime="2021-03-30T23:45:25+08:00">2021-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-31 10:37:10" itemprop="dateModified" datetime="2021-03-31T10:37:10+08:00">2021-03-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h3><ul>
<li>查看进程信息<ul>
<li><code>ps -aux</code>/<code>ps -ef</code>：查看所有进程</li>
<li><code>-p [pid]</code>: 查看指定PID的进程<h3 id="top-htop"><a href="#top-htop" class="headerlink" title="top/htop"></a><code>top</code>/<code>htop</code></h3></li>
</ul>
</li>
<li>动态地展示Linux进程运行情况。包括PID、用户、内存占用率、CPU占用率、启动命令等信息。</li>
</ul>
<h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a><code>pstree</code></h3><ul>
<li>将所有进程以树状图显示。</li>
</ul>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a><code>vmstat</code></h3><ul>
<li>查看虚拟内存状态<h4 id="进程状态procs"><a href="#进程状态procs" class="headerlink" title="进程状态procs"></a>进程状态procs</h4></li>
<li>r:运行队列中的内核线程数目</li>
<li>b:等待队列中的内核线程数目<h4 id="内存状态memory"><a href="#内存状态memory" class="headerlink" title="内存状态memory"></a>内存状态memory</h4></li>
<li>swpd: 虚拟内存大小(k)</li>
<li>free: 空闲内存大小(k)</li>
<li>buff: 已经使用的buff大小(读写缓冲区)</li>
<li>cache: 已经使用的cache大小</li>
<li>inact: 非活跃内存大小，可以回收的内存</li>
<li>active: 活跃内存大小<h4 id="交换空间状态swap"><a href="#交换空间状态swap" class="headerlink" title="交换空间状态swap"></a>交换空间状态swap</h4></li>
<li>si: 每秒从交换区写入内存的大小</li>
<li>so: 每秒从内存写到交换区的大小<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4></li>
<li>bi：每秒读取的块数（包括磁盘在内的所有块设备）</li>
<li>bo：每秒写入的块数（包括磁盘在内的块数量）<h4 id="系统调用情况system"><a href="#系统调用情况system" class="headerlink" title="系统调用情况system"></a>系统调用情况system</h4></li>
<li>in: 每秒中断数，包括时钟中断</li>
<li>cs：每秒上下文切换数：系统调用和进程/线程切换需要进行上下文切换。值太大时要考虑减少进程或线程的数目<h4 id="CPU（单位百分比）"><a href="#CPU（单位百分比）" class="headerlink" title="CPU（单位百分比）"></a>CPU（单位百分比）</h4></li>
<li>us：用户进程消耗CPU时间</li>
<li>sy：系统进程消耗CPU时间</li>
<li>id：空闲时间</li>
<li>wa：等待IO时间</li>
</ul>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a><code>lsof</code></h3><ul>
<li>List Open Files, 展示打开的文件。文件可以是一个普通文件，一个目录，一个库，一个网络文件（例如socket）<ul>
<li><code>-i [地址]</code>：列出所有文件，IP地址和指定参数匹配。如果不指定参数，则选出所有的网络文件。<ul>
<li><code>[4/6][protocol][@hostname|hostaddr][:service|port]</code>：可以指定过滤参数。<code>[4/6]</code>指IP版本</li>
</ul>
</li>
<li><code>-p [pid]</code>: 查看指定进程已经打开的文件</li>
<li><code>-c [command]</code>: 选出指定命令正在使用的文件</li>
</ul>
</li>
</ul>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><code>netstat</code></h3><ul>
<li>显示网络连接、路由表、接口信息、多播成员等。<ul>
<li><code>-t</code>: 只显示TCP连接</li>
<li><code>-u</code>：只显示UDP连接</li>
<li><code>-l</code>：只展示listening的socket</li>
<li><code>-a</code>：展示listening和non-listening的socket</li>
<li><code>-n</code>：显示数字地址(numerical address)</li>
<li><code>-p</code>：显示socket所属的PID和进程的名称</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/JAVASE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/JAVASE/" class="post-title-link" itemprop="url">Java基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 23:30:01" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-04 18:43:54" itemprop="dateModified" datetime="2021-04-04T18:43:54+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><ul>
<li>静态代理的麻烦：要为每一个实现类单独写一个代理类。<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2></li>
<li>对于实现了某个接口的类，能够直接生成<strong>接口的</strong>的代理对象（而不用写代理类）。</li>
<li>基本原理：利用Java反射机制</li>
<li>基本思路：<ol>
<li>接口有方法的定义，但是没有方法体，也没有构造器。通过反射的某个方法根据接口的方法信息创建一个有相同类结构信息但是有构造器的<strong>某个</strong>类。 -&gt; <code>java.lang.reflect.Proxy</code>类，提供静态方法<code>getProxyClass(ClassLoader loader, Class&lt;?&gt; ... interfaces)</code>，只要提供一个类加载器和接口(数组)，就可以生成一个代理类的<code>Class</code>对象。而这个代理类是有构造器的(可以通过<code>Class</code>对象调用<code>getConstructors()</code>)。该类没有无参构造器，需要传入实现<code>InvocationHandler</code>的类实例。</li>
<li>接口的方法体为空，在代理对象中使用传入的实现了<code>InvocationHandler</code>的实例即可利用代理目标在代理对象中执行代理目标的方法，并在代理目标的方法调用前后进行额外的操作或控制。代理对象需要持有实现了<code>InvocationHandler</code>接口的实例。在代理对象上调用代理目标的方法时，代理对象会通过实现了<code>InvocationHandler</code>的实例，将调用转移到代理目标上。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中，<code>proxy</code>为代理对象本身（而不是代理目标）。<code>method</code>为调用的方法，需要对<code>method</code>指定执行方法的目标才可以通过该参数调用方法。<code>args</code>为传入的参数。总之，单独有实现了<code>InvocationHandler</code>接口的实例还是不能正常地调用目标对象的方法，我们需要设法让<code>invoke</code>方法中可以获得到目标对象的引用。方法之一是让实现了<code>InvocationHandler</code>的类持有代理目标的引用（可以用构造函数传参的方式）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Objcet <span class="title">invoke</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>更简单地获得代理对象的方法：<code>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</code></li>
</ol>
</li>
</ol>
</li>
<li>优点：不用写代理类，直接生成代理对象。接口增加新方法时，代理对象可以不用进行修改。</li>
<li>缺点：只能对实现了接口的类使用。在代理对象上只能调用接口中定义的方法。</li>
</ul>
<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><ul>
<li>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。CGLIB属于开源项目，需要额外依赖。</li>
<li>基本思路：<ol>
<li>自定义<code>MethodInterceptor</code>并重写<code>intercept</code>方法。该方法用于拦截增强代理目标的方法，类似于JDK动态代理的<code>invoke</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中<code>o</code>是已经被增强的代理目标(the enhanced object)，<code>method</code>是被增强的方法(Intercepted Method)，<code>args</code>是方法调用的参数。<code>methodProxy</code>用于调用原始方法(super method, non-intercepted method)。<ol>
<li>获得代理类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设需要代理的目标类的Class对象是clazz</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">enhancer.setSuperclass(clazz);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> MyInterceptor());</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>CGLIB动态代理是通过生成一个代理目标的子类来拦截代理类的方法调用，因此不能代理声明为<code>final</code>的类和方法。</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p><img src="pics/JAVASE/java-collection-hierarchy.png" alt="javaColletion"></p>
<h2 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h2><ul>
<li>不同的接口，<code>Comparable</code>的方法是<code>compareTo(obj)</code>，<code>Comparator</code>的方法是<code>compare(obj1, obj2)</code></li>
</ul>
<h2 id="集合底层数据结构"><a href="#集合底层数据结构" class="headerlink" title="集合底层数据结构"></a>集合底层数据结构</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><code>ArrayList</code>、<code>Vector</code>: <code>Object[]</code>数组。<code>Vector</code>线程安全。</li>
<li><code>ArrayList</code>:<ul>
<li>真正持有函数的成员为<code>transient Object[] elementData</code></li>
<li>无参构造时，为<code>elementData</code>赋予静态成员<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code></li>
<li>带参构造时，如果参数<code>initialCapacity</code>为0，那么为<code>elementData</code>赋予静态成员<code>EMPTY_ELEMENTDATA</code>。如果参数为正整数则为<code>elementData</code>初始化一个指定容量的新数组。其他情况则抛出异常。</li>
<li>带参构造时，如果参数为空的集合(不是<code>null</code>)，那么也赋予<code>elementData</code>静态成员<code>EMPTY_ELEMENTDATA</code>的值</li>
<li>调用<code>add</code>方法时要调用<code>ensureCapacityInternal</code>方法保证数组容量足够。</li>
<li>无论如何，如果最开始不显式指定容量或者使用非空集合创建<code>ArrayList</code>，<code>ArrayList</code>都会将创建<code>DEFAULT_CAPACITY</code>个元素这一行为推迟到向<code>ArrayList</code>加入第一个元素时。</li>
<li><code>ArrayList</code>的扩容过程：<ol>
<li>首先计算扩容后的最小容量。如果当前数据为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，则扩容后容量至少为<code>Math.max(DEFAULT_CAPACITY, minCapacity)</code>。<code>DEFAULT_CAPACITY</code>为10。否则扩容后容量至少为<code>size + 1</code></li>
<li>如果<code>minCapacity &gt; elementData.length</code>则需要扩容。扩容的总体规则是，如果旧容量的1.5倍大于<code>minCapacity</code>则扩容1.5倍，否则扩容到<code>minCapacity</code>。此时创建扩容后的新数组并把原本存放在<code>elementData</code>中的元素复制到新数组</li>
<li>Java数组存在最大容量。最大容量一般稍微小于<code>Integer.MAX_VALUE</code>。<code>ArrayList</code>内部用<code>MAX_ARRAY_SIZE</code>保存一个稍微小于<code>Integer.MAX_VALUE</code>的值。如果出现了计算得到的新数组容量存在<code>newCapacity - MAX_ARRAY_SIZE &gt; 0</code>的情况，则判断<code>minCapacity</code>有没有溢出。如果溢出了32位整数的取值范围，则抛出OOM异常，如果没有溢出，则新容量为<code>(minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE</code>。</li>
</ol>
<ul>
<li>为什么要区分<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和<code>EMPTY_ELEMENTDATA</code>？（since Java 8）<ul>
<li>为了区分 “我就是要一个初始容量为0的<code>ArrayList</code>（显示指定初始容量为0，使用空集合初始化<code>ArrayList</code>）” 和 “我想要一个初始容量为<code>DEFAULT_CAPACITY</code>的<code>ArrayList</code>，但是我不一定马上要用，因此先返回容量为0的数组，等我要用的时候(第一次加入元素的时候)，再给我一次扩容上来” 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>LinkedList</code>: 双向（不循环）链表</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li><code>HashSet</code>: 基于<code>HashMap</code>实现，底层使用<code>HashMap</code>，使用成员对象来计算hashcode<ul>
<li>检查重复的方法：先计算hashcode值来判断对象加入的位置，同时与其它对象的hashcode值进行比较。如果发现相同hashcode值的对象，需要调用<code>equals</code>方法来检测对象是否真正相同。（hashcode的定义：同一个对象不可能有两个hashcode，不同对象的hashcode可能相同，其实就是“函数”的定义）</li>
</ul>
</li>
<li><code>LinkedHashSet</code>: 基于<code>LinkedHashMap</code>，能够按照添加的顺序进行遍历</li>
<li><code>TreeSet</code>: 有序，能按照添加元素的顺序进行遍历，唯一，基于红黑树</li>
</ul>
<h3 id="Map-需要重新看"><a href="#Map-需要重新看" class="headerlink" title="Map(需要重新看)"></a>Map(需要重新看)</h3><ul>
<li><code>HashTable</code>：内部方法都是synchronized的，线程安全。</li>
<li><code>HashMap</code>: 底层数据结构是数组+链表/红黑树。使用拉链法解决哈希冲突，JDK 1.8引入红黑树来优化过长的链表。HashMap会重新计算键的哈希值而不是使用hashCode。<ul>
<li>初始大小(<code>capacity</code>)为16，每次扩容时容量为原来的2倍。<code>HashMap</code>会让集合中的元素保持在一个合理的范围内（由装填因子load factor限制），如果元素数超过指定的阈值<code>this.threshold</code>时，则需要进行扩容并进行rehash。</li>
<li><code>HashMap</code>总是使用2的幂作为哈希表<code>capacity</code>的大小。目的是为了加快通过hash计算KV对存储位置的速度。</li>
<li>使用Key来计算hashcode。通过key的hashcode经过<code>HashMap</code>的扰动函数<code>hash()</code>处理(防止较差的<code>hashCode()</code>实现导致<code>HashMap</code>性能下降)后得到真正的hash值，然后通过<code>(n - 1) &amp; hash</code>（<code>n</code>为HashMap数组的长度，该运算等价于用hash对长度取余）的方式计算当前元素要存储的位置。</li>
<li>Table数组：hash表的桶(bucket)。数组的每个位置上都是一个链表。当链表长度大于阈值（默认为8）时，如果当前数组长度小于64，则进行数组扩容，否则将这个链表转换为红黑树。<br><img src="pics/jdk1.8之后的内部结构-HashMap.png" alt="HashMap"><ul>
<li>红黑树：<ul>
<li>首先是一种二叉搜索树：左子树小于根小于右子树</li>
<li>根节点是黑色，叶子节点（Nil）是黑色</li>
<li>每个红色节点的叶子节点都是黑色</li>
<li>任意节点到每个叶子节点的路径都有数量相同的黑色节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>TreeMap</code>实现了<code>NavigableMap</code>实现对集合内元素的搜索能力，实现<code>SortedMap</code>来实现对元素根据key进行排序的能力。</li>
<li><code>HashMap</code>不是线程安全的</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>初始容量<code>initialCapacity</code></li>
<li>负载因子<code>loadFactor</code></li>
<li>阈值<code>threshold</code>: 键值对数超过这个值要扩容</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul>
<li>需要用插入键值对的key的hashCode进行再次hash<ul>
<li>hash方法的规则：如果key为null则返回0。否则计算<code>hashcode ^ (hashcode &gt;&gt;&gt; 16)</code></li>
<li>目的：<ol>
<li>对hashCode进行扰动，防止分布性不佳的hashCode影响HashMap的性能</li>
<li>当数组长度n比较小时可能只有hashCode的低位信息能参与计算，用hashcode的高16位和低16位进行异或，变相让hashcode的高位参与计算，提高了hash值的随机性。</li>
</ol>
</li>
</ul>
</li>
<li>用<code>(n - 1) &amp; hash</code>的方法将hash对数组长度进行求余，效率高。但这要求数组长度必须是2的幂</li>
</ul>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul>
<li>迭代器<code>HashIterator</code>：<ul>
<li>构造方法：找到第一个包含链表节点引用的桶</li>
<li><code>nextNode</code>方法：如果当前节点非空，则返回的是当前节点，同时如果当前节点的next字段为空（当前桶没有下一个元素了），则寻找下一个包含节点引用的桶。</li>
</ul>
</li>
</ul>
<h4 id="插入（重点）"><a href="#插入（重点）" class="headerlink" title="插入（重点）"></a>插入（重点）</h4><h5 id="插入操作总体逻辑"><a href="#插入操作总体逻辑" class="headerlink" title="插入操作总体逻辑"></a>插入操作总体逻辑</h5><ol>
<li>首先通过hash方法（<code>hashcode ^ (hashcode &gt;&gt;&gt; 16)</code>）计算出真正要使用的<code>hash</code>值</li>
<li>HashMap桶数组初始化可以延迟到第一次插入时。开始插入时首先判断table是否被初始化。如果没有则需要初始化。</li>
<li>通过<code>(n - 1) &amp; hash</code>计算出桶的位置，如果此处还没有节点，直接新建节点存入该桶即可。</li>
<li>否则，开始查找该桶中存不存在Key相同的节点<code>e</code><ul>
<li>如果节点是链表节点，则对链表进行遍历，找不到key相同的节点时将节点插入到链表的尾部。如果链表的长度在插入后大于等于树化阈值，则要将链表转换为红黑树。</li>
<li>如果节点是树节点，则调用红黑树的插入方法。</li>
<li>如果在定位插入位置的时候找到了Key相同的节点，则会返回Key相同的节点而不会进行插入。</li>
</ul>
</li>
<li>判断要插入的键值对是否已经存在(<code>e != null</code>)。如果已经存在，则用新的值替换旧的值，并返回旧的值。否则，说明上一步进行过插入操作，如果插入后节点数量大于阈值，则需要对数组进行扩容。</li>
</ol>
<h5 id="链表树化机制"><a href="#链表树化机制" class="headerlink" title="链表树化机制"></a>链表树化机制</h5><ul>
<li>如果只使用链表，当发生碰撞的次数过多性能会下降，JDK1.8引入红黑树来处理这个问题</li>
<li>树化链表需要满足：<ol>
<li>桶数组长度大于等于<code>MIN_TREEIFY_CAPACITY = 64</code>。原因可能是因为当桶数组容量较小时，键值对出现哈希冲突的概率会比较高，较容易导致链表长度较长。高碰撞率是因为桶数组容量较小时，应该有限扩容桶数组。并且桶容量较小时，扩容会比较频繁，而扩容时需要拆分红黑树并且进行重新映射。</li>
<li>链表长度大于等于<code>TREEIFY_THRESHOLD = 8</code>。</li>
</ol>
</li>
<li>链表树化的比较依据（Key不要求实现Comparable接口）：<ol>
<li>比较key之间的hash大小，如果hash相同则继续</li>
<li>检测键是否实现了Comparable接口，如果实现则调用compareTo进行比较，否则继续</li>
<li>如果仍不能比较出大小，使用tieBreakOrder进行仲裁确定顺序</li>
</ol>
</li>
<li>TreeNode节点仍保持了next引用和prev引用（链表型节点是单链表，TreeNode才会有prev引用），链表树化之后原链表的顺序会得到保留</li>
</ul>
<h5 id="桶数组扩容机制"><a href="#桶数组扩容机制" class="headerlink" title="桶数组扩容机制"></a>桶数组扩容机制</h5><ul>
<li>使用<code>resize</code>方法进行扩容</li>
<li>计算出新数组容量和新阈值</li>
<li>根据新容量创建新的桶数组</li>
<li>将键值对节点重新映射到新的桶数组。如果节点是TreeNode类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li>
</ul>
<ol>
<li>计算出新数组容量和新阈值<ol>
<li>当<code>oldCap &gt; 0</code>时，桶数组<code>table</code>已经被初始化<ol>
<li>当<code>oldCap &gt;= MAXIMUM_CAPACITY</code>(2^30)时，不再扩容</li>
<li>当<code>newCap &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY</code>时，会通过乘以2的方式计算新阈值，此时新阈值<code>newThr = oldThr &lt;&lt; 1</code>可能会溢出。（<code>loadFactor</code>可能大于1）</li>
</ol>
</li>
</ol>
</li>
<li>创建数组</li>
<li>键值对节点的重新映射：对于树形节点，需要先拆分红黑树再进行映射。对于链表型节点，需要先对链表进行分组再映射。<ul>
<li>扩容后的数组长度为原数组长度的两倍，并且数组的长度永远是2的幂</li>
<li>对链表型节点的分组映射<ul>
<li>对于扩容前的长度<code>m</code>和扩容后的长度<code>n</code>，<code>n - 1</code>比<code>m - 1</code>在最高有效位上多一位1。</li>
<li>举例：如果原容量为16，扩容后为32，那么<code>16 - 1 = 15</code>的二进制表示为<code>0000 1111</code>, <code>32 - 1 = 31</code>的二进制表示为<code>0001 1111</code></li>
<li>因此可知扩容后，链表中的元素会根据第5位为1还是0被分成两组。使用<code>m &amp; hash</code>(即<code>oldCap &amp; hash</code>)的值即可判断元素应该属于哪一组</li>
<li>遍历旧链表，根据当前元素<code>oldCap &amp; hash</code>的计算结果是否为0，可以将链表中的旧元素使用尾插法插入两个新链表中，完成链表分组。</li>
<li>最后将两条新链表分别确定插入位置后插入桶中即可完成扩容中的重新映射步骤。<ul>
<li>确定的方式：假设原链表所在的数组位置为<code>index</code>。对于新参与<code>hash &amp; (n - 1)</code>计算的位为1的所有节点，该位的新结果必定为1。因此这些节点的新位置应该为<code>index + m</code>，即<code>index + oldCap</code>。相对的，对于该位为0的所有节点，扩容后<code>hash &amp; (n - 1)</code>的计算结果会与原来保持不变，因此这些节点的位置不会改变。</li>
</ul>
</li>
</ul>
</li>
<li>对树形节点的拆分和重映射<ul>
<li>树形节点的分组方式和链表型节点是一样的，也是通过<code>oldCap &amp; hash</code>的方式确定分组。然后以遍历链表的方式(利用next引用)遍历红黑树，将树中的节点用尾插法插入到两个链表中。</li>
<li>分别确定两个链表的新插入位置并将两个链表插入新位置。</li>
<li>如果链表长度小于等于<code>UNTREEIFY_THRESHOLD = 6</code>，则将原本的红黑树转换为链表。</li>
<li>否则，如果另一个链表不为空，说明当前链表中的一部分节点重新分组到了另一个链表，需要对当前链表重新进行树化。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol>
<li>定位桶的位置</li>
<li>如果是TreeNode类型，用红黑树的查找逻辑定位到待删除节点，调用删除方法</li>
<li>如果是链表类型，找到待删除节点和它的前驱节点，删除待删除结点。</li>
</ol>
<h4 id="为什么桶数组table被transient修饰"><a href="#为什么桶数组table被transient修饰" class="headerlink" title="为什么桶数组table被transient修饰"></a>为什么桶数组table被transient修饰</h4><ul>
<li>HashMap不使用默认的序列化机制，而是使用<code>readObject</code>/<code>writeObject</code>两个方法定制了序列化和反序列化的过程。</li>
<li>只要保存了键值对，桶数组可以根据键值对的数据重建HashMap</li>
<li>由于装填因子的设置，多数情况下table无法被存满，保存table会浪费空间</li>
<li>如果键对象没有重写hashCode方法，计算hash时需要使用<code>Object</code>类的hashCode方法，而该方法不同的JVM的实现可能不同。如果同一个键产生了不同的Hash，原本的table就无法继续使用了。</li>
</ul>
<h4 id="为什么TREEIFY-THRESHOLD的取值是8"><a href="#为什么TREEIFY-THRESHOLD的取值是8" class="headerlink" title="为什么TREEIFY_THRESHOLD的取值是8"></a>为什么TREEIFY_THRESHOLD的取值是8</h4><p>理想状态下，在默认装填因子为0.75时，容器中的节点遵循参数λ=5的泊松分布。链表中的元素达到8个的概率是非常低的。</p>
<h4 id="为什么UNTREEIFY-THRESHOLD的取值是6（而不是7）"><a href="#为什么UNTREEIFY-THRESHOLD的取值是6（而不是7）" class="headerlink" title="为什么UNTREEIFY_THRESHOLD的取值是6（而不是7）"></a>为什么UNTREEIFY_THRESHOLD的取值是6（而不是7）</h4><p>如果为7，删除一个元素就会转换成链表，插入一个元素又会转换成红黑树。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/JMM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/JMM/" class="post-title-link" itemprop="url">Java内存模型(JMM)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:14" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="从CPU-寄存器-高速缓存-内存说起"><a href="#从CPU-寄存器-高速缓存-内存说起" class="headerlink" title="从CPU-寄存器-高速缓存-内存说起"></a>从CPU-寄存器-高速缓存-内存说起</h1><ul>
<li>问题：CPU不可能只靠寄存器来完成运算任务，但CPU的速度和内存的存取速度相差太远。</li>
<li>解决：引入高速缓存来缓和CPU速度和内存存取速度的差异。CPU直接独写高速缓存，运算结束再将数据从缓存同步回内存中。</li>
<li>新的问题：缓存一致性。多个CPU有自己的高速缓存，但是他们共享同一个内存，如果多个CPU的运算涉及同一个内存区域将产生数据的不一致问题。此时需要引入缓存一致性协议。<ul>
<li>处理器对内存的读写操作的执行顺序，不一定与内存实际发生的独写顺序一致。</li>
</ul>
</li>
</ul>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul>
<li>一组规范，并不真实存在，定义了一组规则，定义了程序中各个变量的访问方式(确认一段程序的执行轨迹是否是合法的)。</li>
<li>检查程序执行轨迹的每个读操作，根据一些规则检查读操作观察到的写操作是否是有效的。</li>
<li>JMM的实现可以是任意的，只要生成的代码的执行结果能够根据JMM的规则进行预测即可（松规范，给编译器/JVM实现者进行优化的空间，比如指令重排序或者移除不必要的同步）。</li>
</ul>
<h2 id="JMM的规定"><a href="#JMM的规定" class="headerlink" title="JMM的规定"></a>JMM的规定</h2><ul>
<li>所有共享变量（不包括局部变量，局部变量线程私有）都存储于主内存。共享变量：实例变量、类变量（静态字段）、数组元素。</li>
<li>每一个线程还在自己的工作内存中保留了被线程使用的变量的工作副本。</li>
<li>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</li>
<li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</li>
<li>intra-thread semantics: 保证重排序不会改变单线程内的程序执行结果。</li>
<li>对指令的重排序：<ul>
<li>as-if-serial：不能改变单线程程序的语义，重排序后单线程程序的执行结果不能被改变。</li>
<li>不存在数据依赖性的情况下，处理器可以进行重排序<ul>
<li>两个操作访问同一个变量，且其中一个操作为写操作，此时两个操作之间存在依赖性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Java内存模型的三大特性（JMM在多线程环境下的三个问题）"><a href="#Java内存模型的三大特性（JMM在多线程环境下的三个问题）" class="headerlink" title="Java内存模型的三大特性（JMM在多线程环境下的三个问题）"></a>Java内存模型的三大特性（JMM在多线程环境下的三个问题）</h2><ol>
<li>可见性：一个线程修改了共享变量的值，其他线程能够立即得知这个修改。而单纯遵照JMM的规定，多线程程序中单个线程并不一定能马上获知其它线程对共享变量的更改。JMM通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性。<ul>
<li><code>volatile</code>关键字：</li>
<li><code>synchronized</code>关键字：进入<code>synchronized</code>代码块前，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本。进入<code>synchronized</code>代码后，会将修改后的副本的值刷新回主内存中，线程才会释放锁。</li>
<li><code>final</code>关键字</li>
</ul>
</li>
<li>原子性(?)：</li>
<li>有序性<ul>
<li>进行指令重排的时候必须考虑数据的依赖性。</li>
<li>在多线程程序中，不同线程之间存在控制依赖关系重排序可能会改变程序的执行结果。</li>
<li>举例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDependency</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">      flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line">         <span class="keyword">int</span> i = a * a; <span class="comment">// 4</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 在单线程环境下，语句1、2和语句3、4都不存在数据依赖性，因此指令会被重排序。但是在编译器在判断if语句块时会对语句块的内容进行猜测，因此会存在先执行<code>int i = a * a;</code>，然后再判断flag。如果另一线程在执行<code>init</code>时将指令重排序，先执行<code>flag = true</code>，然后又发生了线程切换，这时a的值为0，<code>flag</code>的值却为<code>true</code>。这样就会得到错误的结果<code>int i = 0</code>;</li>
</ul>
</li>
</ol>
<h2 id="怎么解决JMM在多线程环境下的问题"><a href="#怎么解决JMM在多线程环境下的问题" class="headerlink" title="怎么解决JMM在多线程环境下的问题"></a>怎么解决JMM在多线程环境下的问题</h2><ol>
<li>插入内存屏障禁止指令重排序。（<code>volatile</code>）</li>
<li>设置临界区。（<code>synchronized</code>）:JMM允许临界区内的代码重排序，不允许临界区内的代码逃逸到临界区之外。</li>
<li>Happens-Before语义：如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。但这并不意味之前一个操作必须在后一个操作之前执行。Happens-before语义类似于单线程环境下的as-if-serial语义，它保证<strong>正确同步</strong>的多线程程序执行结果不被改变。<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><code>volatile</code>变量规则：对一个<code>volatile</code>字段的写操作happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：A happens-before B ，B happens-before C，那么A happens-before C</li>
<li>start()规则：如果线程A执行<code>ThreadB.start()</code>，那么A线程的start() happens-before于线程B中的任意操作</li>
<li>join()规则：如果线程A执行<code>ThreadB.join()</code>，那么线程B中的任意操作happens-before于线程A从<code>ThreadB.join()</code>成功返回</li>
<li>线程中断规则：对线程<code>interrput</code>方法的调用happens-before于被中断线程的代码检查到中断事件的发生。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/Netty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/Netty/" class="post-title-link" itemprop="url">Netty</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:22" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<ul>
<li>[] Netty线程模型</li>
<li>[] Zero Copy</li>
</ul>
<h1 id="反应器模式"><a href="#反应器模式" class="headerlink" title="反应器模式"></a>反应器模式</h1><ul>
<li>反应器Reactor: 负责查询IO事件。检测到一个IO事件时，将其发送给相应的Handler处理器去处理。这里的IO事件就是NIO中选择器监控的通道IO事件。</li>
<li>Handler处理器：与IO事件绑定，负责IO事件的处理。例如，完成真正的连接建立、通道（channel）的读取、处理业务逻辑、负责将结果写出到通道等。</li>
</ul>
<h2 id="单线程的Reactor模式"><a href="#单线程的Reactor模式" class="headerlink" title="单线程的Reactor模式"></a>单线程的Reactor模式</h2><ul>
<li>Reactor和Handler在同一线程中运行。</li>
<li>相对于传统的多线程Blocking-IO，免去了线程切换的成本</li>
<li>缺点：Reactor和Handler都在同一线程上执行。如果一个Handler被阻塞，其它所有的Handler都得不到执行。假如负责监听连接的Handler和负责数据输入输出的Handler都在同一个线程上，负责监听连接的Handler可能会被阻塞，此时整个服务都不能接受新的连接。</li>
<li>思考：为什么Redis使用了单线程的Reactor模式？<ul>
<li>Redis是一个服务器，Redis的数据操作多数都在内存中，因此Handler的操作耗时应该非常少</li>
<li>多个线程切换需要线程切换开销，如果Handler并不需要很长的阻塞时间，使用多线程模型可能弊大于利</li>
<li>Redis是一个数据库，如果使用多线程的IO模型，多个线程可能会对同一个数据进行操作，此时需要引入同步机制，而同步机制的开销是相当大的。使用单线程模型，天然保证了单个Redis的数据库操作的原子性。</li>
</ul>
</li>
</ul>
<h2 id="多线程的Reactor模式"><a href="#多线程的Reactor模式" class="headerlink" title="多线程的Reactor模式"></a>多线程的Reactor模式</h2><ol>
<li>升级Handler：使用线程池</li>
<li>升级Reactor：引入多个Selector，将单个Reactor线程拆分为多个SubReactor线程，每个SubReactor线程使用一个Selector。</li>
</ol>
<h2 id="VS-生产者消费者模式"><a href="#VS-生产者消费者模式" class="headerlink" title="VS 生产者消费者模式"></a>VS 生产者消费者模式</h2><p>反应器模式没有专门的队列去缓冲存储IO事件</p>
<h2 id="VS-观察者模式"><a href="#VS-观察者模式" class="headerlink" title="VS 观察者模式"></a>VS 观察者模式</h2><p>在Reactor模式中一个事件绑定到了一个Handler上，每个IO事件被查询后Reactor会将事件分发给所绑定的Handler。而观察者模式中同一个事件（主题）可以被订阅过的多个观察者处理。</p>
<h2 id="Reactor的优缺点"><a href="#Reactor的优缺点" class="headerlink" title="Reactor的优缺点"></a>Reactor的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>响应快，不会被单个连接的同步IO阻塞整个服务</li>
<li>编程相对简单</li>
<li>可扩展：增加Reactor线程的个数</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>增加一定复杂性</li>
<li>需要OS底层IO多路复用的支持</li>
</ul>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="Netty中的Reactor"><a href="#Netty中的Reactor" class="headerlink" title="Netty中的Reactor"></a>Netty中的Reactor</h2><h3 id="NioEventLoop类"><a href="#NioEventLoop类" class="headerlink" title="NioEventLoop类"></a>NioEventLoop类</h3><ul>
<li>一个<code>NioEventLoop</code>拥有一个线程，负责一个Java NIO <code>Selector</code>上的IO事件轮询。一个Reactor可以注册多个netty channel。一个<code>EventLoop</code>相当于一个(Sub)Reactor。</li>
<li><code>EventLoopGroup</code>：线程组，多线程版本的反应器，其中的每一个<code>EventLoop</code>为一个SubReactor。</li>
</ul>
<h3 id="Netty通道-Channel"><a href="#Netty通道-Channel" class="headerlink" title="Netty通道(Channel)"></a>Netty通道(Channel)</h3><ul>
<li>Netty channel(TCP服务器里主流的就是<code>NioSocketChannel</code>)封装的就是Java NIO通道。Java NIO通道对应的就是OS底层的文件描述符(File Descriptor, fd)。</li>
<li>连接监听型socket描述符：接受客户端的socket连接。对应<code>ServerSocketChannel</code>(Java NIO)和<code>NioServerSocketChannel</code>(Netty)</li>
<li>传输数据型socket描述符：负责传输数据，在客户端和服务端都会有一个与一条TCP连接相对应的socket描述符进行数据传输。对应<code>SocketChannel</code>(Java NIO)和<code>NioSocketChannel</code>(Netty)</li>
<li>有接受关系的<code>NioServerSocketChannel</code>和<code>NioSocketChannel</code>可以被称为亲子(Parent - Child)通道</li>
</ul>
<h2 id="Netty的入站处理和出站处理"><a href="#Netty的入站处理和出站处理" class="headerlink" title="Netty的入站处理和出站处理"></a>Netty的入站处理和出站处理</h2><ul>
<li>通道中发生IO事件 -&gt; 被EventLoop查询到 -&gt; 分发给实现了<code>ChannelInboundHandler</code>处理器，并调用该处理器的对应处理方法(比如<code>channelRead</code>方法，这个事件在pipeline中可以通过pipeline上下文进行冒泡)，进行一系列业务处理 -&gt; 如果事件超出管道顶端，则会被抛弃，也可以通过事件冒泡的方式传递到出站处理器，通常由出站处理器生成或者处理出站流量 -&gt; 事件被出站处理器处理 -&gt; 如果IO事件到达了出站管道的底部，则IO事件会交由与该channel相关联的线程进行处理，这个IO线程通常会执行实际的IO操作。</li>
</ul>
<h2 id="Netty管道-pipeline"><a href="#Netty管道-pipeline" class="headerlink" title="Netty管道(pipeline)"></a>Netty管道(pipeline)</h2><ul>
<li>Handler和Reactor是多对多的关系，一个Handler可以处理多个Reactor上分发的IO事件，一个Reactor上可以使用多个Handler来处理IO事件。多个Handler可以组成一个pipeline。</li>
<li>一个Netty Channel拥有一条Pipeline。</li>
<li>IO事件在Pipeline上进行双向流动，入站时按顺序由实现了<code>ChannelInboundHandler</code>的处理器处理，出站时按逆序由实现了<code>ChannelOutboundHandler</code>的处理器处理。一个Handler可以同时实现这两个接口，这样出入站都会参与处理。</li>
</ul>
<h2 id="Netty脚手架-Bootstrap"><a href="#Netty脚手架-Bootstrap" class="headerlink" title="Netty脚手架(Bootstrap)"></a>Netty脚手架(Bootstrap)</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/ORM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/ORM/" class="post-title-link" itemprop="url">ORM框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:34" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h1><ul>
<li>将Java Bean转换成行记录</li>
<li>将行记录转换为Java Bean</li>
</ul>
<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><ul>
<li>通过<code>Entity</code>标注实体类，可用<code>@Table(name=&quot;...&quot;)</code>来标识对应的表名。通过<code>@Column(...)</code>建立Java Bean字段和数据库表的列的对应关系</li>
<li>实体类之间可以有继承关系: 父类使用<code>@MappedSuperClass</code>标识</li>
<li>提供自动生成的插入/删除/修改(<code>update</code>)/查询（<code>findByExample</code>/<code>findByCriteria</code>/<code>HQL</code>，使用类名和属性名，由Hibernate转换成实际的表名和列名）</li>
<li>ORM如何将对Java Bean的修改反应到数据库中（调用<code>update</code>时如何确定哪些字段更新了）<ul>
<li>使用代理模式，从ORM读出的对象是代理对象，原对象的每个属性都附加一个标志变量说明这个对象是否被修改。</li>
</ul>
</li>
</ul>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><ul>
<li>半自动ORM：可以完成Java Bean到数据行和数据行到Java Bean的双向转换，但是SQL需要用户自行编写。</li>
<li>属性名与列名不一致？：添加<code>ResultMap</code>（注解或XML）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 23:30:01" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 16:50:54" itemprop="dateModified" datetime="2021-04-02T16:50:54+08:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<ul>
<li>[x] SpringMVC原理</li>
</ul>
<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><ul>
<li>多模块的集合<ul>
<li>核心容器（IOC）</li>
<li>数据访问</li>
<li>Web</li>
<li>AOP</li>
</ul>
</li>
</ul>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="Component和-Bean"><a href="#Component和-Bean" class="headerlink" title="@Component和@Bean"></a>@Component和@Bean</h3><ul>
<li><code>@Component</code>作用于类，使用该注解的类通常会通过classpath扫描来自动侦测并被装配到Spring容器中。可以通过<code>@ComponentScan</code>来定义要扫描的路径，以及定义排除规则。</li>
<li><code>@Bean</code>作用于方法，说明标有该注解的方法中会产生一个Bean。使用第三方库的时候，如果需要将第三方库的类装配到Spring容器中，可以定义一个产生该类的方法并附加<code>@Bean</code>注解。同时，使用<code>@Bean</code>可以实现根据不同条件进行不同的装配操作（在方法中编写条件代码），比<code>@Component</code>相对灵活。</li>
</ul>
<h3 id="如何将一个类声明为Spring的Bean"><a href="#如何将一个类声明为Spring的Bean" class="headerlink" title="如何将一个类声明为Spring的Bean"></a>如何将一个类声明为Spring的Bean</h3><ul>
<li><code>@Component</code>: 通用</li>
<li><code>@Repository</code>: 对应持久层（DAO）</li>
<li><code>@Service</code>: 对应服务层</li>
<li><code>@Controller</code>: 对应控制层</li>
<li><code>@Configuration</code>: 配置类</li>
<li>名称：<code>@....(value = &quot;...&quot;)</code></li>
</ul>
<h3 id="Controller-RestController"><a href="#Controller-RestController" class="headerlink" title="@Controller, @RestController"></a>@Controller, @RestController</h3><ul>
<li>都是表明某类是一个Controller的注解。Dispatcher会扫描使用了这两个注解的类的方法，并检查该方法是否使用了<code>@RequestMapping</code>或<code>@GetMapping</code>一类的注解。</li>
<li><code>@Controller</code>一般用于返回一个视图（一个页面，可以是使用模板引擎进行渲染的页面）。如果要返回JSON或XML格式的数据，需要搭配使用<code>@ResponseBody</code>注解。如果处理器方法被注解<code>@ResponseBody</code>的话，该方法的返回类型会通过适当的Converter转换后写到<code>HttpServletResponse</code>中，而不是被当成视图处理。</li>
<li><code>@RestController</code>，是<code>@Controller</code>和<code>@ResponseBody</code>的结合，只返回对象，对象数据直接以JSON或XML形式写入HTTP响应中。</li>
</ul>
<h3 id="属性注入：-Autowired-Qualifier-Resource"><a href="#属性注入：-Autowired-Qualifier-Resource" class="headerlink" title="属性注入：@Autowired @Qualifier @Resource"></a>属性注入：@Autowired @Qualifier @Resource</h3><ul>
<li><code>@AutoWired</code>：根据类型进行自动装配</li>
<li><code>@Qualifier</code>: 根据属性名称进行注入，需要和<code>@Autowired</code>配合使用。<code>@Qualifier(value = &quot;...&quot;)</code></li>
<li><code>@Resource</code>: 可以根据类型注入，也可以根据名称注入</li>
<li><code>@Value</code>：注入普通类型属性, <code>@Value(&quot;classpath:/...&quot;)</code>…</li>
</ul>
<h3 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h3><ul>
<li><code>@PathVariable</code>: 路径参数</li>
<li><code>@RequestParam</code>: 查询参数（Query String）</li>
<li><code>@RequestBody</code>: 读取Request请求。<code>Content-Type</code>为<code>application/json</code>格式时，接收到数据之后会自动将数据绑定到Java对象上去。系统使用<code>HttpMessageConverter</code>或自定义的Converter将body中的json字符串转换为Java对象。</li>
</ul>
<h3 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h3><ul>
<li><code>@PropertySource(&quot;app.properties&quot;)</code> + <code>@Value(&quot;$&#123;app.property:defaultValue&#125;&quot;)</code></li>
<li><code>@ConfigurationProperties(prefix = &quot;...&quot;)</code>: 读取配置信息并与Bean绑定</li>
</ul>
<h3 id="Json数据处理"><a href="#Json数据处理" class="headerlink" title="Json数据处理"></a>Json数据处理</h3><ul>
<li><code>@JsonIgnoreProperties(&#123;&quot;字段名&quot;&#125;)</code>: 过滤掉特定字段不返回或者不解析</li>
<li><code>@JsonIgnore</code>: 同上，不过直接作用于类的属性上</li>
<li><code>@JsonFormat</code>: 格式化JSON数据</li>
<li><code>@JsonUnwrapped</code>: 扁平化对象</li>
</ul>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="怎么理解IOC"><a href="#怎么理解IOC" class="headerlink" title="怎么理解IOC"></a>怎么理解IOC</h2><p>IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中<strong>手动创建对象的控制权，交由Spring框架来管理</strong>。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<ul>
<li>传统的<code>new</code>关键字进行手动装配存在一定困难<ul>
<li>实例化组件的过程是复杂的，某些组件需要读取配置才能完成实例化</li>
<li>组件之间存在依赖关系，但多个组件依赖一个组件时，很多时候只需要依赖组件的单个实例，没有必要多次实例化。而实现这一点需要理清组件之间的依赖关系，以确定恰当的实例化顺序，这对于手动装配而言是麻烦的</li>
<li>有时候组件需要进行销毁以释放资源，但销毁组件时需要确定所有依赖该组件的其他组件也已经被销毁</li>
</ul>
</li>
<li>因此IOC容器的职责就是<ul>
<li>负责创建组件</li>
<li>负责根据依赖关系组装组件</li>
<li>按照依赖顺序正确地销毁组件</li>
</ul>
</li>
<li>Spring IOC的无侵入性：组件无需要实现框架特定的接口。因此编写完成的组件可以自动装配也可以手动装配。并且测试组件的时候可以单独进行测试。<br>资源（对象）不由使用和提供资源的双方管理，而由第三方管理，集中式的管理容易配置，容易管理，也降低了资源提供方和使用方的耦合度。使得通过配置文件而不是在代码里硬编码（hardcode）的方式来实例化对象和装配对象图。</li>
<li>本质上，IOC容器是个Map。IOC容器可以这样完成自动装配<ul>
<li><code>BeanFactory</code>或<code>ApplicationContext</code>通过XML配置文件或classpath扫描获得所有的附加了<code>@Bean</code>的方法或者附加了<code>@Component</code>的注解，获得所有Bean的类名。通过对类名使用<code>Class.forName</code>可以完成类加载</li>
<li><code>BeanFactory</code>：加载配置时不创建对象，第一次通过<code>getBean</code>获取Bean时才会创建对象。<code>ApplicationContext</code>：加载配置时就创建对象</li>
</ul>
</li>
</ul>
<h2 id="Spring-Bean管理"><a href="#Spring-Bean管理" class="headerlink" title="Spring Bean管理"></a>Spring Bean管理</h2><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>Spring IOC容器原本支持的作用域只有singleton和prototpye。其它作用域是后续框架的增强。</p>
<ul>
<li>singleton：默认是单例的</li>
<li>prototype：每次获取bean时都会创建一个新的bean实例</li>
<li>request：每一次HTTP请求都会生成一个新的bean，仅在当前HTTP request内有效</li>
<li>session：每一次HTTP请求都会生成一个新的bean，仅在当前HTTP session内有效</li>
</ul>
<h3 id="单例bean的线程安全问题"><a href="#单例bean的线程安全问题" class="headerlink" title="单例bean的线程安全问题"></a>单例bean的线程安全问题</h3><ul>
<li>多个线程操作同一个单例对象时对这个对象的成员变量的写操作存在线程安全问题。</li>
<li>一般情况下，Controller、Service、Dao等Bean都应该是无状态的，不保存数据的Bean即使被多线程使用也是安全的。</li>
<li>如果需要成员变量，可以将成员变量保存在<code>ThreadLocal</code>中。或者将Bean的作用域改为prototype</li>
</ul>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ul>
<li>实例化：实例化一个Bean对象</li>
<li>属性赋值：为Bean设置相关属性。如果该Bean依赖其它Bean，则获取对其它bean的引用</li>
<li>初始化：可能的Aware相关接口，BeanPostProcessor的前后置处理，是否实现<code>InitializingBean</code>接口，自定义的<code>init-method</code>（<code>@PostConstruct</code>）（如果Bean有定义初始化方法，则调用这些初始化方法）</li>
<li>销毁：自定义的<code>destroy-method</code>（容器关闭的时候，如果bean调用了销毁方法，则调用销毁方法<code>@PreDestroy</code>）<h4 id="常用扩展点（生命周期钩子？）"><a href="#常用扩展点（生命周期钩子？）" class="headerlink" title="常用扩展点（生命周期钩子？）"></a>常用扩展点（生命周期钩子？）</h4><h5 id="影响多个Bean的接口：后置处理器"><a href="#影响多个Bean的接口：后置处理器" class="headerlink" title="影响多个Bean的接口：后置处理器"></a>影响多个Bean的接口：后置处理器</h5></li>
<li>实现了这些接口的Bean会<strong>切入到多个Bean的生命周期</strong>中。</li>
<li>BeanPostProcessor：<strong>初始化</strong>阶段的前后，Bean实例会被传入这个后置处理器的方法。同时会返回一个Bean。String AOP可以在此处完成对Bean的增强，返回代理对象<ul>
<li><code>postProcessBeforeInitialization</code></li>
<li><code>postProcessAfterInitialization</code></li>
</ul>
</li>
<li>InstantiationAwareBeanPostProcessor：<strong>实例化</strong>阶段的前后<h5 id="只调用一次的接口"><a href="#只调用一次的接口" class="headerlink" title="只调用一次的接口"></a>只调用一次的接口</h5></li>
</ul>
<h2 id="Spring中的设计模式"><a href="#Spring中的设计模式" class="headerlink" title="Spring中的设计模式"></a>Spring中的设计模式</h2><ul>
<li>工厂模式：通过<code>BeanFactory</code>、<code>ApplicationContext</code>创建对象</li>
<li>代理模式：Spring AOP</li>
<li>单例模式：Spring中的单例Bean</li>
</ul>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="为什么要使用MVC设计模式"><a href="#为什么要使用MVC设计模式" class="headerlink" title="为什么要使用MVC设计模式"></a>为什么要使用MVC设计模式</h2><ul>
<li>将数据模型定义、控制逻辑和表现逻辑分离，降低各个模块之间的耦合度。</li>
<li>视图：呈现模型，展示数据，直接与用户交互</li>
<li>控制器：取得用户的输入，解读其对模型的操作，据此改变视图的状态、改变视图的显示</li>
<li>模型：模型封装持有的数据、状态和业务逻辑，不需要对控制器和视图的存在进行感知，只提供操作和检索状态的接口，并发送状态改变通知给观察者。</li>
</ul>
<h2 id="MVC-vs-MVVM"><a href="#MVC-vs-MVVM" class="headerlink" title="MVC vs MVVM"></a>MVC vs MVVM</h2><ul>
<li>MVC: M封装数据和逻辑，V提供展示，C进行控制：V向C请求修改Model，C帮V调用Model的操作，得到Model的反馈后用新的数据更新V。</li>
<li>MVVM：VM完成V与M的双向绑定。直接对V上的数据进行修改，VM会自动将对V的修改同步到M上。反之对M进行修改，VM会自动将对M的修改同步到V上，表现为用户界面的变化。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>客户端发送请求，通过<code>DispatcherServlet</code>接收请求。</li>
<li><code>DispatcherServlet</code>根据请求信息，从<code>HandlerMapping</code>查找对应的<code>HandlerAdapter</code>。</li>
<li>与<code>HandlerAdapter</code>相关的<code>Handler</code>调用真正的处理器来处理请求，完成相应的业务逻辑。<ul>
<li>为什么要区分<code>Handler</code>和<code>HandlerAdapter</code>？</li>
<li><code>HandlerAdapter</code>相当于一个代理。</li>
<li>我们编写的Controller希望能够将路径参数、URL参数和请求体都作为方法的参数传入。因此<code>HandlerAdapter</code>可以将<code>HttpServletRequest</code>中的URL参数、请求体等进行解析，然后使用反射机制调用<code>Handler</code>的方法，实现这一目的。</li>
</ul>
</li>
<li>处理完请求后，如果是RESTful接口，则将返回数据通过适当的转换器转换后写到<code>HttpServletResponse</code>中。</li>
<li>如果不是一个RESTful接口，处理完业务后会返回一个<code>ModelAndView</code>对象。</li>
</ul>
<h1 id="Spring-三级缓存"><a href="#Spring-三级缓存" class="headerlink" title="Spring 三级缓存"></a>Spring 三级缓存</h1><ul>
<li>一级缓存：<code>singletonObjects</code>：单例池，存放已经经历了完整生命周期的Bean(已经初始化好的Bean)</li>
<li>二级缓存：<code>earlySingletonObjects</code>：存放早期暴露出来的Bean对象，生命周期未结束（未完成初始化，属性未填充完）</li>
<li>三级缓存：<code>singletonFactories</code>：存放可以生成Bean的工厂<br><img src="./pics/微信截图_20210308160914.png" alt="springCache"></li>
<li>四大方法:<ul>
<li><code>getSingleton</code><ul>
<li>一级缓存没有，并且当前对象并不是创建过程中（<code>isSingletonCurrentlyInCreation</code>返回<code>false</code>）就去二级缓存找</li>
<li>二级缓存没有，就去三级缓存找</li>
<li>三级缓存有的话（能够获得对应的FactoryBean），就通过factory创建一个原始Bean，放到二级缓存，并删除三级缓存中的factory</li>
</ul>
</li>
<li><code>doCreateBean</code></li>
<li><code>populateBean</code></li>
<li><code>earlySingletonObjects</code></li>
</ul>
</li>
<li>Spring创建Bean的过程：创建原始的bean对象，然后填充对象属性进行初始化</li>
<li>每次创建单例Bean之前先在一级缓存中检查是否已经创建过</li>
</ul>
<h1 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>多个Bean之间互相依赖，形成闭环。默认B的单例Bean中，属性互相引用的场景。</li>
<li>构造方法注入，setter方法注入</li>
<li>构造方法注入可能导致循环依赖问题。并且坚持使用构造方法注入是无法解决的。<ul>
<li>注：一般情况下推荐使用构造注入</li>
<li>使用基于setter方法的注入代替构造方法注入</li>
<li>只要注入方式是setter方法注入，且Bean为单例Bean(<code>@Component</code>)，则能够解决循环依赖问题</li>
<li>原型（prototpye, <code>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code>, <code>@Scope(&quot;prototype&quot;)</code>）的场景无法支持循环依赖，会报错<code>BeanCurrentlyInCreationException</code>。</li>
</ul>
</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>Spring内部通过三级缓存解决循环依赖：<code>DefaultSingletonBeanRegistry</code></li>
<li>单例Bean：三级缓存提前暴露，依靠Bean的“中间态”概念，中间态指的是已经实例化但没有初始化的状态</li>
<li>非单例Bean：每次都要获取一个新的对象，要重新创建，没有缓存</li>
<li>创建单例Bean A的原始对象后（未填充属性），将其放入三级缓存，然后开始填充对象属性。此时发现Bean A需要依赖Bean B，顺序查找三级缓存未能找到Bean B，于是进行BeanB的创建。经过相似的过程后会发现创建Bean B需要Bean A</li>
<li>此时Bean B在第三级缓存中查找到Bean A的原始对象，直接将原始对象注入Bean B（提前暴露Bean A），完成对Bean B的创建。</li>
<li>Bean B创建完毕后Bean A的创建流程即可继续，完成属性填充的工作。<br><img src="./pics/微信截图_20210308184933.png" alt="SpringCircularDependency"></li>
</ul>
<h3 id="为什么一定要用三级缓存？"><a href="#为什么一定要用三级缓存？" class="headerlink" title="为什么一定要用三级缓存？"></a>为什么一定要用三级缓存？</h3><ul>
<li>维持Spring Bean的生命周期</li>
</ul>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="怎么理解"><a href="#怎么理解" class="headerlink" title="怎么理解"></a>怎么理解</h2><p>能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制、统一的错误处理等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Spring AOP基于动态代理。如果代理对象实现了某个接口，使用JDK动态代理。否则使用CGLIB生产一个被代理对象的子类作为代理。<br><img src="./pics/spring/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<h2 id="Spring-AOP和AspectJ-AOP的区别"><a href="#Spring-AOP和AspectJ-AOP的区别" class="headerlink" title="Spring AOP和AspectJ AOP的区别"></a>Spring AOP和AspectJ AOP的区别</h2><ul>
<li>Spring AOP无论是使用JDK提供的Proxy还是CGLIB，本质都是动态代理，在运行时对类进行增强。而AspectJ AOP其实使用了静态代理的方法，在编译字节码时在方法的周围加上业务逻辑，是编译期通过操作字节码完成静态织入。</li>
<li>AspectJ的功能更强大，同时性能更好，因为对方法的增强在编译期就已经完成了。</li>
</ul>
<h2 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h2><ul>
<li><code>@Before</code></li>
<li><code>@After</code></li>
<li><code>@AfterReturning</code></li>
<li><code>@AfterThrowing</code></li>
<li><code>@Around</code></li>
</ul>
<h2 id="AOP的执行顺序"><a href="#AOP的执行顺序" class="headerlink" title="AOP的执行顺序"></a>AOP的执行顺序</h2><ul>
<li>正常执行：环绕Before -&gt; Before -&gt; AfterReturn -&gt; After -&gt; 环绕After</li>
<li>异常流程：环绕Before -&gt; Before -&gt; AfterThrowing -&gt; After</li>
</ul>
<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><ul>
<li>编程式事务：<code>TransactionTemplate</code>，<code>TransactionManager</code></li>
<li>声明式事务：基于XML、基于注解<ul>
<li>实现原理：动态代理<h2 id="Spring事务的隔离级别-isolation"><a href="#Spring事务的隔离级别-isolation" class="headerlink" title="Spring事务的隔离级别(isolation)"></a>Spring事务的隔离级别(isolation)</h2></li>
</ul>
</li>
<li><code>TransactionDefinition.ISOLATION_DEFAULT</code>: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="Spring事务的传播-propagation"><a href="#Spring事务的传播-propagation" class="headerlink" title="Spring事务的传播(propagation)"></a>Spring事务的传播(propagation)</h2><h3 id="加入当前事务"><a href="#加入当前事务" class="headerlink" title="加入当前事务"></a>加入当前事务</h3><ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRED</code>： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><code>TransactionDefinition.PROPAGATION_MANDATORY</code>： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<h3 id="挂起当前事务"><a href="#挂起当前事务" class="headerlink" title="挂起当前事务"></a>挂起当前事务</h3><ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h2 id="Transcational-rollbackFor-Exception-class"><a href="#Transcational-rollbackFor-Exception-class" class="headerlink" title="@Transcational(rollbackFor = Exception.class)"></a>@Transcational(rollbackFor = Exception.class)</h2><ul>
<li>让Spring事务遇到非运行时异常时也回滚。</li>
</ul>
<h2 id="事务超时属性-timeout"><a href="#事务超时属性-timeout" class="headerlink" title="事务超时属性(timeout)"></a>事务超时属性(timeout)</h2><ul>
<li>在<code>TransactionDefinition</code>中以int类型<code>timeout</code>表示超时时间</li>
</ul>
<h2 id="事务只读属性-readOnly"><a href="#事务只读属性-readOnly" class="headerlink" title="事务只读属性(readOnly)"></a>事务只读属性(readOnly)</h2><h2 id="自调用问题"><a href="#自调用问题" class="headerlink" title="自调用问题"></a>自调用问题</h2><p>若同一类中的其他没有 <code>@Transactional</code> 注解的方法内部调用有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。<br>因为Spring AOP的实现原因，当含有<code>@Transactional</code>注解的方法在类以外被调用的时候，Spring事务管理才生效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/SpringBoot/" class="post-title-link" itemprop="url">SpringBoot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:42" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<p>TODOS:</p>
<ul>
<li>[] SpringBoot的启动流程</li>
</ul>
<h1 id="SpringBoot帮我们干了什么"><a href="#SpringBoot帮我们干了什么" class="headerlink" title="SpringBoot帮我们干了什么"></a>SpringBoot帮我们干了什么</h1><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li>父项目完成依赖管理（<code>spring-boot-starter-parent</code>）。父项目几乎声明了常用的所有依赖的版本号</li>
<li>开发时导入starter场景启动器：对于一个场景，引入starter依赖会引入该场景相关的所有常规依赖<ul>
<li>所有场景启动器都依赖<code>spring-boot-starter</code></li>
</ul>
</li>
<li>无需关注版本号，完成自动版本仲裁<ul>
<li>查看<code>spring-boot-dependencies</code>中的依赖标签名。也可以在项目中的<code>&lt;properties&gt;</code>标签中自定义依赖的版本号</li>
</ul>
</li>
</ul>
<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><ul>
<li>对于一个场景中的各种依赖会提供默认配置，开箱即用（例如<code>web.xml</code>中的各种设置，例如字符编码…etc）</li>
<li>默认的包结构（包扫描的目录：主程序所在的包及其子包中的所有类都会被扫描</li>
<li>各种配置拥有默认值（默认端口，默认值…），配置类持有这些默认值，而在SpringBoot类的项目配置文件中(<code>application.properties</code>/<code>application.yml</code>)进行设置可以将这些值绑定到<strong>对应的</strong>配置类上，配置类会被加载到容器中发挥作用。</li>
<li>按需加载自动配置项：引入的时候自动配置才会开启<ul>
<li>所有的自动配置功能都在<code>spring-boot-autoconfigure</code>中</li>
</ul>
</li>
</ul>
<h1 id="底层注解"><a href="#底层注解" class="headerlink" title="底层注解"></a>底层注解</h1><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>默认加在主类上，是<code>@SpringBootConfiguration</code>（其实就是<code>@Configuration</code>, 允许在Spring上下文中注册额外的Bean或导入其它配置类）、<code>@EnableAutoConfiguration</code>（启动Springboot自动配置机制）、<code>@ComponentScan</code>（扫描Bean，扫描该类所在包下所有的类）的集合。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><ul>
<li>声明配置类，作用如<code>beans.xml</code></li>
<li>创建Bean：<ul>
<li>在类中创建方法并附加<code>@Bean</code>注解，方法名就是组件ID，返回类型就是组件类型，返回值就是组件实例。默认为单例Bean</li>
</ul>
</li>
<li>默认<code>proxyBeanMethods = true</code>：代理Bean的方法。可以说明<code>@Configuration</code>中的方法是被代理的。（重复直接调用单例Bean的创建方法不会返回不同对象，说明方法已经被代理）<ul>
<li>Full配置与Lite配置：Full模式中配置类的<code>proxyBeanMethods = true</code>，Lite模式中为<code>false</code></li>
</ul>
</li>
</ul>
<h2 id="Import-Class-lt-gt"><a href="#Import-Class-lt-gt" class="headerlink" title="@Import(Class&lt;?&gt;[])"></a>@Import(Class&lt;?&gt;[])</h2><ul>
<li>向容器中导入指定的类的实例</li>
</ul>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><ul>
<li>满足条件时才进行装配 </li>
</ul>
<h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><ul>
<li>从classpath中搜索配置文件，注入配置文件中描述的Bean</li>
</ul>
<h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><ul>
<li>从配置文件中读取配置，绑定到容器中的Bean的属性上</li>
<li><code>@EnableConfigurationProperties</code>：附加在配置类上，开启指定类的属性配置功能，同时把这个类的对象加入容器中。主要在为第三方包的类进行配置绑定时使用。（因为没办法在第三方的类加注解）</li>
</ul>
<h1 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h1><h2 id="核心注解-EnableAutoConfiguration"><a href="#核心注解-EnableAutoConfiguration" class="headerlink" title="核心注解@EnableAutoConfiguration"></a>核心注解<code>@EnableAutoConfiguration</code></h2><h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><p><img src="./pics/springboot/AutoConfigurationPackage.png" alt="AutoConfigurationPackage"></p>
<h3 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h3><ul>
<li>其中包含注解<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>。</li>
<li><code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry();</span><br><span class="line"></span><br><span class="line"><span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</li>
<li>用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName。为排除</li>
<li>获取需要自动装配的所有配置类，读取META-INF/spring.factories（所有引入的starter依赖中都需要定义<code>/META-INF/spring.factories</code>，才能被SpringBoot的自动装配机制捕捉到），查找出所有的<code>XXXAutoConfiguration</code>。</li>
<li>对自动配置器进行筛选，在<code>XXXAutoConfiguration</code>类中的<code>@ConditionalOnClass</code>中，规定只有相关的类存在的时候（也就是classpath下有指定类的时候），才会将加载器实例化并注入IOC容器中，进而完成下一步的自动装配。</li>
</ol>
<h2 id="手写Starter"><a href="#手写Starter" class="headerlink" title="手写Starter"></a>手写Starter</h2><ol>
<li>命名最好是<code>XXX-spring-boot-starter</code>，而不是<code>spring-boot-starter-XXX</code>，后者是SpringBoot官方的Starter的命名方式</li>
<li>引入依赖：<code>spring-boot-starter-parent</code>, <code>spring-boot-starter</code></li>
<li>创建自动配置器：带有<code>@Configuration</code>注解的类，这样其中的方法可以向IOC容器注入Bean。需要为类或者方法附加<code>@ConditionalOnClass</code>注解，否则无论如何都会为Spring注入Bean。</li>
<li>在工程的resource目录下创建<code>/META-INF/spring.factories</code>文件，文件内容包含<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</code>以及自动装配器的全限定类名。</li>
<li>最后在SpringBoot项目中引入该starter，即可实现自动装配。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">分布式理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-26 23:30:01" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 22:35:20" itemprop="dateModified" datetime="2021-04-06T22:35:20+08:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<ul>
<li>[] CAP理论彻底理清</li>
<li>[] BASE</li>
<li>[] 常见中间件在CAP理论中的定位: <ul>
<li>[] MySQL Cluster</li>
<li>[] Redis Cluster</li>
<li>[] Redis Sentinel</li>
<li>[] Zookeeper</li>
<li>[] Eureka</li>
<li>[] Nacos</li>
<li>[] HDFS(?)</li>
</ul>
</li>
<li>[] 常见算法（优缺点及其原因<ul>
<li>2PC协议/3PC协议</li>
<li>Paxos简单情况</li>
<li>ZAB</li>
<li>Raft</li>
</ul>
</li>
</ul>
<h1 id="多机器的时钟同步"><a href="#多机器的时钟同步" class="headerlink" title="多机器的时钟同步"></a>多机器的时钟同步</h1><ul>
<li>分布式环境下多台机器的时间流动可能是不一样的，需要一种机制来进行时钟同步，在多个机器间确定事件的发生顺序</li>
<li>全序：任意两个元素都有二元关系，可比较</li>
<li>偏序：只有部分元素可以比较，无法确定所有元素的准确顺序</li>
<li>在单节点系统上维持全序关系是容易的，但是在分布式系统上维持全序关系需要付出代价。通信的代价是昂贵的，时间的同步是非常困难并且脆弱的。</li>
</ul>
<h2 id="全局时间"><a href="#全局时间" class="headerlink" title="全局时间"></a>全局时间</h2><ul>
<li>理想世界，每个节点使用同一个有完美准确度的时钟</li>
</ul>
<h2 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h2><h2 id="逻辑时间戳"><a href="#逻辑时间戳" class="headerlink" title="逻辑时间戳"></a>逻辑时间戳</h2><ul>
<li>“逻辑时间（logical time）”而非真实时间来记录因果关系：使用计数器和通信机制来判断事件发生的顺序</li>
<li>无法得知有关时间间隔的信息，也无法使用超时机制</li>
</ul>
<h2 id="向量时间戳"><a href="#向量时间戳" class="headerlink" title="向量时间戳"></a>向量时间戳</h2><h3 id="Simple-Lamport-Clock"><a href="#Simple-Lamport-Clock" class="headerlink" title="Simple Lamport Clock"></a>Simple Lamport Clock</h3><p>进程工作 -&gt; 计数器自增<br>发送消息 -&gt; 携带计数器值<br>接收消息 -&gt; 合并计数器</p>
<ul>
<li>偏序关系：若timestamp(a) &lt; timestamp(b)，则a可能在b之前发生，也可能无法比较。因为一个Lamport clock只能携带1条时间线的信息，因此可能发生“明明是同时发生的事件，却被排序”的情况。</li>
</ul>
<h3 id="Vector-Clock"><a href="#Vector-Clock" class="headerlink" title="Vector Clock"></a>Vector Clock</h3><h1 id="FLP-impossiblity-result"><a href="#FLP-impossiblity-result" class="headerlink" title="FLP impossiblity result"></a>FLP impossiblity result</h1><ul>
<li>假设<ul>
<li>节点只会fail by crashing，不存在拜占庭式错误</li>
<li>网络是可靠的</li>
<li>其它异步系统模型所需的关于时间的假设<ul>
<li>各个进程行进的速率是独立的</li>
<li>没有上界</li>
<li>没有可用的时钟</li>
</ul>
</li>
</ul>
</li>
<li>结论<ul>
<li>即使在消息不会丢失，最多一个进程fail且只会fail by crashing的条件下，异步系统模型中也不存在能够解决共识问题(consensus problem)的确定性算法。</li>
<li>假设这样的算法存在，则总能设计出一种执行这种算法的方式，通过delaying message来让系统remain undecided(“bivalent”)</li>
<li>这个结论的重要意义是它强调了在异步系统模型的假设下（no uppder bound），设计解决共识问题的算法必须考虑一种折衷：要么放弃safety，要么放弃liveness。</li>
</ul>
</li>
</ul>
<h1 id="CAP-theorem"><a href="#CAP-theorem" class="headerlink" title="CAP theorem"></a>CAP theorem</h1><h2 id="三类属性"><a href="#三类属性" class="headerlink" title="三类属性"></a>三类属性</h2><ul>
<li>一致性Consistency：所有节点在同一时间都可以访问到同样的数据（see the same data）</li>
<li>可用性Availability：节点的failure不影响没有fail的节点继续工作</li>
<li>分区容错性Partition tolerance：即使出现了因为网络问题（Partition - communication break）导致的消息丢失，系统还是能继续工作</li>
<li>最多只有两种属性能够同时满足。（事实上，这并不是严格的“3选2”问题，某些时候属性之间存在tradeoff）<h2 id="三系统类型"><a href="#三系统类型" class="headerlink" title="三系统类型"></a>三系统类型</h2></li>
<li>CA：保证一致性可用性， <strong>full strict</strong> quorum protocols，例如two-phace commit（2PC）<ul>
<li>一种强一致性模型，无法区分节点不可用和网络问题，只能通过停止接收写操作来避免数据分歧</li>
<li>quorum protocol：基于鸽巢原理的算法，保证数据冗余和最终一致性<ul>
<li>分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：<ul>
<li>Vr + Vw &gt; V</li>
<li>Vw &gt; V/2</li>
</ul>
</li>
<li>第一条规则保证了一个数据不会被同时读写。当一个写操作请求过来的时候，它必须要获得Vw个冗余拷贝的许可。而剩下的数量是V-Vw 不够Vr，因此不能再有读请求过来了。同理，当读请求已经获得了Vr个冗余拷贝的许可时，写请求就无法获得许可了。</li>
<li>第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。</li>
</ul>
</li>
</ul>
</li>
<li>CP：保证一致性和分区容错性，majority quorum protocols，例如Paxos，Raft<ul>
<li>也是一种强一致性模型，通过对网络中断的两段实行不对称的行为来避免数据分歧。节点多的一侧可用，节点少的一侧不可用（属于哪种情况需要使用算法进行区分）。</li>
</ul>
</li>
<li>AP：使用冲突化解(conflit resolution)的协议</li>
</ul>
<h2 id="导出结论"><a href="#导出结论" class="headerlink" title="导出结论"></a>导出结论</h2><ul>
<li>应该积极考虑Partition Tolerance：“分布式系统必须保证分区容错性，基本上只能选择AP原则和CP原则”，“You can’t sacrifice partition tolerance”</li>
<li>因此分布式系统中并不存在”CA”类别，当network partition发生时，分布式系统要么保证一致性，要么保证可用性。（单机系统可以存在CA类别，比如RDBMS）</li>
<li>存在network partitions时，强一致性和高可用性存在冲突</li>
<li>在一般情况下，强一致性和性能存在冲突。要保证强一致性，各个节点要在每个操作上进行通信和协商，这会导致很高的latency</li>
</ul>
<h2 id="强一致性与弱一致性模型"><a href="#强一致性与弱一致性模型" class="headerlink" title="强一致性与弱一致性模型"></a>强一致性与弱一致性模型</h2><h3 id="强一致性模型"><a href="#强一致性模型" class="headerlink" title="强一致性模型"></a>强一致性模型</h3><ul>
<li>可线性化一致性：在可线性一致性的情况下，所有的操作似乎都按照与全局实时操作顺序一致的顺序原子地执行</li>
<li>顺序一致性：在顺序一致性的情况下，所有操作似乎都是按照某种顺序原子地执行的，这种顺序与在单个节点上看到的顺序一致，并且在所有节点上都是相等的。</li>
</ul>
<h3 id="弱一致性模型"><a href="#弱一致性模型" class="headerlink" title="弱一致性模型"></a>弱一致性模型</h3><ul>
<li>client-centric一致性模型：入了客户端或会话机制的一致性模型，保证客户不会访问到一个数据项的旧版本，通常可以在客户端增加额外的cache来实现</li>
<li>最终一致性模型：如果停止对数据的值进行修改，经过”一段待定义的时间”后所有数据的副本都会达成一致得到某个相同的值。在此之前，多个数据的副本可能在”某些为定义的行为中”存在不一致的现象。<ul>
<li>因果一致性：如果A更新完数据通知了B，则B之后对数据的访问和修改必须基于A更新后的值。对于C则没有这样的限制。</li>
<li>Read your writes：节点A更新后总是能访问到自己更新过的最新值。</li>
</ul>
</li>
</ul>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><ul>
<li>Basically Available: 基本可用。出现故障时，可能出现响应时间变慢或者部分功能降级，但是仍能提供服务。</li>
<li>Soft State: 软状态，允许系统中的数据存在中间状态，而不是要求多个节点的数据副本总是一致的。</li>
<li>Eventually Consistent: 最终一致性，软状态存在时间期限。时间期限过后应该保证所有的副本保持数据一致性。</li>
</ul>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><ul>
<li>一种分布式共识的特殊情况</li>
<li>DBMS相较于文件系统的意义在于<ul>
<li>基于关系代数，实现对数据的一种结构化存储和结构化查询</li>
<li>事务的支持 -&gt; ACID<h2 id="2PC：尽量保证强-一致性"><a href="#2PC：尽量保证强-一致性" class="headerlink" title="2PC：尽量保证强(?)一致性"></a>2PC：尽量保证强(?)一致性</h2><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3></li>
</ul>
</li>
<li>一阶段：</li>
</ul>
<ol>
<li>客户端向协调者发起事务。事务的协调者节点首先向所有的参与者节点发送Prepare请求。</li>
<li>接收到Prepare请求后，每一个参与者节点都会写入日志并各自执行与事务有关的数据更新（此时会对数据上锁），但是暂时不提交事务，而是想协调者节点返回“完成”消息。</li>
<li>协调者接收到<strong>所有</strong>参与者返回的消息后，分布式事务进入第二阶段。</li>
</ol>
<ul>
<li>二阶段正常流程：<ul>
<li>成功流程：<ol>
<li>如果协调者节点接收到的都是“可以准备提交事务”的消息，那么协调者节点会向所有参与者发送事务提交命令。</li>
<li>参与者接收到事务提交命令，进行事务的提交并释放锁资源。本地事务完成提交后，会向当前协调者返回“完成”消息。</li>
<li>协调者接收到所有事务参与者的反馈，分布式事务完成。</li>
</ol>
</li>
<li>失败流程：<ol>
<li>在第一阶段协调者接收到某个参与者反馈的失败消息，说明该节点的事务执行不成功，必须回滚。</li>
<li>协调者节点向所有的参与者发送abort请求。接收到abort请求的参与者需要在本地进行事务的回滚操作。</li>
</ol>
</li>
<li>无论是成功还是失败，此时才会告知客户端事务执行的结果。</li>
</ul>
</li>
</ul>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul>
<li>一阶段中如果协调者发出Prepare请求，有可能收不到所有参与者的响应。此时可以引入重试-超时机制。如果超时，则直接回滚。</li>
<li>二阶段第一步如果协调者发出提交请求或回滚请求，但是没有收到所有参与者的响应。则需要不断重发提交请求，直到收到全部协调者的响应。否则可能导致参与者节点的数据不一致。</li>
<li>各个节点在事务执行过程中会持续占用数据库资源（在事务相关的数据上加锁），性能较差。</li>
<li>协调者的单点故障问题<ul>
<li>发送Prepare请求之后协调者单点故障、发送提交事务/回滚事务之前单点故障、发送…之后单点故障…</li>
</ul>
</li>
</ul>
<h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>一阶段同样发出Prepare请求，但是不让参与者立即执行事务，而是只需要返回是否能够准备。</li>
<li>二阶段进行预提交，多出这一状态可以让参与者确认其它参与者都回应了协调者，表示可以进行后续事务。该阶段参与者会进行写日志和修改数据，不提交事务。</li>
<li>三阶段进行事务提交，协调者发出提交事务请求，参与者响应。</li>
<li>同样，不管哪一个阶段有参与者返回失败都会宣布事务失败。</li>
<li>参与者超时：等待提交事务请求超时，参与者会直接提交事务（？）。而等待与提交命令超时的情况，则没有任何影响。</li>
</ul>
<h1 id="复制（Replication）"><a href="#复制（Replication）" class="headerlink" title="复制（Replication）"></a>复制（Replication）</h1><h2 id="复制的时机来分类"><a href="#复制的时机来分类" class="headerlink" title="复制的时机来分类"></a>复制的时机来分类</h2><h3 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h3><ul>
<li>请求 -&gt; 阻塞，将操作复制到所有节点 -&gt; 所有节点返回 -&gt; 向客户端返回</li>
<li>返回客户端之前状态变化会被系统中所有节点所知。</li>
<li>性能差，耐用性保证强。<h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3></li>
<li>请求 -&gt; 立即响应，将更新数据保存在本机 -&gt; 发送异步复制消息，联系其他节点 其他节点更新它们的副本</li>
<li>性能高，对网络延迟的容忍度高，耐用性保证差，如果某个修改在给客户端发送响应后，在成功复制到从节点之前丢失了，那这个修改就永远丢失了。</li>
<li>高可用性，但是单纯的lazy approach无法保证错误发生时能够读出之前写入的内容</li>
</ul>
<h2 id="按照副本一致性的强弱分类"><a href="#按照副本一致性的强弱分类" class="headerlink" title="按照副本一致性的强弱分类"></a>按照副本一致性的强弱分类</h2><h3 id="维护单一副本（prevent-divergence，single-copy）"><a href="#维护单一副本（prevent-divergence，single-copy）" class="headerlink" title="维护单一副本（prevent divergence，single copy）"></a>维护单一副本（prevent divergence，single copy）</h3><ul>
<li>尽可能地表现得像单一系统</li>
<li>保证只有一个活动副本</li>
<li>保证所有副本的一致性</li>
<li>例子：异步主从复制、同步主从复制、2PC、Multi-Paxos，3PC，Paxos with leader election<h3 id="multi-master-systems（risk-divergence）"><a href="#multi-master-systems（risk-divergence）" class="headerlink" title="multi-master systems（risk divergence）"></a>multi-master systems（risk divergence）</h3></li>
</ul>
<h2 id="常见的复制算法：主从复制"><a href="#常见的复制算法：主从复制" class="headerlink" title="常见的复制算法：主从复制"></a>常见的复制算法：主从复制</h2><ul>
<li>所有操作都在一个master server上进行，master server将所有操作序列化并形成local log，local log将被发送到所有backup server上形成replica</li>
<li>丢失修改的两种情况<ul>
<li>异步复制导致：没来得及同步完成时master宕机，新slave成为master，旧master即使恢复了也会变成slave，无法将修改复制到其他节点</li>
<li>脑裂：master和slave无法互相联系，联系不上master的slave选出了backup master，新旧master同时接收修改，导致丢失修改<ul>
<li>怎么解决？要求master必须与一定量的slave保持联系才可以接受写，否则拒绝写</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="主从复制下的一致性协议：2PC-2-Phase-Commit"><a href="#主从复制下的一致性协议：2PC-2-Phase-Commit" class="headerlink" title="主从复制下的一致性协议：2PC(2 Phase Commit)"></a>主从复制下的一致性协议：2PC(2 Phase Commit)</h3><ul>
<li>中心化的协议，需要单一的master/leader/coordinator角色</li>
<li>过程 vote -&gt; decision -&gt; commit</li>
<li>是一个CA算法，不保证Partition Tolerance</li>
</ul>
<h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><h2 id="Quorum机制"><a href="#Quorum机制" class="headerlink" title="Quorum机制"></a>Quorum机制</h2><h3 id="最极端的情况：Write-All-Read-One"><a href="#最极端的情况：Write-All-Read-One" class="headerlink" title="最极端的情况：Write All Read One"></a>最极端的情况：Write All Read One</h3><ul>
<li>当Client请求向某副本写数据时(更新数据)，只有当所有的副本都更新成功之后，这次写操作才算成功，否则视为失败。</li>
<li>写操作很脆弱，因为只要有一个副本更新失败，此次写操作就视为失败了。</li>
<li>读操作很简单，因为，所有的副本更新成功，才视为更新成功，从而保证所有的副本一致。这样，只需要读任何一个副本上的数据即可。假设有N个副本，N-1个都宕机了，剩下的那个副本仍能提供读服务；但是只要有一个副本宕机了，写服务就不会成功。</li>
</ul>
<h3 id="W-R-N"><a href="#W-R-N" class="headerlink" title="W R N"></a>W R N</h3><ul>
<li>更新操作在W个副本中更新成功后才认为此次更新操作成功。更新后的数据为“成功提交”。</li>
<li>对于读操作，至少要读R个副本才能读到此次更新的数据</li>
<li>W + R &gt; N</li>
<li>在保证强一致性的情况下，W越大，写操作的可用性越差，读操作的可用性越好，反之亦然。</li>
</ul>
<h3 id="如何判断是否是最新的？"><a href="#如何判断是否是最新的？" class="headerlink" title="如何判断是否是最新的？"></a>如何判断是否是最新的？</h3><h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><h2 id="传统哈希方法的局限性"><a href="#传统哈希方法的局限性" class="headerlink" title="传统哈希方法的局限性"></a>传统哈希方法的局限性</h2><ul>
<li>通过哈希的方式确定某个数据或某个请求应该落到哪个节点。</li>
<li>传统哈希方法在节点增加或减少的时候需要进行重哈希，这会导致大量key和节点的映射关系发生变化。 -&gt; 如果是缓存的情况，此时会发生大量的缓存失效，造成缓存雪崩。</li>
</ul>
<h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>保证了增加或减少服务器时让尽可能少的映射发生改变<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></li>
<li>一致性哈希环：分布范围是<code>[0, 2^32 - 1]</code></li>
<li>对象和服务器放置在同一个哈希环上。</li>
<li>对于每个对象，在哈希环上顺时针查找举例这个对象的哈希值最近的服务器。将这一服务器确定为该对象所属的服务器。</li>
<li>对于服务器增加的情况，只有在哈希环上位于新增的服务器和该服务器的上一台服务器之间的对象需要进行重新分配。</li>
<li>对于服务器减少的情况，只有原本分配到该台服务器上的对象需要进行重新分配，其它节点不会受影响。</li>
<li>虚拟节点：将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器配置到哈希环上，然后维护虚拟服务器到物理服务器的映射。</li>
</ul>
<h3 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h3><ul>
<li>如果哈希环上的一个服务器故障，原本属于该服务器的请求或数据访问就会全部转移到哈希环上的下一个服务器，这会造成下一个服务器的负载瞬间上升，有可能导致下一个服务器故障。</li>
<li>解决：在下一个服务器之前增加虚拟节点，分担下一个服务器的压力。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Freeman Huang</p>
  <div class="site-description" itemprop="description">Self-talking of a noob</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Freeman Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
