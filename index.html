<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Self-talking of a noob">
<meta property="og:type" content="website">
<meta property="og:title" content="Freeman&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Freeman&#39;s Blog">
<meta property="og:description" content="Self-talking of a noob">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Freeman Huang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Freeman's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Freeman's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个菜鸡心血来潮搭建的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/JAVASE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/JAVASE/" class="post-title-link" itemprop="url">Java基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:12" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><ul>
<li>静态代理的麻烦：要为每一个实现类单独写一个代理类。<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2></li>
<li>对于实现了某个接口的类，能够直接生成<strong>接口的</strong>的代理对象（而不用写代理类）。</li>
<li>基本原理：利用Java反射机制</li>
<li>基本思路：<ol>
<li>接口有方法的定义，但是没有方法体，也没有构造器。通过反射的某个方法根据接口的方法信息创建一个有相同类结构信息但是有构造器的<strong>某个</strong>类。 -&gt; <code>java.lang.reflect.Proxy</code>类，提供静态方法<code>getProxyClass(ClassLoader loader, Class&lt;?&gt; ... interfaces)</code>，只要提供一个类加载器和接口(数组)，就可以生成一个代理类的<code>Class</code>对象。而这个代理类是有构造器的(可以通过<code>Class</code>对象调用<code>getConstructors()</code>)。该类没有无参构造器，需要传入实现<code>InvocationHandler</code>的类实例。</li>
<li>接口的方法体为空，在代理对象中使用传入的实现了<code>InvocationHandler</code>的实例即可利用代理目标在代理对象中执行代理目标的方法，并在代理目标的方法调用前后进行额外的操作或控制。代理对象需要持有实现了<code>InvocationHandler</code>接口的实例。在代理对象上调用代理目标的方法时，代理对象会通过实现了<code>InvocationHandler</code>的实例，将调用转移到代理目标上。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中，<code>proxy</code>为代理对象本身（而不是代理目标）。<code>method</code>为调用的方法，需要对<code>method</code>指定执行方法的目标才可以通过该参数调用方法。<code>args</code>为传入的参数。总之，单独有实现了<code>InvocationHandler</code>接口的实例还是不能正常地调用目标对象的方法，我们需要设法让<code>invoke</code>方法中可以获得到目标对象的引用。方法之一是让实现了<code>InvocationHandler</code>的类持有代理目标的引用（可以用构造函数传参的方式）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Objcet <span class="title">invoke</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>更简单地获得代理对象的方法：<code>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</code></li>
</ol>
</li>
</ol>
</li>
<li>优点：不用写代理类，直接生成代理对象。接口增加新方法时，代理对象可以不用进行修改。</li>
<li>缺点：只能对实现了接口的类使用。在代理对象上只能调用接口中定义的方法。</li>
</ul>
<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><ul>
<li>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。CGLIB属于开源项目，需要额外依赖。</li>
<li>基本思路：<ol>
<li>自定义<code>MethodInterceptor</code>并重写<code>intercept</code>方法。该方法用于拦截增强代理目标的方法，类似于JDK动态代理的<code>invoke</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中<code>o</code>是已经被增强的代理目标(the enhanced object)，<code>method</code>是被增强的方法(Intercepted Method)，<code>args</code>是方法调用的参数。<code>methodProxy</code>用于调用原始方法(super method, non-intercepted method)。<ol>
<li>获得代理类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设需要代理的目标类的Class对象是clazz</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">enhancer.setSuperclass(clazz);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> MyInterceptor());</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>CGLIB动态代理是通过生成一个代理目标的子类来拦截代理类的方法调用，因此不能代理声明为<code>final</code>的类和方法。</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p><img src="pics/JAVASE/java-collection-hierarchy.png" alt="javaColletion"></p>
<h2 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h2><ul>
<li>不同的接口，<code>Comparable</code>的方法是<code>compareTo(obj)</code>，<code>Comparator</code>的方法是<code>compare(obj1, obj2)</code></li>
</ul>
<h2 id="集合底层数据结构"><a href="#集合底层数据结构" class="headerlink" title="集合底层数据结构"></a>集合底层数据结构</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><code>ArrayList</code>、<code>Vector</code>: <code>Object[]</code>数组。<code>Vector</code>线程安全。</li>
<li><code>ArrayList</code>:<ul>
<li>真正持有函数的成员为<code>transient Object[] elementData</code></li>
<li>无参构造时，为<code>elementData</code>赋予静态成员<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code></li>
<li>带参构造时，如果参数<code>initialCapacity</code>为0，那么为<code>elementData</code>赋予静态成员<code>EMPTY_ELEMENTDATA</code>。如果参数为正整数则为<code>elementData</code>初始化一个指定容量的新数组。其他情况则抛出异常。</li>
<li>带参构造时，如果参数为空的集合(不是<code>null</code>)，那么也赋予<code>elementData</code>静态成员<code>EMPTY_ELEMENTDATA</code>的值</li>
<li>调用<code>add</code>方法时要调用<code>ensureCapacityInternal</code>方法保证数组容量足够。</li>
<li>无论如何，如果最开始不显式指定容量或者使用非空集合创建<code>ArrayList</code>，<code>ArrayList</code>都会将创建<code>DEFAULT_CAPACITY</code>个元素这一行为推迟到向<code>ArrayList</code>加入第一个元素时。</li>
<li><code>ArrayList</code>的扩容过程：<ol>
<li>首先计算扩容后的最小容量。如果当前数据为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，则扩容后容量至少为<code>Math.max(DEFAULT_CAPACITY, minCapacity)</code>。<code>DEFAULT_CAPACITY</code>为10。否则扩容后容量至少为<code>size + 1</code></li>
<li>如果<code>minCapacity &gt; elementData.length</code>则需要扩容。扩容的总体规则是，如果旧容量的1.5倍大于<code>minCapacity</code>则扩容1.5倍，否则扩容到<code>minCapacity</code>。此时创建扩容后的新数组并把原本存放在<code>elementData</code>中的元素复制到新数组</li>
<li>Java数组存在最大容量。最大容量一般稍微小于<code>Integer.MAX_VALUE</code>。<code>ArrayList</code>内部用<code>MAX_ARRAY_SIZE</code>保存一个稍微小于<code>Integer.MAX_VALUE</code>的值。如果出现了计算得到的新数组容量存在<code>newCapacity - MAX_ARRAY_SIZE &gt; 0</code>的情况，则判断<code>minCapacity</code>有没有溢出。如果溢出了32位整数的取值范围，则抛出OOM异常，如果没有溢出，则新容量为<code>(minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE</code>。</li>
</ol>
<ul>
<li>为什么要区分<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和<code>EMPTY_ELEMENTDATA</code>？（since Java 8）<ul>
<li>为了区分 “我就是要一个初始容量为0的<code>ArrayList</code>（显示指定初始容量为0，使用空集合初始化<code>ArrayList</code>）” 和 “我想要一个初始容量为<code>DEFAULT_CAPACITY</code>的<code>ArrayList</code>，但是我不一定马上要用，因此先返回容量为0的数组，等我要用的时候(第一次加入元素的时候)，再给我一次扩容上来” 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>LinkedList</code>: 双向（不循环）链表</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li><code>HashSet</code>: 基于<code>HashMap</code>实现，底层使用<code>HashMap</code>，使用成员对象来计算hashcode<ul>
<li>检查重复的方法：先计算hashcode值来判断对象加入的位置，同时与其它对象的hashcode值进行比较。如果发现相同hashcode值的对象，需要调用<code>equals</code>方法来检测对象是否真正相同。（hashcode的定义：同一个对象不可能有两个hashcode，不同对象的hashcode可能相同，其实就是“函数”的定义）</li>
</ul>
</li>
<li><code>LinkedHashSet</code>: 基于<code>LinkedHashMap</code>，能够按照添加的顺序进行遍历</li>
<li><code>TreeSet</code>: 有序，能按照添加元素的顺序进行遍历，唯一，基于红黑树</li>
</ul>
<h3 id="Map-需要重新看"><a href="#Map-需要重新看" class="headerlink" title="Map(需要重新看)"></a>Map(需要重新看)</h3><ul>
<li><code>HashTable</code>：内部方法都是synchronized的，线程安全。</li>
<li><code>HashMap</code>: 底层数据结构是数组+链表/红黑树。使用拉链法解决哈希冲突，JDK 1.8引入红黑树来优化过长的链表。HashMap会重新计算键的哈希值而不是使用hashCode。<ul>
<li>初始大小(<code>capacity</code>)为16，每次扩容时容量为原来的2倍。<code>HashMap</code>会让集合中的元素保持在一个合理的范围内（由装填因子load factor限制），如果元素数超过指定的阈值<code>this.threshold</code>时，则需要进行扩容并进行rehash。</li>
<li><code>HashMap</code>总是使用2的幂作为哈希表<code>threshold</code>的大小。<code>threshold</code>的值为大于或等于<code>capacity</code>的最小的2的n次幂。</li>
<li>使用Key来计算hashcode。通过key的hashcode经过<code>HashMap</code>的扰动函数<code>hash()</code>处理(防止较差的<code>hashCode()</code>实现导致<code>HashMap</code>性能下降)后得到真正的hash值，然后通过<code>(n - 1) &amp; hash</code>（<code>n</code>为HashMap数组的长度，该运算等价于用hash对长度取余）的方式计算当前元素要存储的位置。</li>
<li>Table数组：hash表的桶(bucket)。数组的每个位置上都是一个链表。当链表长度大于阈值（默认为8）时，如果当前数组长度小于64，则进行数组扩容，否则将这个链表转换为红黑树。<br><img src="pics/jdk1.8之后的内部结构-HashMap.png" alt="HashMap"></li>
</ul>
</li>
<li><code>TreeMap</code>实现了<code>NavigableMap</code>实现对集合内元素的搜索能力，实现<code>SortedMap</code>来实现对元素根据key进行排序的能力。</li>
<li><code>HashMap</code>不是线程安全的</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/JMM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/JMM/" class="post-title-link" itemprop="url">Java内存模型(JMM)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:14" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="从CPU-寄存器-高速缓存-内存说起"><a href="#从CPU-寄存器-高速缓存-内存说起" class="headerlink" title="从CPU-寄存器-高速缓存-内存说起"></a>从CPU-寄存器-高速缓存-内存说起</h1><ul>
<li>问题：CPU不可能只靠寄存器来完成运算任务，但CPU的速度和内存的存取速度相差太远。</li>
<li>解决：引入高速缓存来缓和CPU速度和内存存取速度的差异。CPU直接独写高速缓存，运算结束再将数据从缓存同步回内存中。</li>
<li>新的问题：缓存一致性。多个CPU有自己的高速缓存，但是他们共享同一个内存，如果多个CPU的运算涉及同一个内存区域将产生数据的不一致问题。此时需要引入缓存一致性协议。<ul>
<li>处理器对内存的读写操作的执行顺序，不一定与内存实际发生的独写顺序一致。</li>
</ul>
</li>
</ul>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul>
<li>一组规范，并不真实存在，定义了一组规则，定义了程序中各个变量的访问方式(确认一段程序的执行轨迹是否是合法的)。</li>
<li>检查程序执行轨迹的每个读操作，根据一些规则检查读操作观察到的写操作是否是有效的。</li>
<li>JMM的实现可以是任意的，只要生成的代码的执行结果能够根据JMM的规则进行预测即可（松规范，给编译器/JVM实现者进行优化的空间，比如指令重排序或者移除不必要的同步）。</li>
</ul>
<h2 id="JMM的规定"><a href="#JMM的规定" class="headerlink" title="JMM的规定"></a>JMM的规定</h2><ul>
<li>所有共享变量（不包括局部变量，局部变量线程私有）都存储于主内存。共享变量：实例变量、类变量（静态字段）、数组元素。</li>
<li>每一个线程还在自己的工作内存中保留了被线程使用的变量的工作副本。</li>
<li>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</li>
<li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</li>
<li>intra-thread semantics: 保证重排序不会改变单线程内的程序执行结果。</li>
<li>对指令的重排序：<ul>
<li>as-if-serial：不能改变单线程程序的语义，重排序后单线程程序的执行结果不能被改变。</li>
<li>不存在数据依赖性的情况下，处理器可以进行重排序<ul>
<li>两个操作访问同一个变量，且其中一个操作为写操作，此时两个操作之间存在依赖性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Java内存模型的三大特性（JMM在多线程环境下的三个问题）"><a href="#Java内存模型的三大特性（JMM在多线程环境下的三个问题）" class="headerlink" title="Java内存模型的三大特性（JMM在多线程环境下的三个问题）"></a>Java内存模型的三大特性（JMM在多线程环境下的三个问题）</h2><ol>
<li>可见性：一个线程修改了共享变量的值，其他线程能够立即得知这个修改。而单纯遵照JMM的规定，多线程程序中单个线程并不一定能马上获知其它线程对共享变量的更改。JMM通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性。<ul>
<li><code>volatile</code>关键字：</li>
<li><code>synchronized</code>关键字：进入<code>synchronized</code>代码块前，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本。进入<code>synchronized</code>代码后，会将修改后的副本的值刷新回主内存中，线程才会释放锁。</li>
<li><code>final</code>关键字</li>
</ul>
</li>
<li>原子性(?)：</li>
<li>有序性<ul>
<li>进行指令重排的时候必须考虑数据的依赖性。</li>
<li>在多线程程序中，不同线程之间存在控制依赖关系重排序可能会改变程序的执行结果。</li>
<li>举例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlDependency</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">      flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line">         <span class="keyword">int</span> i = a * a; <span class="comment">// 4</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 在单线程环境下，语句1、2和语句3、4都不存在数据依赖性，因此指令会被重排序。但是在编译器在判断if语句块时会对语句块的内容进行猜测，因此会存在先执行<code>int i = a * a;</code>，然后再判断flag。如果另一线程在执行<code>init</code>时将指令重排序，先执行<code>flag = true</code>，然后又发生了线程切换，这时a的值为0，<code>flag</code>的值却为<code>true</code>。这样就会得到错误的结果<code>int i = 0</code>;</li>
</ul>
</li>
</ol>
<h2 id="怎么解决JMM在多线程环境下的问题"><a href="#怎么解决JMM在多线程环境下的问题" class="headerlink" title="怎么解决JMM在多线程环境下的问题"></a>怎么解决JMM在多线程环境下的问题</h2><ol>
<li>插入内存屏障禁止指令重排序。（<code>volatile</code>）</li>
<li>设置临界区。（<code>synchronized</code>）:JMM允许临界区内的代码重排序，不允许临界区内的代码逃逸到临界区之外。</li>
<li>Happens-Before语义：如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。但这并不意味之前一个操作必须在后一个操作之前执行。Happens-before语义类似于单线程环境下的as-if-serial语义，它保证<strong>正确同步</strong>的多线程程序执行结果不被改变。<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><code>volatile</code>变量规则：对一个<code>volatile</code>字段的写操作happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：A happens-before B ，B happens-before C，那么A happens-before C</li>
<li>start()规则：如果线程A执行<code>ThreadB.start()</code>，那么A线程的start() happens-before于线程B中的任意操作</li>
<li>join()规则：如果线程A执行<code>ThreadB.join()</code>，那么线程B中的任意操作happens-before于线程A从<code>ThreadB.join()</code>成功返回</li>
<li>线程中断规则：对线程<code>interrput</code>方法的调用happens-before于被中断线程的代码检查到中断事件的发生。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/Netty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/Netty/" class="post-title-link" itemprop="url">Netty</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:22" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<ul>
<li>[] Netty线程模型</li>
<li>[] Zero Copy</li>
</ul>
<h1 id="反应器模式"><a href="#反应器模式" class="headerlink" title="反应器模式"></a>反应器模式</h1><ul>
<li>反应器Reactor: 负责查询IO事件。检测到一个IO事件时，将其发送给相应的Handler处理器去处理。这里的IO事件就是NIO中选择器监控的通道IO事件。</li>
<li>Handler处理器：与IO事件绑定，负责IO事件的处理。例如，完成真正的连接建立、通道（channel）的读取、处理业务逻辑、负责将结果写出到通道等。</li>
</ul>
<h2 id="单线程的Reactor模式"><a href="#单线程的Reactor模式" class="headerlink" title="单线程的Reactor模式"></a>单线程的Reactor模式</h2><ul>
<li>Reactor和Handler在同一线程中运行。</li>
<li>相对于传统的多线程Blocking-IO，免去了线程切换的成本</li>
<li>缺点：Reactor和Handler都在同一线程上执行。如果一个Handler被阻塞，其它所有的Handler都得不到执行。假如负责监听连接的Handler和负责数据输入输出的Handler都在同一个线程上，负责监听连接的Handler可能会被阻塞，此时整个服务都不能接受新的连接。</li>
<li>思考：为什么Redis使用了单线程的Reactor模式？<ul>
<li>Redis是一个服务器，Redis的数据操作多数都在内存中，因此Handler的操作耗时应该非常少</li>
<li>多个线程切换需要线程切换开销，如果Handler并不需要很长的阻塞时间，使用多线程模型可能弊大于利</li>
<li>Redis是一个数据库，如果使用多线程的IO模型，多个线程可能会对同一个数据进行操作，此时需要引入同步机制，而同步机制的开销是相当大的。使用单线程模型，天然保证了单个Redis的数据库操作的原子性。</li>
</ul>
</li>
</ul>
<h2 id="多线程的Reactor模式"><a href="#多线程的Reactor模式" class="headerlink" title="多线程的Reactor模式"></a>多线程的Reactor模式</h2><ol>
<li>升级Handler：使用线程池</li>
<li>升级Reactor：引入多个Selector，将单个Reactor线程拆分为多个SubReactor线程，每个SubReactor线程使用一个Selector。</li>
</ol>
<h2 id="VS-生产者消费者模式"><a href="#VS-生产者消费者模式" class="headerlink" title="VS 生产者消费者模式"></a>VS 生产者消费者模式</h2><p>反应器模式没有专门的队列去缓冲存储IO事件</p>
<h2 id="VS-观察者模式"><a href="#VS-观察者模式" class="headerlink" title="VS 观察者模式"></a>VS 观察者模式</h2><p>在Reactor模式中一个事件绑定到了一个Handler上，每个IO事件被查询后Reactor会将事件分发给所绑定的Handler。而观察者模式中同一个事件（主题）可以被订阅过的多个观察者处理。</p>
<h2 id="Reactor的优缺点"><a href="#Reactor的优缺点" class="headerlink" title="Reactor的优缺点"></a>Reactor的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>响应快，不会被单个连接的同步IO阻塞整个服务</li>
<li>编程相对简单</li>
<li>可扩展：增加Reactor线程的个数</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>增加一定复杂性</li>
<li>需要OS底层IO多路复用的支持</li>
</ul>
<h1 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h1><h2 id="Netty中的Reactor"><a href="#Netty中的Reactor" class="headerlink" title="Netty中的Reactor"></a>Netty中的Reactor</h2><h3 id="NioEventLoop类"><a href="#NioEventLoop类" class="headerlink" title="NioEventLoop类"></a>NioEventLoop类</h3><ul>
<li>一个<code>NioEventLoop</code>拥有一个线程，负责一个Java NIO <code>Selector</code>上的IO事件轮询。一个Reactor可以注册多个netty channel。一个<code>EventLoop</code>相当于一个(Sub)Reactor。</li>
<li><code>EventLoopGroup</code>：线程组，多线程版本的反应器，其中的每一个<code>EventLoop</code>为一个SubReactor。</li>
</ul>
<h3 id="Netty通道-Channel"><a href="#Netty通道-Channel" class="headerlink" title="Netty通道(Channel)"></a>Netty通道(Channel)</h3><ul>
<li>Netty channel(TCP服务器里主流的就是<code>NioSocketChannel</code>)封装的就是Java NIO通道。Java NIO通道对应的就是OS底层的文件描述符(File Descriptor, fd)。</li>
<li>连接监听型socket描述符：接受客户端的socket连接。对应<code>ServerSocketChannel</code>(Java NIO)和<code>NioServerSocketChannel</code>(Netty)</li>
<li>传输数据型socket描述符：负责传输数据，在客户端和服务端都会有一个与一条TCP连接相对应的socket描述符进行数据传输。对应<code>SocketChannel</code>(Java NIO)和<code>NioSocketChannel</code>(Netty)</li>
<li>有接受关系的<code>NioServerSocketChannel</code>和<code>NioSocketChannel</code>可以被称为亲子(Parent - Child)通道</li>
</ul>
<h2 id="Netty的入站处理和出站处理"><a href="#Netty的入站处理和出站处理" class="headerlink" title="Netty的入站处理和出站处理"></a>Netty的入站处理和出站处理</h2><ul>
<li>通道中发生IO事件 -&gt; 被EventLoop查询到 -&gt; 分发给实现了<code>ChannelInboundHandler</code>处理器，并调用该处理器的对应处理方法(比如<code>channelRead</code>方法，这个事件在pipeline中可以通过pipeline上下文进行冒泡)，进行一系列业务处理 -&gt; 如果事件超出管道顶端，则会被抛弃，也可以通过事件冒泡的方式传递到出站处理器，通常由出站处理器生成或者处理出站流量 -&gt; 事件被出站处理器处理 -&gt; 如果IO事件到达了出站管道的底部，则IO事件会交由与该channel相关联的线程进行处理，这个IO线程通常会执行实际的IO操作。</li>
</ul>
<h2 id="Netty管道-pipeline"><a href="#Netty管道-pipeline" class="headerlink" title="Netty管道(pipeline)"></a>Netty管道(pipeline)</h2><ul>
<li>Handler和Reactor是多对多的关系，一个Handler可以处理多个Reactor上分发的IO事件，一个Reactor上可以使用多个Handler来处理IO事件。多个Handler可以组成一个pipeline。</li>
<li>一个Netty Channel拥有一条Pipeline。</li>
<li>IO事件在Pipeline上进行双向流动，入站时按顺序由实现了<code>ChannelInboundHandler</code>的处理器处理，出站时按逆序由实现了<code>ChannelOutboundHandler</code>的处理器处理。一个Handler可以同时实现这两个接口，这样出入站都会参与处理。</li>
</ul>
<h2 id="Netty脚手架-Bootstrap"><a href="#Netty脚手架-Bootstrap" class="headerlink" title="Netty脚手架(Bootstrap)"></a>Netty脚手架(Bootstrap)</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/ORM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/ORM/" class="post-title-link" itemprop="url">ORM框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:34" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h1><ul>
<li>将Java Bean转换成行记录</li>
<li>将行记录转换为Java Bean</li>
</ul>
<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><ul>
<li>通过<code>Entity</code>标注实体类，可用<code>@Table(name=&quot;...&quot;)</code>来标识对应的表名。通过<code>@Column(...)</code>建立Java Bean字段和数据库表的列的对应关系</li>
<li>实体类之间可以有继承关系: 父类使用<code>@MappedSuperClass</code>标识</li>
<li>提供自动生成的插入/删除/修改(<code>update</code>)/查询（<code>findByExample</code>/<code>findByCriteria</code>/<code>HQL</code>，使用类名和属性名，由Hibernate转换成实际的表名和列名）</li>
<li>ORM如何将对Java Bean的修改反应到数据库中（调用<code>update</code>时如何确定哪些字段更新了）<ul>
<li>使用代理模式，从ORM读出的对象是代理对象，原对象的每个属性都附加一个标志变量说明这个对象是否被修改。</li>
</ul>
</li>
</ul>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><ul>
<li>半自动ORM：可以完成Java Bean到数据行和数据行到Java Bean的双向转换，但是SQL需要用户自行编写。</li>
<li>属性名与列名不一致？：添加<code>ResultMap</code>（注解或XML）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:39" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<ul>
<li>[x] SpringMVC原理</li>
</ul>
<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><ul>
<li>多模块的集合<ul>
<li>核心容器（IOC）</li>
<li>数据访问</li>
<li>Web</li>
<li>AOP</li>
</ul>
</li>
</ul>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="Component和-Bean"><a href="#Component和-Bean" class="headerlink" title="@Component和@Bean"></a>@Component和@Bean</h3><ul>
<li><code>@Component</code>作用于类，使用该注解的类通常会通过classpath扫描来自动侦测并被装配到Spring容器中。可以通过<code>@ComponentScan</code>来定义要扫描的路径，以及定义排除规则。</li>
<li><code>@Bean</code>作用于方法，说明标有该注解的方法中会产生一个Bean。使用第三方库的时候，如果需要将第三方库的类装配到Spring容器中，可以定义一个产生该类的方法并附加<code>@Bean</code>注解。同时，使用<code>@Bean</code>可以实现根据不同条件进行不同的装配操作（在方法中编写条件代码），比<code>@Component</code>相对灵活。</li>
</ul>
<h3 id="如何将一个类声明为Spring的Bean"><a href="#如何将一个类声明为Spring的Bean" class="headerlink" title="如何将一个类声明为Spring的Bean"></a>如何将一个类声明为Spring的Bean</h3><ul>
<li><code>@Component</code>: 通用</li>
<li><code>@Repository</code>: 对应持久层（DAO）</li>
<li><code>@Service</code>: 对应服务层</li>
<li><code>@Controller</code>: 对应控制层</li>
<li><code>@Configuration</code>: 配置类</li>
<li>名称：<code>@....(value = &quot;...&quot;)</code></li>
</ul>
<h3 id="Controller-RestController"><a href="#Controller-RestController" class="headerlink" title="@Controller, @RestController"></a>@Controller, @RestController</h3><ul>
<li>都是表明某类是一个Controller的注解。Dispatcher会扫描使用了这两个注解的类的方法，并检查该方法是否使用了<code>@RequestMapping</code>或<code>@GetMapping</code>一类的注解。</li>
<li><code>@Controller</code>一般用于返回一个视图（一个页面，可以是使用模板引擎进行渲染的页面）。如果要返回JSON或XML格式的数据，需要搭配使用<code>@ResponseBody</code>注解。如果处理器方法被注解<code>@ResponseBody</code>的话，该方法的返回类型会通过适当的Converter转换后写到<code>HttpServletResponse</code>中，而不是被当成视图处理。</li>
<li><code>@RestController</code>，是<code>@Controller</code>和<code>@ResponseBody</code>的结合，只返回对象，对象数据直接以JSON或XML形式写入HTTP响应中。</li>
</ul>
<h3 id="属性注入：-Autowired-Qualifier-Resource"><a href="#属性注入：-Autowired-Qualifier-Resource" class="headerlink" title="属性注入：@Autowired @Qualifier @Resource"></a>属性注入：@Autowired @Qualifier @Resource</h3><ul>
<li><code>@AutoWired</code>：根据类型进行自动装配</li>
<li><code>@Qualifier</code>: 根据属性名称进行注入，需要和<code>@Autowired</code>配合使用。<code>@Qualifier(value = &quot;...&quot;)</code></li>
<li><code>@Resource</code>: 可以根据类型注入，也可以根据名称注入</li>
<li><code>@Value</code>：注入普通类型属性, <code>@Value(&quot;classpath:/...&quot;)</code>…</li>
</ul>
<h3 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h3><ul>
<li><code>@PathVariable</code>: 路径参数</li>
<li><code>@RequestParam</code>: 查询参数（Query String）</li>
<li><code>@RequestBody</code>: 读取Request请求。<code>Content-Type</code>为<code>application/json</code>格式时，接收到数据之后会自动将数据绑定到Java对象上去。系统使用<code>HttpMessageConverter</code>或自定义的Converter将body中的json字符串转换为Java对象。</li>
</ul>
<h3 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h3><ul>
<li><code>@PropertySource(&quot;app.properties&quot;)</code> + <code>@Value(&quot;$&#123;app.property:defaultValue&#125;&quot;)</code></li>
<li><code>@ConfigurationProperties(prefix = &quot;...&quot;)</code>: 读取配置信息并与Bean绑定</li>
</ul>
<h3 id="Json数据处理"><a href="#Json数据处理" class="headerlink" title="Json数据处理"></a>Json数据处理</h3><ul>
<li><code>@JsonIgnoreProperties(&#123;&quot;字段名&quot;&#125;)</code>: 过滤掉特定字段不返回或者不解析</li>
<li><code>@JsonIgnore</code>: 同上，不过直接作用于类的属性上</li>
<li><code>@JsonFormat</code>: 格式化JSON数据</li>
<li><code>@JsonUnwrapped</code>: 扁平化对象</li>
</ul>
<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="怎么理解IOC"><a href="#怎么理解IOC" class="headerlink" title="怎么理解IOC"></a>怎么理解IOC</h2><p>IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中<strong>手动创建对象的控制权，交由Spring框架来管理</strong>。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<ul>
<li>传统的<code>new</code>关键字进行手动装配存在一定困难<ul>
<li>实例化组件的过程是复杂的，某些组件需要读取配置才能完成实例化</li>
<li>组件之间存在依赖关系，但多个组件依赖一个组件时，很多时候只需要依赖组件的单个实例，没有必要多次实例化。而实现这一点需要理清组件之间的依赖关系，以确定恰当的实例化顺序，这对于手动装配而言是麻烦的</li>
<li>有时候组件需要进行销毁以释放资源，但销毁组件时需要确定所有依赖该组件的其他组件也已经被销毁</li>
</ul>
</li>
<li>因此IOC容器的职责就是<ul>
<li>负责创建组件</li>
<li>负责根据依赖关系组装组件</li>
<li>按照依赖顺序正确地销毁组件</li>
</ul>
</li>
<li>Spring IOC的无侵入性：组件无需要实现框架特定的接口。因此编写完成的组件可以自动装配也可以手动装配。并且测试组件的时候可以单独进行测试。<br>资源（对象）不由使用和提供资源的双方管理，而由第三方管理，集中式的管理容易配置，容易管理，也降低了资源提供方和使用方的耦合度。使得通过配置文件而不是在代码里硬编码（hardcode）的方式来实例化对象和装配对象图。</li>
<li>本质上，IOC容器是个Map。IOC容器可以这样完成自动装配<ul>
<li><code>BeanFactory</code>或<code>ApplicationContext</code>通过XML配置文件或classpath扫描获得所有的附加了<code>@Bean</code>的方法或者附加了<code>@Component</code>的注解，获得所有Bean的类名。通过对类名使用<code>Class.forName</code>可以完成类加载</li>
<li><code>BeanFactory</code>：加载配置时不创建对象，第一次通过<code>getBean</code>获取Bean时才会创建对象。<code>ApplicationContext</code>：加载配置时就创建对象</li>
</ul>
</li>
</ul>
<h2 id="Spring-Bean管理"><a href="#Spring-Bean管理" class="headerlink" title="Spring Bean管理"></a>Spring Bean管理</h2><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>Spring IOC容器原本支持的作用域只有singleton和prototpye。其它作用域是后续框架的增强。</p>
<ul>
<li>singleton：默认是单例的</li>
<li>prototype：每次获取bean时都会创建一个新的bean实例</li>
<li>request：每一次HTTP请求都会生成一个新的bean，仅在当前HTTP request内有效</li>
<li>session：每一次HTTP请求都会生成一个新的bean，仅在当前HTTP session内有效</li>
</ul>
<h3 id="单例bean的线程安全问题"><a href="#单例bean的线程安全问题" class="headerlink" title="单例bean的线程安全问题"></a>单例bean的线程安全问题</h3><ul>
<li>多个线程操作同一个单例对象时对这个对象的成员变量的写操作存在线程安全问题。</li>
<li>一般情况下，Controller、Service、Dao等Bean都应该是无状态的，不保存数据的Bean即使被多线程使用也是安全的。</li>
<li>如果需要成员变量，可以将成员变量保存在<code>ThreadLocal</code>中。或者将Bean的作用域改为prototype</li>
</ul>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><ul>
<li>实例化：实例化一个Bean对象</li>
<li>属性赋值：为Bean设置相关属性。如果该Bean依赖其它Bean，则获取对其它bean的引用</li>
<li>初始化：可能的Aware相关接口，BeanPostProcessor的前后置处理，是否实现<code>InitializingBean</code>接口，自定义的<code>init-method</code>（<code>@PostConstruct</code>）（如果Bean有定义初始化方法，则调用这些初始化方法）</li>
<li>销毁：自定义的<code>destroy-method</code>（容器关闭的时候，如果bean调用了销毁方法，则调用销毁方法<code>@PreDestroy</code>）<h4 id="常用扩展点（生命周期钩子？）"><a href="#常用扩展点（生命周期钩子？）" class="headerlink" title="常用扩展点（生命周期钩子？）"></a>常用扩展点（生命周期钩子？）</h4><h5 id="影响多个Bean的接口：后置处理器"><a href="#影响多个Bean的接口：后置处理器" class="headerlink" title="影响多个Bean的接口：后置处理器"></a>影响多个Bean的接口：后置处理器</h5></li>
<li>实现了这些接口的Bean会<strong>切入到多个Bean的生命周期</strong>中。</li>
<li>BeanPostProcessor：<strong>初始化</strong>阶段的前后，Bean实例会被传入这个后置处理器的方法。同时会返回一个Bean。String AOP可以在此处完成对Bean的增强，返回代理对象<ul>
<li><code>postProcessBeforeInitialization</code></li>
<li><code>postProcessAfterInitialization</code></li>
</ul>
</li>
<li>InstantiationAwareBeanPostProcessor：<strong>实例化</strong>阶段的前后<h5 id="只调用一次的接口"><a href="#只调用一次的接口" class="headerlink" title="只调用一次的接口"></a>只调用一次的接口</h5></li>
</ul>
<h2 id="Spring中的设计模式"><a href="#Spring中的设计模式" class="headerlink" title="Spring中的设计模式"></a>Spring中的设计模式</h2><ul>
<li>工厂模式：通过<code>BeanFactory</code>、<code>ApplicationContext</code>创建对象</li>
<li>代理模式：Spring AOP</li>
<li>单例模式：Spring中的单例Bean</li>
</ul>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="为什么要使用MVC设计模式"><a href="#为什么要使用MVC设计模式" class="headerlink" title="为什么要使用MVC设计模式"></a>为什么要使用MVC设计模式</h2><ul>
<li>将数据模型定义、控制逻辑和表现逻辑分离，降低各个模块之间的耦合度。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ul>
<li>客户端发送请求，通过<code>DispatcherServlet</code>接收请求。</li>
<li><code>DispatcherServlet</code>根据请求信息，从<code>HandlerMapping</code>查找对应的<code>HandlerAdapter</code>。</li>
<li>与<code>HandlerAdapter</code>相关的<code>Handler</code>调用真正的处理器来处理请求，完成相应的业务逻辑。<ul>
<li>为什么要区分<code>Handler</code>和<code>HandlerAdapter</code>？</li>
<li><code>HandlerAdapter</code>相当于一个代理。</li>
<li>我们编写的Controller希望能够将路径参数、URL参数和请求体都作为方法的参数传入。因此<code>HandlerAdapter</code>可以将<code>HttpServletRequest</code>中的URL参数、请求体等进行解析，然后使用反射机制调用<code>Handler</code>的方法，实现这一目的。</li>
</ul>
</li>
<li>处理完请求后，如果是RESTful接口，则将返回数据通过适当的转换器转换后写到<code>HttpServletResponse</code>中。</li>
<li>如果不是一个RESTful接口，处理完业务后会返回一个<code>ModelAndView</code>对象。</li>
</ul>
<h1 id="Spring-三级缓存"><a href="#Spring-三级缓存" class="headerlink" title="Spring 三级缓存"></a>Spring 三级缓存</h1><ul>
<li>一级缓存：<code>singletonObjects</code>：单例池，存放已经经历了完整生命周期的Bean(已经初始化好的Bean)</li>
<li>二级缓存：<code>earlySingletonObjects</code>：存放早期暴露出来的Bean对象，生命周期未结束（未完成初始化，属性未填充完）</li>
<li>三级缓存：<code>singletonFactories</code>：存放可以生成Bean的工厂<br><img src="./pics/微信截图_20210308160914.png" alt="springCache"></li>
<li>四大方法:<ul>
<li><code>getSingleton</code><ul>
<li>一级缓存没有，并且当前对象并不是创建过程中（<code>isSingletonCurrentlyInCreation</code>返回<code>false</code>）就去二级缓存找</li>
<li>二级缓存没有，就去三级缓存找</li>
<li>三级缓存有的话（能够获得对应的FactoryBean），就通过factory创建一个原始Bean，放到二级缓存，并删除三级缓存中的factory</li>
</ul>
</li>
<li><code>doCreateBean</code></li>
<li><code>populateBean</code></li>
<li><code>earlySingletonObjects</code></li>
</ul>
</li>
<li>Spring创建Bean的过程：创建原始的bean对象，然后填充对象属性进行初始化</li>
<li>每次创建单例Bean之前先在一级缓存中检查是否已经创建过</li>
</ul>
<h1 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>多个Bean之间互相依赖，形成闭环。默认B的单例Bean中，属性互相引用的场景。</li>
<li>构造方法注入，setter方法注入</li>
<li>构造方法注入可能导致循环依赖问题。并且坚持使用构造方法注入是无法解决的。<ul>
<li>注：一般情况下推荐使用构造注入</li>
<li>使用基于setter方法的注入代替构造方法注入</li>
<li>只要注入方式是setter方法注入，且Bean为单例Bean(<code>@Component</code>)，则能够解决循环依赖问题</li>
<li>原型（prototpye, <code>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code>, <code>@Scope(&quot;prototype&quot;)</code>）的场景无法支持循环依赖，会报错<code>BeanCurrentlyInCreationException</code>。</li>
</ul>
</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>Spring内部通过三级缓存解决循环依赖：<code>DefaultSingletonBeanRegistry</code></li>
<li>单例Bean：三级缓存提前暴露，依靠Bean的“中间态”概念，中间态指的是已经实例化但没有初始化的状态</li>
<li>非单例Bean：每次都要获取一个新的对象，要重新创建，没有缓存</li>
<li>创建单例Bean A的原始对象后（未填充属性），将其放入三级缓存，然后开始填充对象属性。此时发现Bean A需要依赖Bean B，顺序查找三级缓存未能找到Bean B，于是进行BeanB的创建。经过相似的过程后会发现创建Bean B需要Bean A</li>
<li>此时Bean B在第三级缓存中查找到Bean A的原始对象，直接将原始对象注入Bean B（提前暴露Bean A），完成对Bean B的创建。</li>
<li>Bean B创建完毕后Bean A的创建流程即可继续，完成属性填充的工作。<br><img src="./pics/微信截图_20210308184933.png" alt="SpringCircularDependency"></li>
</ul>
<h3 id="为什么一定要用三级缓存？"><a href="#为什么一定要用三级缓存？" class="headerlink" title="为什么一定要用三级缓存？"></a>为什么一定要用三级缓存？</h3><ul>
<li>维持Spring Bean的生命周期</li>
</ul>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="怎么理解"><a href="#怎么理解" class="headerlink" title="怎么理解"></a>怎么理解</h2><p>能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制、统一的错误处理等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Spring AOP基于动态代理。如果代理对象实现了某个接口，使用JDK动态代理。否则使用CGLIB生产一个被代理对象的子类作为代理。<br><img src="./pics/spring/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<h2 id="Spring-AOP和AspectJ-AOP的区别"><a href="#Spring-AOP和AspectJ-AOP的区别" class="headerlink" title="Spring AOP和AspectJ AOP的区别"></a>Spring AOP和AspectJ AOP的区别</h2><ul>
<li>Spring AOP无论是使用JDK提供的Proxy还是CGLIB，本质都是动态代理，在运行时对类进行增强。而AspectJ AOP其实使用了静态代理的方法，在编译字节码时在方法的周围加上业务逻辑，是编译期通过操作字节码完成静态织入。</li>
<li>AspectJ的功能更强大，同时性能更好，因为对方法的增强在编译期就已经完成了。</li>
</ul>
<h2 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h2><ul>
<li><code>@Before</code></li>
<li><code>@After</code></li>
<li><code>@AfterReturning</code></li>
<li><code>@AfterThrowing</code></li>
<li><code>@Around</code></li>
</ul>
<h2 id="AOP的执行顺序"><a href="#AOP的执行顺序" class="headerlink" title="AOP的执行顺序"></a>AOP的执行顺序</h2><ul>
<li>正常执行：环绕Before -&gt; Before -&gt; AfterReturn -&gt; After -&gt; 环绕After</li>
<li>异常流程：环绕Before -&gt; Before -&gt; AfterThrowing -&gt; After</li>
</ul>
<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><ul>
<li>编程式事务：<code>TransactionTemplate</code>，<code>TransactionManager</code></li>
<li>声明式事务：基于XML、基于注解<ul>
<li>实现原理：动态代理<h2 id="Spring事务的隔离级别-isolation"><a href="#Spring事务的隔离级别-isolation" class="headerlink" title="Spring事务的隔离级别(isolation)"></a>Spring事务的隔离级别(isolation)</h2></li>
</ul>
</li>
<li><code>TransactionDefinition.ISOLATION_DEFAULT</code>: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="Spring事务的传播-propagation"><a href="#Spring事务的传播-propagation" class="headerlink" title="Spring事务的传播(propagation)"></a>Spring事务的传播(propagation)</h2><h3 id="加入当前事务"><a href="#加入当前事务" class="headerlink" title="加入当前事务"></a>加入当前事务</h3><ul>
<li><code>TransactionDefinition.PROPAGATION_REQUIRED</code>： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><code>TransactionDefinition.PROPAGATION_MANDATORY</code>： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<h3 id="挂起当前事务"><a href="#挂起当前事务" class="headerlink" title="挂起当前事务"></a>挂起当前事务</h3><ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h2 id="Transcational-rollbackFor-Exception-class"><a href="#Transcational-rollbackFor-Exception-class" class="headerlink" title="@Transcational(rollbackFor = Exception.class)"></a>@Transcational(rollbackFor = Exception.class)</h2><ul>
<li>让Spring事务遇到非运行时异常时也回滚。</li>
</ul>
<h2 id="事务超时属性-timeout"><a href="#事务超时属性-timeout" class="headerlink" title="事务超时属性(timeout)"></a>事务超时属性(timeout)</h2><ul>
<li>在<code>TransactionDefinition</code>中以int类型<code>timeout</code>表示超时时间</li>
</ul>
<h2 id="事务只读属性-readOnly"><a href="#事务只读属性-readOnly" class="headerlink" title="事务只读属性(readOnly)"></a>事务只读属性(readOnly)</h2><h2 id="自调用问题"><a href="#自调用问题" class="headerlink" title="自调用问题"></a>自调用问题</h2><p>若同一类中的其他没有 <code>@Transactional</code> 注解的方法内部调用有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。<br>因为Spring AOP的实现原因，当含有<code>@Transactional</code>注解的方法在类以外被调用的时候，Spring事务管理才生效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/SpringBoot/" class="post-title-link" itemprop="url">SpringBoot</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:38:42" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<p>TODOS:</p>
<ul>
<li>[] SpringBoot的启动流程</li>
</ul>
<h1 id="SpringBoot帮我们干了什么"><a href="#SpringBoot帮我们干了什么" class="headerlink" title="SpringBoot帮我们干了什么"></a>SpringBoot帮我们干了什么</h1><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><ul>
<li>父项目完成依赖管理（<code>spring-boot-starter-parent</code>）。父项目几乎声明了常用的所有依赖的版本号</li>
<li>开发时导入starter场景启动器：对于一个场景，引入starter依赖会引入该场景相关的所有常规依赖<ul>
<li>所有场景启动器都依赖<code>spring-boot-starter</code></li>
</ul>
</li>
<li>无需关注版本号，完成自动版本仲裁<ul>
<li>查看<code>spring-boot-dependencies</code>中的依赖标签名。也可以在项目中的<code>&lt;properties&gt;</code>标签中自定义依赖的版本号</li>
</ul>
</li>
</ul>
<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><ul>
<li>对于一个场景中的各种依赖会提供默认配置，开箱即用（例如<code>web.xml</code>中的各种设置，例如字符编码…etc）</li>
<li>默认的包结构（包扫描的目录：主程序所在的包及其子包中的所有类都会被扫描</li>
<li>各种配置拥有默认值（默认端口，默认值…），配置类持有这些默认值，而在SpringBoot类的项目配置文件中(<code>application.properties</code>/<code>application.yml</code>)进行设置可以将这些值绑定到<strong>对应的</strong>配置类上，配置类会被加载到容器中发挥作用。</li>
<li>按需加载自动配置项：引入的时候自动配置才会开启<ul>
<li>所有的自动配置功能都在<code>spring-boot-autoconfigure</code>中</li>
</ul>
</li>
</ul>
<h1 id="底层注解"><a href="#底层注解" class="headerlink" title="底层注解"></a>底层注解</h1><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>默认加在主类上，是<code>@SpringBootConfiguration</code>（其实就是<code>@Configuration</code>, 允许在Spring上下文中注册额外的Bean或导入其它配置类）、<code>@EnableAutoConfiguration</code>（启动Springboot自动配置机制）、<code>@ComponentScan</code>（扫描Bean，扫描该类所在包下所有的类）的集合。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><ul>
<li>声明配置类，作用如<code>beans.xml</code></li>
<li>创建Bean：<ul>
<li>在类中创建方法并附加<code>@Bean</code>注解，方法名就是组件ID，返回类型就是组件类型，返回值就是组件实例。默认为单例Bean</li>
</ul>
</li>
<li>默认<code>proxyBeanMethods = true</code>：代理Bean的方法。可以说明<code>@Configuration</code>中的方法是被代理的。（重复直接调用单例Bean的创建方法不会返回不同对象，说明方法已经被代理）<ul>
<li>Full配置与Lite配置：Full模式中配置类的<code>proxyBeanMethods = true</code>，Lite模式中为<code>false</code></li>
</ul>
</li>
</ul>
<h2 id="Import-Class-lt-gt"><a href="#Import-Class-lt-gt" class="headerlink" title="@Import(Class&lt;?&gt;[])"></a>@Import(Class&lt;?&gt;[])</h2><ul>
<li>向容器中导入指定的类的实例</li>
</ul>
<h2 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h2><ul>
<li>满足条件时才进行装配 </li>
</ul>
<h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><ul>
<li>从classpath中搜索配置文件，注入配置文件中描述的Bean</li>
</ul>
<h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><ul>
<li>从配置文件中读取配置，绑定到容器中的Bean的属性上</li>
<li><code>@EnableConfigurationProperties</code>：附加在配置类上，开启指定类的属性配置功能，同时把这个类的对象加入容器中。主要在为第三方包的类进行配置绑定时使用。（因为没办法在第三方的类加注解）</li>
</ul>
<h1 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h1><h2 id="核心注解-EnableAutoConfiguration"><a href="#核心注解-EnableAutoConfiguration" class="headerlink" title="核心注解@EnableAutoConfiguration"></a>核心注解<code>@EnableAutoConfiguration</code></h2><h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><p><img src="./pics/springboot/AutoConfigurationPackage.png" alt="AutoConfigurationPackage"></p>
<h3 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h3><ul>
<li>其中包含注解<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>。</li>
<li><code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry();</span><br><span class="line"></span><br><span class="line"><span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</li>
<li>用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName。为排除</li>
<li>获取需要自动装配的所有配置类，读取META-INF/spring.factories（所有引入的starter依赖中都需要定义<code>/META-INF/spring.factories</code>，才能被SpringBoot的自动装配机制捕捉到），查找出所有的<code>XXXAutoConfiguration</code>。</li>
<li>对自动配置器进行筛选，在<code>XXXAutoConfiguration</code>类中的<code>@ConditionalOnClass</code>中，规定只有相关的类存在的时候（也就是classpath下有指定类的时候），才会将加载器实例化并注入IOC容器中，进而完成下一步的自动装配。</li>
</ol>
<h2 id="手写Starter"><a href="#手写Starter" class="headerlink" title="手写Starter"></a>手写Starter</h2><ol>
<li>命名最好是<code>XXX-spring-boot-starter</code>，而不是<code>spring-boot-starter-XXX</code>，后者是SpringBoot官方的Starter的命名方式</li>
<li>引入依赖：<code>spring-boot-starter-parent</code>, <code>spring-boot-starter</code></li>
<li>创建自动配置器：带有<code>@Configuration</code>注解的类，这样其中的方法可以向IOC容器注入Bean。需要为类或者方法附加<code>@ConditionalOnClass</code>注解，否则无论如何都会为Spring注入Bean。</li>
<li>在工程的resource目录下创建<code>/META-INF/spring.factories</code>文件，文件内容包含<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</code>以及自动装配器的全限定类名。</li>
<li>最后在SpringBoot项目中引入该starter，即可实现自动装配。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">分布式理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:37:39" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<ul>
<li>[] CAP理论彻底理清</li>
<li>[] 常见中间件在CAP理论中的定位: <ul>
<li>[] MySQL Cluster</li>
<li>[] Redis Cluster</li>
<li>[] Redis Sentinel</li>
<li>[] Zookeeper</li>
<li>[] Eureka</li>
<li>[] Nacos</li>
<li>[] HDFS(?)</li>
</ul>
</li>
<li>[] 常见算法（优缺点及其原因<ul>
<li>2PC协议/3PC协议</li>
<li>Paxos简单情况</li>
<li>ZAB</li>
<li>Raft</li>
</ul>
</li>
</ul>
<h1 id="多机器的时钟同步"><a href="#多机器的时钟同步" class="headerlink" title="多机器的时钟同步"></a>多机器的时钟同步</h1><ul>
<li>分布式环境下多台机器的时间流动可能是不一样的，需要一种机制来进行时钟同步，在多个机器间确定事件的发生顺序</li>
<li>全序：任意两个元素都有二元关系，可比较</li>
<li>偏序：只有部分元素可以比较，无法确定所有元素的准确顺序</li>
<li>在单节点系统上维持全序关系是容易的，但是在分布式系统上维持全序关系需要付出代价。通信的代价是昂贵的，时间的同步是非常困难并且脆弱的。</li>
</ul>
<h2 id="全局时间"><a href="#全局时间" class="headerlink" title="全局时间"></a>全局时间</h2><ul>
<li>理想世界，每个节点使用同一个有完美准确度的时钟</li>
</ul>
<h2 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h2><h2 id="逻辑时间戳"><a href="#逻辑时间戳" class="headerlink" title="逻辑时间戳"></a>逻辑时间戳</h2><ul>
<li>“逻辑时间（logical time）”而非真实时间来记录因果关系：使用计数器和通信机制来判断事件发生的顺序</li>
<li>无法得知有关时间间隔的信息，也无法使用超时机制</li>
</ul>
<h2 id="向量时间戳"><a href="#向量时间戳" class="headerlink" title="向量时间戳"></a>向量时间戳</h2><h3 id="Simple-Lamport-Clock"><a href="#Simple-Lamport-Clock" class="headerlink" title="Simple Lamport Clock"></a>Simple Lamport Clock</h3><p>进程工作 -&gt; 计数器自增<br>发送消息 -&gt; 携带计数器值<br>接收消息 -&gt; 合并计数器</p>
<ul>
<li>偏序关系：若timestamp(a) &lt; timestamp(b)，则a可能在b之前发生，也可能无法比较。因为一个Lamport clock只能携带1条时间线的信息，因此可能发生“明明是同时发生的事件，却被排序”的情况。</li>
</ul>
<h3 id="Vector-Clock"><a href="#Vector-Clock" class="headerlink" title="Vector Clock"></a>Vector Clock</h3><h1 id="FLP-impossiblity-result"><a href="#FLP-impossiblity-result" class="headerlink" title="FLP impossiblity result"></a>FLP impossiblity result</h1><ul>
<li>假设<ul>
<li>节点只会fail by crashing，不存在拜占庭式错误</li>
<li>网络是可靠的</li>
<li>其它异步系统模型所需的关于时间的假设<ul>
<li>各个进程行进的速率是独立的</li>
<li>没有上界</li>
<li>没有可用的时钟</li>
</ul>
</li>
</ul>
</li>
<li>结论<ul>
<li>即使在消息不会丢失，最多一个进程fail且只会fail by crashing的条件下，异步系统模型中也不存在能够解决共识问题(consensus problem)的确定性算法。</li>
<li>假设这样的算法存在，则总能设计出一种执行这种算法的方式，通过delaying message来让系统remain undecided(“bivalent”)</li>
<li>这个结论的重要意义是它强调了在异步系统模型的假设下（no uppder bound），设计解决共识问题的算法必须考虑一种折衷：要么放弃safety，要么放弃liveness。</li>
</ul>
</li>
</ul>
<h1 id="CAP-theorem"><a href="#CAP-theorem" class="headerlink" title="CAP theorem"></a>CAP theorem</h1><h2 id="三类属性"><a href="#三类属性" class="headerlink" title="三类属性"></a>三类属性</h2><ul>
<li>一致性Consistency：所有节点在同一时间都可以访问到同样的数据（see the same data）</li>
<li>可用性Availability：节点的failure不影响没有fail的节点继续工作</li>
<li>分区容错性Partition tolerance：即使出现了因为网络问题（Partition - communication break）导致的消息丢失，系统还是能继续工作</li>
<li>最多只有两种属性能够同时满足。（事实上，这并不是严格的“3选2”问题，某些时候属性之间存在tradeoff）<h2 id="三系统类型"><a href="#三系统类型" class="headerlink" title="三系统类型"></a>三系统类型</h2></li>
<li>CA：保证一致性可用性， <strong>full strict</strong> quorum protocols，例如two-phace commit（2PC）<ul>
<li>一种强一致性模型，无法区分节点不可用和网络问题，只能通过停止接收写操作来避免数据分歧</li>
<li>quorum protocol：基于鸽巢原理的算法，保证数据冗余和最终一致性<ul>
<li>分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：<ul>
<li>Vr + Vw &gt; V</li>
<li>Vw &gt; V/2</li>
</ul>
</li>
<li>第一条规则保证了一个数据不会被同时读写。当一个写操作请求过来的时候，它必须要获得Vw个冗余拷贝的许可。而剩下的数量是V-Vw 不够Vr，因此不能再有读请求过来了。同理，当读请求已经获得了Vr个冗余拷贝的许可时，写请求就无法获得许可了。</li>
<li>第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。</li>
</ul>
</li>
</ul>
</li>
<li>CP：保证一致性和分区容错性，majority quorum protocols，例如Paxos，Raft<ul>
<li>也是一种强一致性模型，通过对网络中断的两段实行不对称的行为来避免数据分歧。节点多的一侧可用，节点少的一侧不可用（属于哪种情况需要使用算法进行区分）。</li>
</ul>
</li>
<li>AP：使用冲突化解(conflit resolution)的协议</li>
</ul>
<h2 id="导出结论"><a href="#导出结论" class="headerlink" title="导出结论"></a>导出结论</h2><ul>
<li>应该积极考虑Partition Tolerance：“分布式系统必须保证分区容错性，基本上只能选择AP原则和CP原则”，“You can’t sacrifice partition tolerance”</li>
<li>因此并不存在”CA”类别，当network partition发生时，分布式系统要么保证一致性，要么保证可用性。</li>
<li>存在network partitions时，强一致性和高可用性存在冲突</li>
<li>在一般情况下，强一致性和性能存在冲突。要保证强一致性，各个节点要在每个操作上进行通信和协商，这会导致很高的latency</li>
</ul>
<h2 id="强一致性与弱一致性模型"><a href="#强一致性与弱一致性模型" class="headerlink" title="强一致性与弱一致性模型"></a>强一致性与弱一致性模型</h2><h3 id="强一致性模型"><a href="#强一致性模型" class="headerlink" title="强一致性模型"></a>强一致性模型</h3><ul>
<li>可线性化一致性：在可线性一致性的情况下，所有的操作似乎都按照与全局实时操作顺序一致的顺序原子地执行</li>
<li>顺序一致性：在顺序一致性的情况下，所有操作似乎都是按照某种顺序原子地执行的，这种顺序与在单个节点上看到的顺序一致，并且在所有节点上都是相等的。</li>
</ul>
<h3 id="弱一致性模型"><a href="#弱一致性模型" class="headerlink" title="弱一致性模型"></a>弱一致性模型</h3><ul>
<li>client-centric一致性模型：入了客户端或会话机制的一致性模型，保证客户不会访问到一个数据项的旧版本，通常可以在客户端增加额外的cache来实现</li>
<li>因果一致性模型</li>
<li>最终一致性模型：如果停止对数据的值进行修改，经过”一段待定义的时间”后所有数据的副本都会达成一致得到某个相同的值。在此之前，多个数据的副本可能在”某些为定义的行为中”存在不一致的现象。</li>
</ul>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><ul>
<li>DBMS相较于文件系统的意义在于<ul>
<li>基于关系代数，实现对数据的一种结构化存储和结构化查询</li>
<li>事务的支持 -&gt; ACID</li>
</ul>
</li>
</ul>
<h1 id="复制（Replication）"><a href="#复制（Replication）" class="headerlink" title="复制（Replication）"></a>复制（Replication）</h1><h2 id="复制的时机来分类"><a href="#复制的时机来分类" class="headerlink" title="复制的时机来分类"></a>复制的时机来分类</h2><h3 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h3><ul>
<li>请求 -&gt; 阻塞，将操作复制到所有节点 -&gt; 所有节点返回 -&gt; 向客户端返回</li>
<li>返回客户端之前状态变化会被系统中所有节点所知。</li>
<li>性能差，耐用性保证强。<h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3></li>
<li>请求 -&gt; 立即响应，将更新数据保存在本机 -&gt; 发送异步复制消息，联系其他节点 其他节点更新它们的副本</li>
<li>性能高，对网络延迟的容忍度高，耐用性保证差，如果某个修改在给客户端发送响应后，在成功复制到从节点之前丢失了，那这个修改就永远丢失了。</li>
<li>高可用性，但是单纯的lazy approach无法保证错误发生时能够读出之前写入的内容</li>
</ul>
<h2 id="按照副本一致性的强弱分类"><a href="#按照副本一致性的强弱分类" class="headerlink" title="按照副本一致性的强弱分类"></a>按照副本一致性的强弱分类</h2><h3 id="维护单一副本（prevent-divergence，single-copy）"><a href="#维护单一副本（prevent-divergence，single-copy）" class="headerlink" title="维护单一副本（prevent divergence，single copy）"></a>维护单一副本（prevent divergence，single copy）</h3><ul>
<li>尽可能地表现得像单一系统</li>
<li>保证只有一个活动副本</li>
<li>保证所有副本的一致性</li>
<li>例子：异步主从复制、同步主从复制、2PC、Multi-Paxos，3PC，Paxos with leader election<h3 id="multi-master-systems（risk-divergence）"><a href="#multi-master-systems（risk-divergence）" class="headerlink" title="multi-master systems（risk divergence）"></a>multi-master systems（risk divergence）</h3></li>
</ul>
<h2 id="常见的复制算法：主从复制"><a href="#常见的复制算法：主从复制" class="headerlink" title="常见的复制算法：主从复制"></a>常见的复制算法：主从复制</h2><ul>
<li>所有操作都在一个master server上进行，master server将所有操作序列化并形成local log，local log将被发送到所有backup server上形成replica</li>
<li>丢失修改的两种情况<ul>
<li>异步复制导致：没来得及同步完成时master宕机，新slave成为master，旧master即使恢复了也会变成slave，无法将修改复制到其他节点</li>
<li>脑裂：master和slave无法互相联系，联系不上master的slave选出了backup master，新旧master同时接收修改，导致丢失修改<ul>
<li>怎么解决？要求master必须与一定量的slave保持联系才可以接受写，否则拒绝写</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="主从复制下的一致性协议：2PC-2-Phase-Commit"><a href="#主从复制下的一致性协议：2PC-2-Phase-Commit" class="headerlink" title="主从复制下的一致性协议：2PC(2 Phase Commit)"></a>主从复制下的一致性协议：2PC(2 Phase Commit)</h3><ul>
<li>中心化的协议，需要单一的master/leader/coordinator角色</li>
<li>过程 vote -&gt; decision -&gt; commit</li>
<li>是一个CA算法，不保证Partition Tolerance</li>
</ul>
<h3 id="能实现partition-tolerance的共识算法"><a href="#能实现partition-tolerance的共识算法" class="headerlink" title="能实现partition tolerance的共识算法"></a>能实现partition tolerance的共识算法</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:37:36" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="5种IO模型"><a href="#5种IO模型" class="headerlink" title="5种IO模型"></a>5种IO模型</h1><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><h2 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h2><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><h1 id="Java-3种IO"><a href="#Java-3种IO" class="headerlink" title="Java 3种IO"></a>Java 3种IO</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">面经</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:37:37" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="腾讯csig智慧供应链："><a href="#腾讯csig智慧供应链：" class="headerlink" title="腾讯csig智慧供应链："></a>腾讯csig智慧供应链：</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM:"></a>JVM:</h2><ul>
<li>运行时内存模型√</li>
<li>垃圾回收机制：标记算法、回收算法√</li>
<li>类加载机制√</li>
<li>移动到老年代有哪几种情况√</li>
</ul>
<h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC:"></a>JUC:</h2><ul>
<li>线程池怎么实现的，底层有什么数据结构</li>
<li>synchronized的底层实现√</li>
<li>volatile是什么，跟synchronized的区别，volatile是不是锁√</li>
<li>CAS√</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络:"></a>网络:</h2><ul>
<li>浏览器中输入地址回车会发生什么√</li>
<li>TCP/IP协议栈有哪几层√</li>
</ul>
<h1 id="字节跳动："><a href="#字节跳动：" class="headerlink" title="字节跳动："></a>字节跳动：</h1><h2 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h2><ul>
<li>HashMap的实现√</li>
<li>接口跟抽象类的区别（Java 8， default关键字）√</li>
</ul>
<h2 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li>老年代的垃圾回收出现的时机是什么√</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>SQL语句</li>
<li>三大范式、BCNF范式√</li>
</ul>
<h2 id="手撕环节"><a href="#手撕环节" class="headerlink" title="手撕环节"></a>手撕环节</h2><ul>
<li>给定有n个元素一个数组，求和为x的所有可能性 Leetcode 40。（15:13-15:35, 总计用时22分钟)</li>
</ul>
<h1 id="东方财富"><a href="#东方财富" class="headerlink" title="东方财富"></a>东方财富</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>抽象 封装 继承 多态√</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>是什么？：解决一类问题的方式√</li>
<li>用过什么？√</li>
<li>UML?</li>
</ul>
<h2 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h2><ul>
<li>TCP和UDP的区别，优缺点√</li>
<li>ICMP：控制信息</li>
<li>TCP为什么要等2MSL√</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>进程间通信的方式√</li>
<li>线程间通信的方式<ul>
<li>共享内存</li>
</ul>
</li>
<li>IO的几种方式√</li>
<li>进程和线程的区别√</li>
<li>多线程和多进程的区别√</li>
<li>虚拟内存：交换分区√</li>
</ul>
<h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>ACID特性√</li>
<li>索引的数据结构√</li>
<li>怎么用的索引√</li>
<li>表锁和行锁√</li>
<li>内连接和外连接√</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>红黑树</li>
<li>字典树？</li>
</ul>
<h2 id="JVM-2"><a href="#JVM-2" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li>栈内存是什么</li>
<li>值传递 -&gt; 引用类型，引用的复制，引用的地址</li>
</ul>
<h2 id="Java-SE-1"><a href="#Java-SE-1" class="headerlink" title="Java SE"></a>Java SE</h2><ul>
<li>List、Set、Map</li>
<li>Java泛型</li>
<li>Java内存泄漏？</li>
<li>对象复制：浅拷贝、深拷贝</li>
<li>Java native关键字</li>
<li>反射</li>
<li>lambda表达式</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul>
<li>是什么</li>
<li>SpringMVC</li>
<li>Spring Bean</li>
</ul>
<h1 id=""><a href="#" class="headerlink" title="?"></a>?</h1><h2 id="Java-SE-2"><a href="#Java-SE-2" class="headerlink" title="Java SE"></a>Java SE</h2><ul>
<li>多态</li>
<li>重载和重写</li>
<li>静态代码块(<code>static</code>)</li>
<li>静态内部类</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>线程池的原理</li>
<li>什么时候新建线程（最大线程数）</li>
<li>线程状态转换</li>
<li>进程中断发生了什么</li>
<li>不响应中断？<ul>
<li>什么时候线程不会响应中断?</li>
</ul>
</li>
<li>Lock和Synchronized的区别</li>
<li>Lock的实现原理</li>
<li>volatile了解吗<ul>
<li>做了什么（原理？）</li>
<li>防止指令重排</li>
<li>volatile读：需要读取内存</li>
<li>volatile写：刷新到内存</li>
</ul>
</li>
</ul>
<h2 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>策略模式</li>
</ul>
<h2 id="JVM-3"><a href="#JVM-3" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li>运行时内存模型</li>
<li>堆里有什么</li>
<li>CMS</li>
<li>JVM调优参数</li>
<li>堆转储</li>
<li>Full GC（Major GC）的发生时机</li>
</ul>
<h2 id="数据库-2"><a href="#数据库-2" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>索引数据结构<ul>
<li>B+树的数据结构</li>
</ul>
</li>
<li>索引失效？<ul>
<li>复合索引</li>
</ul>
</li>
<li>事务默认隔离级别<ul>
<li>默认隔离级别</li>
<li>可重复读</li>
</ul>
</li>
<li>MVCC <ul>
<li>隐藏字段：隐藏主键，上一版本，时间戳</li>
</ul>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis?"></a>Redis?</h2><ul>
<li>如何实现分布式锁</li>
</ul>
<h2 id="网络-2"><a href="#网络-2" class="headerlink" title="网络"></a>网络</h2><ul>
<li>HTTP状态码</li>
<li>TCP<ul>
<li>TIME_WAIT</li>
<li>CLOSE_WAIT</li>
</ul>
</li>
</ul>
<h1 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h1><ul>
<li>SpringAOP<ul>
<li>实现接口：JDK、不实现接口：CGLIB</li>
</ul>
</li>
<li>Bean生命周期<ul>
<li>Aware接口</li>
</ul>
</li>
</ul>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><ul>
<li>自动装配的原理</li>
</ul>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:37:35" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="TLA-ToolBox"><a href="#TLA-ToolBox" class="headerlink" title="TLA+ ToolBox"></a>TLA+ ToolBox</h1><h2 id="项目总述"><a href="#项目总述" class="headerlink" title="项目总述"></a>项目总述</h2><ul>
<li>TLA+：TLA意为行为时序逻辑，TLA+则是一种形式化语言，以行为时序逻辑的方式对软件程序、算法或者协议进行高层次的建模，描述系统的行为，帮助开发人员对程序和算法有更清楚的认识，在系统设计阶段避免一些可能出现的错误。（对代码进行测试是一种发现编码错误的手段，但不是一种高效的对系统设计进行检查的手段）</li>
<li>TLA+的做法是使用基于状态的方式来描述系统的行为。用对所有状态变量的一次赋值来表示一个系统的全局状态。用状态转移前后状态变量的关系来表现所有可能出现的状态变化。于是系统的可能行为集合就可以被分为两个部分：所有可能的初始状态和所有可能的状态转移方式。</li>
<li>TLA+ Toolbox是形式化语言TLA+的集成开发环境，其中包括了模型检查器TLC。用户使用TLA+对系统建立的模型包括了系统的初始状态和所有可能的状态转换，实际上建立了整个系统的状态图。模型检查器TLC可以遍历用户系统对应的状态图，检查每个状态是否能够满足用户定义的一些约束，以此来帮助用户发现系统模型的潜在问题。</li>
<li>个人负责的工作：提供TLC的运行时API，用户使用这些API可以在TLC运行时获取他们关心的一些状态信息，例如当前已经检查的模型深度和当前正在检查的状态。用户还可以使用这些API对运行中的TLC进行一些操作，例如让计算任务暂停，为当前任务创建检查点以便恢复执行等。这些API计划使用JMX进行提供。同时开发云计算功能模块：用户提供云服务提供商的token，TLC可以自动地使用云服务提供商的SDK创建云实例，将TLC主程序和用户编写的模型打包上传到云实例，在云实例上执行计算任务，并在计算任务完成时自动给用户发送邮件并关闭云实例。</li>
</ul>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul>
<li>…</li>
</ul>
<h2 id="TLA-可以举个例子吗"><a href="#TLA-可以举个例子吗" class="headerlink" title="TLA+可以举个例子吗"></a>TLA+可以举个例子吗</h2><ul>
<li>TLA+ 比较常用的地方是用于精确地对并发系统或分布式算法进行建模<h3 id="2PC协议的TLA实现"><a href="#2PC协议的TLA实现" class="headerlink" title="2PC协议的TLA实现"></a>2PC协议的TLA实现</h3></li>
</ul>
<h2 id="JMX？"><a href="#JMX？" class="headerlink" title="JMX？"></a>JMX？</h2><ul>
<li>定义符合JMX规范的Java对象<code>MBean</code>，将其注册到Java内置的MBean服务器中让MBean服务器对其进行管理，即可暴露一些当前应用的运行时信息，提供一些可读写的字段，提供一些可以在运行时执行的操作。</li>
<li>定义<code>MBean</code>一般是先定义一个<code>XXXMBean</code>接口，在接口中说明所有可以访问的属性和所有可以执行的方法，然后定义<code>XXXMBean</code>的实现类<code>XXX</code>，在实现类中提供实际的数据访问、执行实际的操作。</li>
<li>MBean的名称规范(<code>ObjectName</code>): 至少要包括一个域(domain)和一系列的键值对。Domain一般可以使用包名。</li>
<li>MXBean: 只会包含预定义的数据类型，因此任何客户端（包括远程客户端）都可以使用，而不需要引用特定的自定义类型。MXBean接口不要求实现类名与接口名有对应关系。</li>
<li>如果要在MXBean里使用复杂类型，复杂类型的数据会被映射为简单类型。</li>
</ul>
<h2 id="项目实现细节"><a href="#项目实现细节" class="headerlink" title="项目实现细节"></a>项目实现细节</h2><h3 id="模型检查器的基本原理"><a href="#模型检查器的基本原理" class="headerlink" title="模型检查器的基本原理"></a>模型检查器的基本原理</h3><ul>
<li>本质上，用户所编写的模型规定了系统的初始状态和所有可能的状态转换，相当于定义了一个状态图。模型检查器的原理大致是对这个状态图进行广度优先遍历，并检查每个状态是否出现不满足Safety属性。为了实现广度优先遍历，TLC需要维护2个数据结构：一个记录所有已经检查过的状态的集合，一个用于实现广度优先遍历的队列。TLC可以开启多个worker线程，worker线程对已检查过的状态集和状态队列的独写使用<code>ReadWriteLock</code>来保证线程安全。</li>
</ul>
<h3 id="集合怎么实现"><a href="#集合怎么实现" class="headerlink" title="集合怎么实现?"></a>集合怎么实现?</h3><h3 id="队列怎么实现"><a href="#队列怎么实现" class="headerlink" title="队列怎么实现?"></a>队列怎么实现?</h3><ul>
<li>队列实现为一个硬盘上的文件，开头和结尾保留一定量的元素在内存中。使用了专有的线程对队列开头和结尾的缓冲区进行预载。</li>
</ul>
<h3 id="提供什么运行时API"><a href="#提供什么运行时API" class="headerlink" title="提供什么运行时API?"></a>提供什么运行时API?</h3><ul>
<li>启动与暂停：<ul>
<li>暂停：设置队列的标志变量<code>stop</code>，worker线程调用入队列或出队列的方法使用<code>synchornized</code>关键字修饰，调用时必须检查标志变量的值，如果发现<code>stop = true</code>则会调用<code>wait</code>方法让自己挂起。</li>
<li>重启：修改<code>stop</code>为<code>false</code>，并且调用<code>notifyAll</code>唤醒所有在队列上等待的线程</li>
</ul>
</li>
<li>单步调试：<ul>
<li>使用模型检查器的内部类解析用户编写的模型，生成所有的初始状态，让用户自行挑选下一状态并单步观察状态的变化。</li>
</ul>
</li>
</ul>
<h3 id="云计算模块的基本原理"><a href="#云计算模块的基本原理" class="headerlink" title="云计算模块的基本原理"></a>云计算模块的基本原理</h3><ul>
<li>让用户选择云服务的提供商并设置必要的认证凭据（ID, SECRET），云计算模块负责自动创建特定规格的实例，并通过SSH连接到云实例上，完成云实例的准备并下载运行所需要的依赖（例如JDK）。同时云计算模块会负责将用户在本地创建的模型文件与模型检查器的可执行jar文件打包上传到云实例上。模型检查器执行完毕后首先将执行结果的输出文件使用邮件发送到用户提供的邮件地址。</li>
<li>主要负责为该模块添加阿里云支持，项目原本使用了jclouds屏蔽不同云服务提供商的接口差异，但是jclouds并未在正式版中提供阿里云支持，因此计划是尝试将阿里云的SDK进行包装和适配，尽可能地复用原有的代码。</li>
<li>怎么发送邮件<ul>
<li>让用户提供邮件地址，可以通过邮件地址的<code>@</code>后的域名查询邮件地址对应的SMTP服务器域名。DNS服务器会返回对应的MX记录</li>
<li>至于怎么知道哪台服务器才存放这个MX记录，我觉得只需要和查找A记录一样，先找到<code>@</code>后的域名所在的服务器就可以找到对应的MX记录了。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Freeman Huang</p>
  <div class="site-description" itemprop="description">Self-talking of a noob</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Freeman Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
