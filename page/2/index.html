<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Self-talking of a noob">
<meta property="og:type" content="website">
<meta property="og:title" content="Freeman&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Freeman&#39;s Blog">
<meta property="og:description" content="Self-talking of a noob">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Freeman Huang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Freeman's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Freeman's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个菜鸡心血来潮搭建的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:33:42" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<ul>
<li>[] MVCC彻底理解清楚</li>
<li>[] 分库分表</li>
<li>[] MySQL Cluster在CAP中的定位</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="3大范式是什么"><a href="#3大范式是什么" class="headerlink" title="3大范式是什么"></a>3大范式是什么</h2><ul>
<li>函数依赖：对于X, Y, 如果不存在关系，使得X上的属性值相等而Y的属性值不等，称Y函数依赖于X。此时X称为决定因素。</li>
<li>完全函数依赖：对于X的任何一个真子集X’，都不满足X’ -&gt; Y，说明Y完全函数依赖与X</li>
<li>部分函数依赖：如果存在X的真子集X’，满足X’-&gt;Y，说明Y对X部分函数依赖</li>
<li>如果X-&gt;Y, Y不属于X（防止Y-&gt;X）, Y -&gt; Z, Z不属于Y（防止Z-&gt;Y），称Z对X传递函数依赖。</li>
<li>码：如果K -F-&gt; U（完全函数确定），K是R的候选码。</li>
<li>1NF: 关系模式中的每一个分量是不可分的数据项</li>
<li>2NF: 如果某个关系满足1NF，并且任何一个非主属性都完全函数依赖于任何一个候选码，则该关系模式满足2NF</li>
<li>3NF: 如果任何一个非主属性既不部分依赖于码，也不传递依赖于码，说明该关系模式满足3NF</li>
<li>BCNF: 如果每一个决定因素都包含码，说明该关系模式满足BCNF</li>
</ul>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h1 id="MyISAM-vs-InnoDB"><a href="#MyISAM-vs-InnoDB" class="headerlink" title="MyISAM vs InnoDB"></a>MyISAM vs InnoDB</h1><ul>
<li>是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
<li>是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li>MyISAM不支持外键，InnoDB支持外键</li>
<li>是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h2><ul>
<li>创建唯一性索引可以保证每行数据的唯一性</li>
<li>加快数据检索速度</li>
<li>帮助服务器避免排序和临时表（？）</li>
<li>将随机IO变为顺序IO</li>
<li>加速表之间的连接<h2 id="为什么不为每一个列创建索引"><a href="#为什么不为每一个列创建索引" class="headerlink" title="为什么不为每一个列创建索引"></a>为什么不为每一个列创建索引</h2></li>
<li>索引需要维护，加入索引会降低对数据更新的速度</li>
<li>索引要占据物理空间</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>在经常需要搜索的列上，可以加快搜索的速度；</p>
</li>
<li><p>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p>
</li>
<li><p>在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p>
</li>
<li><p>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</p>
</li>
<li><p>在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；</p>
</li>
<li><p>避免 where 子句中对字段施加函数，这会造成无法命中索引。</p>
</li>
<li><p>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</p>
</li>
<li><p>单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用，以提升效率。</p>
</li>
<li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序 I/O 不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。</li>
<li>索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就 不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访 问是很慢的。</li>
</ul>
<h2 id="BTree索引"><a href="#BTree索引" class="headerlink" title="BTree索引"></a>BTree索引</h2><ul>
<li>数据结构：B+树<h3 id="B树-vs-B-树"><a href="#B树-vs-B-树" class="headerlink" title="B树 vs B+树"></a>B树 vs B+树</h3></li>
<li>B树的所有节点既存放key也存放data，但B+树只有叶子节点存放key和data，其它节点只存放key</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程。<h3 id="MyISAM实现"><a href="#MyISAM实现" class="headerlink" title="MyISAM实现"></a>MyISAM实现</h3></li>
<li>非聚簇索引，在索引数据结构（叶子节点的data域）上存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</li>
<li>MyISAM使用前缀压缩以减少索引，可以让更多的索引进入内存以减少磁盘IO的时间。MyISAM压缩索引库的方法是完全保存索引块中的第一个值，后续的值只保存和第一个值相同前缀的字节数和后续的不同部分。这样每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描，这会影响某些操作的性能，例如倒序扫描。</li>
<li>硬要说的话适合<code>UPDATE</code>密集的表<h3 id="InnoDB实现"><a href="#InnoDB实现" class="headerlink" title="InnoDB实现"></a>InnoDB实现</h3></li>
<li>聚簇索引，表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。其它的索引都作为辅助索引，辅助索引的data域保存的是主键的值而不是地址。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</li>
<li>MyISAM索引按照行存储的物理位置引用被索引的行，但是InnoDB按照主键值引用行。如果使用DML对表中数据进行操作（插入、删除、修改…），行的存储位置可能会发生变化，如果使用主键值引用行，此时就不需要对索引进行更新。</li>
</ul>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><ul>
<li>数据结构：哈希表</li>
<li>对于哈希索引来说，底层的数据结构就是哈希表，因此在<strong>绝大多数需求为单条记录查询</strong>的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。哈希索引无法支持范围查询和顺序查询。</li>
</ul>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。<br><strong>问题</strong>：对于<code>(a, b, c)</code>上的联合索引，对于条件<code>where a = &#39;xx&#39; and c = &#39;yy&#39;</code>，是否可以利用索引？<br><strong>问题</strong>：MySQL 8.0还需要遵守最左匹配原则吗？</p>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><ul>
<li>事务是逻辑上的一组操作，要么都执行，要么都不执行。</li>
<li>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性（Consistency）： 执行事务后，数据库从一个正确的状态变化到另一个正确的状态；</li>
<li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><ul>
<li>脏读（Dirty read）：事务修改了数据但是还没有将修改提交到数据库中，另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没来得及提交的旧数据，读取的事务读到的是脏数据，根据这样的脏数据做的操作可能是不正确的</li>
<li>丢失修改（Lost to modify）：两个事务同时读取一个数据，并同时修改这个数据。第一个事务修改了这个数据后第二个事务也修改了这个数据，导致第一个事务的修改被丢失。</li>
<li>不可重复读（Unrepeatableread）：在一个事务内多次读同一数据。在这个事务还没结束时另一个事务也访问这个数据，并且可能对这个数据进行修改。这样，一个事务内的多次读取到的同一数据的值可能不一样，这种情况称为不可重复读</li>
<li>幻读（Phantom read）：在一个事务内用相同的条件查询多次数据，在这个事务查询一次数据之后，另一个并发的事务插入或删除了一些数据，因此事务后续用相同的条件进行查询时结果集会发生变化。</li>
</ul>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul>
<li>READ-UNCOMMITTED（读取未提交）：最低的隔离级别，允许读取尚未提交的数据变更。可能会导致脏读、幻读、不可重复读。</li>
<li>READ-COMMITTED（读取已提交）：允许读取并发事务已经提交的数据，可以阻止脏读，但是无法阻止幻读和不可重复读。</li>
<li>REPEATABLE-READ（可重复读）：默认的隔离级别。一个事务内对同一字段的多次读取结果是一致的，除非数据本身已经被事务自己改变。可以阻止脏读和不可重复读，但是仍然可能发生<strong>幻读</strong>。</li>
<li>SERIALIZABLE（可串行化）：最高的隔离级别，分布式事务的情况下一般使用可串行化的隔离级别，完全满足ACID性质，所有的事务依次逐个执行，互不干扰。可以防止脏读、不可重复读和幻读。</li>
</ul>
<h1 id="MySQL-锁机制"><a href="#MySQL-锁机制" class="headerlink" title="MySQL 锁机制"></a>MySQL 锁机制</h1><h2 id="按照锁的粒度分类"><a href="#按照锁的粒度分类" class="headerlink" title="按照锁的粒度分类"></a>按照锁的粒度分类</h2><ul>
<li>表级锁：对整张表加锁，实现简单，消耗资源少，加锁快，不会出现死锁，粒度最大，并发度最低。</li>
<li>行级锁：粒度最小的锁，减少数据库操作的锁冲突，并发度高，但加锁开销大，加锁慢，可能出现死锁。</li>
</ul>
<h2 id="共享-排他锁"><a href="#共享-排他锁" class="headerlink" title="共享/排他锁"></a>共享/排他锁</h2><ul>
<li>S锁：可以是行级也可以是表级</li>
<li>X锁：可以实行级也可以是表级</li>
<li>IS锁：表级</li>
<li>IX锁：表级</li>
</ul>
<h2 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h2><h3 id="记录锁-Record-locks"><a href="#记录锁-Record-locks" class="headerlink" title="记录锁(Record locks)"></a>记录锁(Record locks)</h3><ul>
<li>记录锁是施加在索引记录上的锁。（是指主索引吗？）</li>
<li>记录锁永远只会对索引记录施加，即使表没有定义任何索引。在这种情况下，InnoDB会创建一个隐藏的聚簇索引，用该索引实现记录锁。</li>
</ul>
<h3 id="间隙锁-Gap-locks-lt"><a href="#间隙锁-Gap-locks-lt" class="headerlink" title="间隙锁(Gap locks) &lt;- ?"></a>间隙锁(Gap locks) &lt;- ?</h3><ul>
<li>间隙锁是施加在索引记录之间间隙、在第一个索引记录之前和最后一个索引记录之后的锁。例如查询<br><code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE</code>会阻止其他事务插入一个<code>t.c1 = 15</code>的行，因为在这个范围内的间隙都已被加锁。（一个间隙指的是一个区间）</li>
<li>间隙锁是性能和并发性之间权衡的一部分，在某些事务隔离级别中使用（目测是为了防止幻读），而在其他级别中则不使用。</li>
<li>当使用唯一索引搜索唯一行时，不需要使用间隙锁。但是使用多列唯一索引的部分列进行搜索时，间隙锁会发生作用。</li>
<li>不同事务可以持有互相冲突的间隙锁。</li>
<li>InnoDB中的间隙锁是纯禁止性的，间隙锁的唯一目的就是防止其它事务向间隙中插入数据。</li>
</ul>
<h3 id="邻键锁-Next-Key-locks-lt"><a href="#邻键锁-Next-Key-locks-lt" class="headerlink" title="邻键锁(Next-Key locks) &lt;- ?"></a>邻键锁(Next-Key locks) &lt;- ?</h3><ul>
<li>邻键锁是记录锁和在索引记录之前的间隙锁的结合（a combination of a record lock on the index record and a gap lock on the gap before the index record）。</li>
<li>InnoDB是这样实现行级锁的：当搜索或扫描表的索引时，InnoDB在它遇到的索引记录上施加共享锁或排他锁。因此行级锁实际上是索引记录锁。</li>
<li>邻键锁对索引记录加锁，同时对索引记录之前的(一个)间隙加锁。</li>
<li>在<code>REPEATABLE_READ</code>事务隔离级别下，InnoDB使用邻键锁来进行搜索和索引扫描，避免<strong>幻读</strong>的出现(-&gt;因此REPEATABLE_READ隔离级别不存在幻读问题？</li>
</ul>
<h3 id="插入意向锁-Insert-Intension-locks"><a href="#插入意向锁-Insert-Intension-locks" class="headerlink" title="插入意向锁(Insert Intension locks)"></a>插入意向锁(Insert Intension locks)</h3><ul>
<li>插入意图锁是一种间隙锁，是由<code>INSERT</code>操作在行插入之前设置的。该锁表明插入数据的意向，多个事务向同一个间隙(区间)插入数据时，如果他们插入的位置不同，则不需要互相等待。</li>
</ul>
<h3 id="自增锁-AUTO-INC-locks"><a href="#自增锁-AUTO-INC-locks" class="headerlink" title="自增锁(AUTO-INC locks)"></a>自增锁(AUTO-INC locks)</h3><ul>
<li>自增锁是一种特殊的表级锁，当事务需要向包含<code>AUTO_INCREMENT</code>列的表插入数据时自增锁会发挥作用。如果一个事务正在向表中插入数据，另一个需要插入数据的事务必须等待，这样插入表中的行才能有连续的自增主键。</li>
<li>通过更改<code>innodb_autoinc_lock_mode</code>配置项可以选择用于自增锁的算法，更改该选项用户可以自由地在自增值的可预测性和插入操作的并发性之间进行权衡取舍。</li>
</ul>
<h1 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h1><h2 id="限定数据范围，禁止不带任何限制范围条件的查询语句"><a href="#限定数据范围，禁止不带任何限制范围条件的查询语句" class="headerlink" title="限定数据范围，禁止不带任何限制范围条件的查询语句"></a>限定数据范围，禁止不带任何限制范围条件的查询语句</h2><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主库写、从库读</p>
<h2 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h2><p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。<br>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。<br>优点：列数据变小，减少读取的block数，减少IO次数，简化表的结构，易于维护。<br>缺点：主键冗余，增加join操作，让事务变得更复杂。</p>
<h2 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h2><p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中（比如，按时间区间水平分区，按ID水平分区），达到了分布式的目的。 水平拆分可以支撑非常大的数据量。<br>分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分<strong>最好分库</strong> 。<br>水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。</p>
<ul>
<li>分片的常见方案:<ul>
<li>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或封装JDBC层来实现。（？）</li>
<li>中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。（？）<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2></li>
</ul>
</li>
<li>使用慢查询日志找出较慢的SQL</li>
<li>不做列运算：<code>SELECT id WHERE age + 1 = 10</code>，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</li>
<li>对列进行函数操作可能会导致无法使用索引 -&gt; 函数索引。隐式类型转换也会导致索引失效。</li>
<li>尽量不用<code>SELECT *</code>，而是显式指定需要的列</li>
<li>不用函数和触发器，在应用程序实现（？）</li>
<li>少用JOIN</li>
<li>尽量避免在<code>WHERE</code>中使用<code>!=</code>, <code>&lt;&gt;</code>, 这类条件无法利用索引，而只能使用全表扫描。</li>
</ul>
<h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><ul>
<li>频繁的查询优先考虑使用覆盖索引（包含了所查询字段的索引），这样可以必满InnoDB表进行索引的二次查询。<ul>
<li>例如，要通过某个建立了二级索引的列<code>A</code>上的条件查询列<code>B</code>的值，如果只使用<code>A</code>上的索引，由于该索引的叶子节点只保存了主键的值，因此此时需要回表，即在主键索引上再次进行查找，才能找到对应行的<code>B</code>的值。如果在<code>A</code>和<code>B</code>上建立一个联合索引，在叶子节点处就会存在<code>B</code>列的值，不需要进行回表。</li>
</ul>
</li>
<li>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</li>
</ul>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><ul>
<li>严禁左模糊（例如，<code>a like &#39;%123&#39;</code>。形如<code>a like &#39;123%&#39;</code>，即左侧具体的条件，是可以使用列上的索引的）或者全模糊，有这种需求的时候需要使用搜索引擎。B树索引有最左前缀匹配的特性，最左边的值不确定时无法使用。</li>
</ul>
<h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><ul>
<li>对于外键和级联的一种好的方式是在应用层实现。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风 险;外键影响数据库的插入速度。并且分库分表的情况下数据库级别的外键也无法生效。</li>
<li>外键也有一定的好处：在DB层面就保证了数据的一致性和完整性，并且由数据库自动完成级联操作也可以减少代码量。</li>
<li>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</li>
</ul>
<h1 id="池化（数据库连接池）"><a href="#池化（数据库连接池）" class="headerlink" title="池化（数据库连接池）"></a>池化（数据库连接池）</h1><p>建立连接是需要消耗时间的，如果有较多的任务陆续提交而不进行任何特殊处理，就需要重复建立连接-关闭连接的过程，浪费时间。因此池化技术的思想就是复用这些创建的连接。（数据库连接的本质可以视为一个socket连接）。</p>
<h1 id="SQL语句的执行过程"><a href="#SQL语句的执行过程" class="headerlink" title="SQL语句的执行过程"></a>SQL语句的执行过程</h1><h2 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h2><ul>
<li>Server层<ul>
<li>连接器： 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li>查询缓存:  执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。</li>
<li>分析器:  没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。词法分析提取关键字，语法分析校验SQL语法是否正确。</li>
<li>优化器： 按照 MySQL 认为最优的方案，生成查询计划去执行。 比如决定如何选择索引。</li>
<li>执行器:  执行语句，然后从存储引擎返回数据。执行器在执行前会首先检查用户有没有权限。</li>
</ul>
</li>
<li>存储引擎：InnoDB包括Redolog模块</li>
</ul>
<h2 id="更新语句的执行流程"><a href="#更新语句的执行流程" class="headerlink" title="更新语句的执行流程"></a>更新语句的执行流程</h2><p>执行更新语句时要记录日志。MySQL使用binlog进行日志记录，InnoDB还自带一个日志模块redo log。</p>
<ol>
<li>拿到待修改的数据，进行修改，然后调用引擎API接口写入修改后的数据。InnoDB会将数据保存在内存中，同时记录Redo log，此时redo log进入prepare状态，然后告诉执行器执行完成，随时可以提交。</li>
<li>执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为提交状态。</li>
<li>更新完成。</li>
</ol>
<ul>
<li><p>为什么要用两个日志模块？</p>
<ul>
<li>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</li>
</ul>
</li>
<li><p>为什么要先让redo log进入prepare状态，然后记录binlog，最后commit redo log？</p>
<ul>
<li>先写 redo log 直接提交，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li>先写 binlog，然后写 redo log，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。<br>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</li>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。<br>这样就解决了数据一致性的问题。</li>
</ul>
</li>
</ul>
<h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><ul>
<li>binlog：二进制日志</li>
<li>redo log、undo log：事务日志<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2>binlog 用于记录数据库执行的<strong>写入性操作</strong>(不包括查询)信息，以二进制的形式保存在磁盘中。 binlog 是 mysql的<strong>逻辑日志</strong>，并且由 Server 层进行记录，使用任何存储引擎的 mysql 数据库都会记录 binlog 日志。</li>
<li>逻辑日志： 可以简单理解为记录的就是sql语句 。</li>
<li>物理日志： mysql 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>主从复制 ：在 Master 端开启 binlog ，然后将 binlog 发送到各个 Slave 端， Slave 端重放 binlog 从而达到主从数据一致。</li>
<li>数据恢复 ：通过使用 mysqlbinlog 工具来恢复数据。</li>
</ul>
<h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p>对于 InnoDB 存储引擎而言，只有在事务提交时才会记录 binlog ，此时记录还在内存中。mysql 通过 sync_binlog 参数控制 biglog 的刷盘时机，取值范围是 0-N：</p>
<ul>
<li>0：不去强制要求，由系统自行判断何时写入磁盘；</li>
<li>1（默认）：每次 commit 的时候都要将 binlog 写入磁盘；</li>
<li>N：每N个事务，才会将 binlog 写入磁盘。</li>
</ul>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>事务的持久性：只要提交成功，对数据库的修改就要永久保存。<br>内存与硬盘数据的一致性如何保证？最简单的方法是每次事务提交的时候就把涉及到的数据页全部刷写到磁盘中。可能每次事务只会改一个页里的几个字节，却要把整个页完整地刷新到磁盘（InnoDB以页为单位与磁盘交互），而且一个事务可能涉及多个数据页，这样性能太差。</p>
<ul>
<li>redo log：记录事务对数据页做了哪些修改。<br>redo log 包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo logfile)。 mysql 每执行一条 DML 语句，先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到 redo log file 。这种 先写日志，再写磁盘 的技术就是 MySQL里经常说到的 WAL(Write-Ahead Logging) 技术。</li>
<li>redo log记录数据页的变更（物理日志？）redo log采用大小固定、循环写入的方式，到达结尾时会回到开头循环写日志。日志上的记录在数据落盘后会被覆盖掉。（可以看出redo log和binlog的一些区别）</li>
</ul>
<p>binlog 和redo log的区别？<br><img src="./pics/binlog-vs-redolog.png" alt="BinlogVSRedolog"></p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>数据库事务四大特性中有一个是 原子性 ，具体来说就是 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。实际上， 原子性 底层就是通过 undo log 实现的。 undo log 主要记录了数据的逻辑变化，比如一条INSERT语句，对应一条 DELETE 的 undo log ，对于每个UPDATE 语句，对应一条相反的 UPDATE 的undo log ，这样在发生错误时，就能回滚到事务之前的数据状态。同时， undo log 也是 MVCC(多版本并发控制)实现的关键。</p>
<h1 id="MVCC（多版本并发控制）"><a href="#MVCC（多版本并发控制）" class="headerlink" title="MVCC（多版本并发控制）"></a>MVCC（多版本并发控制）</h1><ul>
<li>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。</li>
<li>只在<code>READ COMMITTED</code>和<code>READ REPEATABLE</code>隔离级别下工作。因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。<h2 id="MVCC在InnoDB中的实现"><a href="#MVCC在InnoDB中的实现" class="headerlink" title="MVCC在InnoDB中的实现"></a>MVCC在InnoDB中的实现</h2>在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：<br>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。<br>INSERT时，保存当前事务版本号为行的创建版本号<br>DELETE时，保存当前事务版本号为行的删除版本号<br>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:34:23" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<p>TODOS</p>
<ul>
<li>[] Redis分布式锁</li>
</ul>
<h1 id="5大数据类型"><a href="#5大数据类型" class="headerlink" title="5大数据类型"></a>5大数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li>分布式锁<ul>
<li>set if not exists: <code>setnx key value</code></li>
<li><code>set key value [EX seconds] [PX milliseconds] [NX|XX]</code><ul>
<li>ex: 几秒后过期</li>
<li>px：几毫秒后过期</li>
<li>NX：不存在的时候创建key</li>
<li>XX：存在的时候覆盖key</li>
</ul>
</li>
</ul>
</li>
<li>需要计数的场景</li>
<li>商品编号、订单号，使用<code>INCR</code>生成</li>
<li>赞/踩<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2></li>
<li>有序有重复/可以左右加入</li>
<li><code>lpush</code></li>
<li><code>lrange</code>： 分页查询</li>
<li>（离线的）消息推送。</li>
<li>消息队列、慢查询<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2></li>
<li><code>hset</code>/<code>hmset</code></li>
<li><code>hget</code>/<code>hmget</code></li>
<li>对象存储</li>
<li>也可以实现分布式锁 -&gt; 可重入锁<ul>
<li>记录过期时间和释放次数</li>
</ul>
</li>
<li>购物车？<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2></li>
<li>无序无重复</li>
<li>删除/加入/判重</li>
<li>随机弹x个（删/不删）</li>
<li>集合运算：差/交/并</li>
<li>场景<ul>
<li>数据不能重复，需要进行集合操作</li>
<li>抽奖：参与<code>sadd</code>，显示参与<code>scard</code>，抽取<code>srandmember</code>/<code>spop</code></li>
<li>点赞</li>
<li>社交关系</li>
<li>可能认识的人<h2 id="zset-Sorted-set"><a href="#zset-Sorted-set" class="headerlink" title="zset(Sorted set)"></a>zset(Sorted set)</h2></li>
</ul>
</li>
<li><strong>有序</strong>无重复</li>
<li>需要根据权重进行排序的情况。</li>
<li>在线用户列表、排行榜、弹幕…<h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2></li>
<li>用一个bit位来表示某个元素对应的值或者状态。key就是对应元素本身。-&gt; 节省存储空间</li>
<li>用户签到：offset = day % 365，key = 年份#用户ID</li>
<li>统计活跃用户？<code>BITOP [AND | OR | NOT | XOR]</code></li>
<li>用户在线状态：用户ID为offset<h2 id="hyperloglogs"><a href="#hyperloglogs" class="headerlink" title="hyperloglogs"></a>hyperloglogs</h2><h2 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h2><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2></li>
</ul>
<h1 id="Redis为什么单线程，又为什么开始使用多线程"><a href="#Redis为什么单线程，又为什么开始使用多线程" class="headerlink" title="Redis为什么单线程，又为什么开始使用多线程"></a>Redis为什么单线程，又为什么开始使用多线程</h1><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><ul>
<li>IO多路复用 + Reactor模式<ul>
<li>单线程带来更好的可维护性，方便开发调试</li>
<li>单线程也能够并发。</li>
<li>绝大多数操作的性能瓶颈不是CPU<ul>
<li>简单总结一下，Redis 并不是 CPU 密集型的服务，如果不开启 AOF 备份，所有 Redis 的操作都会在内存中完成不会涉及任何的 I/O 操作，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I/O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案。</li>
</ul>
</li>
<li>减少线程创建和切换的开销</li>
<li>不需要同步机制，可以保障<strong>单次操作</strong>的原子性</li>
</ul>
</li>
</ul>
<h2 id="为什么引入多线程模型"><a href="#为什么引入多线程模型" class="headerlink" title="为什么引入多线程模型"></a>为什么引入多线程模型</h2><ul>
<li>如果某个任务特别大，单次任务可能要消耗较多的时间，这些操作会阻塞待处理的任务。</li>
<li>删除超大键值对：<code>UNLINK</code>，将key从元数据中删除，开启新线程在后台执行释放内存空间的工作。</li>
<li>接受数据包并解析Redis命令，发送返回数据包：这些过程可以引入多线程进行并发处理。</li>
</ul>
<h1 id="Redis如何判断数据过期、删除策略、内存淘汰机制"><a href="#Redis如何判断数据过期、删除策略、内存淘汰机制" class="headerlink" title="Redis如何判断数据过期、删除策略、内存淘汰机制"></a>Redis如何判断数据过期、删除策略、内存淘汰机制</h1><h2 id="Redis判断数据过期"><a href="#Redis判断数据过期" class="headerlink" title="Redis判断数据过期"></a>Redis判断数据过期</h2><p>过期字典：key就是数据库中的key，value是时间戳</p>
<h2 id="Redis过期删除策略"><a href="#Redis过期删除策略" class="headerlink" title="Redis过期删除策略"></a>Redis过期删除策略</h2><ul>
<li>惰性删除：只有在取出key的时候对数据进行过期检查。对CPU友好，但可能会造成过期key太多。</li>
<li>定期删除：隔一段时间抽取一批key执行删除过期key操作。执行时长和执行频率会对CPU时间造成影响。</li>
<li>定期删除+惰性删除：每隔一段时间进行检查，但是控制请求的时间和范围，只对key进行随机抽检。然后在取出某个key的时候进行检查，如果过期则删除。<ul>
<li>即使使用这种策略，如果定期删除没有删除完全/没有对key进行请求/没有设置过期时间，redis的内存占用会越来越高，此时需要采用内存淘汰机制。</li>
</ul>
</li>
</ul>
<h2 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h2><ul>
<li><code>redis.conf</code>中：<code>maxmemory-policy [policy name]</code></li>
<li>volatile-lru：从设置了过期时间的数据集里进行LRU，只有在将redis既作为持久存储又作为缓存的时候才使用。</li>
<li>volatile-ttl：从设置了过期时间的数据级中选择即将过期的数据进行淘汰</li>
<li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰</li>
<li>allkeys-lru: 当内存不足以容纳新数据时对键空间中所有的key进行lru</li>
<li>allkeys-random：从数据集中任意选择数据淘汰</li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>volatile-lfu（least frequently used）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><ul>
<li>1.重启机器后重用数据、2. 防止系统故障将数据备份<h2 id="快照持久化（Snapshotting，RDB，默认持久化方式）"><a href="#快照持久化（Snapshotting，RDB，默认持久化方式）" class="headerlink" title="快照持久化（Snapshotting，RDB，默认持久化方式）"></a>快照持久化（Snapshotting，RDB，默认持久化方式）</h2>创建快照，建立内存数据在某个时间点上的副本。可以对快照进行备份，可以将快照复制到其它服务器上（主从复制、读写分离）<h3 id="RDB的触发机制"><a href="#RDB的触发机制" class="headerlink" title="RDB的触发机制"></a>RDB的触发机制</h3></li>
<li><code>save</code>命令，是同步命令，会占用Redis主进程</li>
<li><code>bgsave</code>命令，执行一个异步操作，使用<code>fork()</code>生成子进程将数据保存到硬盘上。主进程调用<code>fork()</code>时也会阻塞，但是比让主进程亲自创建RDB快多了。缺点在于消耗内存。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Redis.conf</span><br><span class="line">save 900 100 # 在900秒后，如果至少有100个key发生变化，Redis就自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line"># RDB持久化文件名</span><br><span class="line">dbfilename dump-&lt;port&gt;.rdb</span><br><span class="line"></span><br><span class="line"># 数据持久化文件存储目录</span><br><span class="line">dir &#x2F;var&#x2F;lib&#x2F;redis</span><br><span class="line"></span><br><span class="line"># bgsave发生错误时是否停止写入，通常为yes</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># rdb文件是否使用压缩格式</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 是否对rdb文件进行校验和检验，通常为yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>
<h3 id="创建RDB的机制：写时复制"><a href="#创建RDB的机制：写时复制" class="headerlink" title="创建RDB的机制：写时复制"></a>创建RDB的机制：写时复制</h3>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:</li>
</ul>
<ol>
<li>Redis 调用forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ol>
<h3 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h3><ul>
<li>优点<ul>
<li>紧凑、适合数据集的备份、用RDB进行备份恢复比AOF快、可以隔段时间进行备份，创建符合不同要求的数据还原点。</li>
<li>方便传送到远端机器，适合容灾恢复。</li>
<li>使用<code>BGSAVE</code>的方式，Redis主进程除了<code>fork</code>不需要任何其他操作。</li>
</ul>
</li>
<li>缺点<ul>
<li>频繁进行<code>fork</code>操作也会影响性能。</li>
<li>不可控，存在数据丢失风险。将数据集进行全量备份是耗时的工作，如果Redis宕机，只能保存上一个检查点记录的数据。</li>
</ul>
</li>
</ul>
<h2 id="AOF持久化（Append-Only-File）"><a href="#AOF持久化（Append-Only-File）" class="headerlink" title="AOF持久化（Append-Only File）"></a>AOF持久化（Append-Only File）</h2><p>比起RDB持久化，AOF持久化的实时性更好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Redis.conf</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><br>每执行一条更改Redis中数据的命令，Redis就将命令写入硬盘中的AOF文件，保存位置和RDB文件的位置相同。</p>
<h3 id="AOF持久化的不同方式"><a href="#AOF持久化的不同方式" class="headerlink" title="AOF持久化的不同方式"></a>AOF持久化的不同方式</h3><p>通过配置文件设置Redis隔多长时间fsync到磁盘一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Redis.conf</span><br><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件，好处是不丢数据，但IO开销大，这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘，但可能丢失1秒数据</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure></p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。<br>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。可以减少磁盘占用量，加速数据恢复。<br>AOF 重写由 Redis 自行触发，<code>bgrewriteaof</code> 仅仅用于手动触发重写操作。在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作</p>
<h3 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h3><ul>
<li>优点<ul>
<li>AOF有序地保存了对数据库执行的所有写入操作，可以对文件进行解析。如果出现了错误的操作，可以对AOF文件解析后通过编辑去除错误的操作，进行数据恢复。</li>
</ul>
</li>
<li>缺点<ul>
<li>一般AOF文件的体积大于RDB文件</li>
<li>使用的fsync策略不当的时候可能会降低速度</li>
</ul>
</li>
</ul>
<h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><h2 id="事务的四大特性："><a href="#事务的四大特性：" class="headerlink" title="事务的四大特性："></a>事务的四大特性：</h2><ul>
<li>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；Redis事务并不支持原子性，虽然Redis事务的多个操作是原子的，事务机制也可以保证多个命令的<strong>正确</strong>执行不被打断，但是Redis事务不支持回滚。<ul>
<li><code>DISCARD</code>命令：清除之前放入队列的命令，然后恢复连接状态。</li>
<li><code>WATCH</code>命令： 将特定的key设置为受监控的状态，如果该key被修改，之后的事务调用<code>EXEC</code>时队列中的所有命令均不会执行。调用<code>UNWATCH</code>命令可以接触之前的<code>WATCH</code>操作。</li>
<li>Redis命令语法错误：后续的命令即使是正确地添加到命令队列中，所有的命令（命令队列中的所有命令，包括出错命令之前和之后的命令）都不会被执行。</li>
<li>Redis命令运行时错误（Redis似乎并不会在加入命令队列时对命令进行类型匹配检查）：<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; set test1 value1-<span class="number">3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; lpush test2 value2-<span class="number">3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; set test3 value3-<span class="number">3</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; exec</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line"><span class="number">3</span>) OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; get test1</span><br><span class="line"><span class="string">&quot;value1-3&quot;</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; get test3</span><br><span class="line"><span class="string">&quot;value3-3&quot;</span></span><br></pre></td></tr></table></figure>
可以看到，运行时错误只会影响出错的命令执行，其它命令都会正常执行，而不会回滚。</li>
</ul>
</li>
<li>隔离性：一个用户的事务不被其他事务干扰。Redis是单线程的，命令在主线程上串行执行，因此Redis事务可以保证隔离性。</li>
<li>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响，除非下一个事务覆盖了这次事务的修改。</li>
<li>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</li>
</ul>
<h1 id="Redis缓存性能问题"><a href="#Redis缓存性能问题" class="headerlink" title="Redis缓存性能问题"></a>Redis缓存性能问题</h1><ul>
<li>key的一种设计：<code>表名:列名:主键名:主键值</code><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2></li>
<li>问题：缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，进而需要到数据库上进行查找，<strong>同时数据库中也不存在相应的数据</strong>。大量的无效请求会落到数据库上造成数据库压力过大。</li>
<li>解决<ul>
<li>做好参数校验，在查询前过滤错误的、不合法的参数，向客户端返回错误。校验可以在后端接口层完成，也可以在前端完成。</li>
<li>缓存无效key：在缓存中放置一些无效key，通过这些key进行查询时让缓存返回无意义值或者null。可以防范使用重复无效key的攻击，但是对于大量变化的无效key会占用内存，因此要为无效key设置较短的过期时间。</li>
<li>布隆过滤器：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端。<ul>
<li>场景：有限的存储空间存储大量需要查找/匹配的元素，提供判断一个元素是否在集合中的功能，允许较低的查找误差。</li>
<li>大致的做法：使用k个hash函数，对于每个要加入的元素，计算出k个hash值。准备一个长度为m的bitmap，然后令这k个hash值对m取模，得到k个在<code>[0, m - 1]</code>范围内的下标，将bitmap中这k个下标对应位置的bit设置为1。对于一个待查找的元素，用同样的k个hash函数计算出k个hash值并对m取模得到k个下标，如果这k个下标对应的位都是1，则说明这个元素<strong>可能</strong>在集合中，否则，说明这个元素<strong>一定</strong>不在集合中。布隆过滤器有将不存在的元素判断为在集合中的可能，但是一定不会将存在于集合中的元素判断为不在集合中。</li>
<li>缺点：有误判率、删除困难。降低概率：增加bitmap的大小、调整hash函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul>
<li>问题：读取到了缓存中不存在但是数据库中存在的数据，需要向数据库发送请求，并发用户多的时候去数据库读取数据。</li>
<li>解决：<ul>
<li>设置热点数据永不过期。</li>
<li><ul>
<li>要对数据库发送请求的情况下，加入互斥锁（信号量？），保证只有一定量的请求能够到达数据库。在缓存重生效之前避免数据库崩溃。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul>
<li>问题：缓存在同一时间大面积的失效/Redis突然不可用，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</li>
<li>解决<ul>
<li>针对Redis服务不可用的情况：<ul>
<li>采用Redis集群</li>
<li>限流（？</li>
</ul>
</li>
<li>针对热点缓存失效的情况：<ul>
<li>为不同缓存设置不同的（随机的）生效时间</li>
<li>要对数据库发送请求的情况下，加入互斥锁（信号量？），保证只有一定量的请求能够到达数据库。在缓存重生效之前避免数据库崩溃。</li>
<li>对热点数据不设置过期时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h1><h2 id="怎么实现分布式锁"><a href="#怎么实现分布式锁" class="headerlink" title="怎么实现分布式锁"></a>怎么实现分布式锁</h2><ul>
<li>mysql、zookeeper、redis</li>
<li>Redlock算法 -&gt; redisson（Redlock算法的Java实现） lock/unlock</li>
<li>解锁问题：加了锁一定要解锁 -&gt; 怎么删锁？ <ul>
<li>代码可能出现异常：finally中解锁</li>
<li>整个节点直接炸了，或者网给掐了：过期策略<ul>
<li>取得锁后直接为锁添加过期时间：这个操作必须是原子的（否则刚加完锁还没设置过期时间节点直接被扬了，这把锁就不会过期了）。然而redis的<code>setnx</code>命令本身并没有提供直接的timeout参数。</li>
</ul>
</li>
<li>节点从宕机状态中恢复/网络恢复，由于过期策略的存在节点持有的锁有可能已经过期。 <ul>
<li>该节点会进行一些不持有锁时不应该继续进行的操作</li>
<li>该节点可能会进行锁释放，在redis上删除了别的节点的锁</li>
<li>解决：删除锁时只能删除自己的锁，先尝试获得锁进行判断<ul>
<li>这个判断-解锁的操作必须是原子的：否则可能出现在锁过期前一刻判断出锁属于自己，而其它节点在锁过期后获得锁，当前节点判断完成后误删其它节点的锁的情况</li>
<li>Redis事务？<code>MULTI</code> <code>EXEC</code> <code>WATCH</code></li>
<li>lua脚本？（Jedis，<code>eval()</code></li>
</ul>
</li>
<li>锁的过期时间应该确保大于业务执行时间 -&gt; 续期</li>
</ul>
</li>
</ul>
</li>
<li>Redis集群分布式锁：主从复制<ul>
<li>Redis是AP型的：有可能存在Redis异步复制造成的锁丢失<ul>
<li>Master写，Slave读。Redis先直接返回成功信息，再将锁同步到Slave节点。但是复制成功之前Master可能会故障，Master进行降级 -&gt; 锁丢失（似乎并没有什么好的办法，这是Redis方案的固有缺陷）</li>
</ul>
</li>
<li>加锁操作</li>
<li>对比ZK：ZK属于CP型，实行同步复制，先将数据从Master复制到从节点，再返回对外成功消息。此时master故障，新master会保留最新的锁信息。但是这会牺牲可用性(A)：对网络延迟敏感，速度取决于最慢速度。</li>
</ul>
</li>
</ul>
<h1 id="秒杀设计"><a href="#秒杀设计" class="headerlink" title="秒杀设计"></a>秒杀设计</h1><ul>
<li>单机情况下的多线程同步只需要使用Java提供的同步机制（<code>synchronized</code>, <code>ReentrantLock</code>…)</li>
<li>多机部署：Nginx负载均衡</li>
<li>多机部署的情况下Java提供的锁机制不够用了 -&gt; 分布式锁（用上Redis提供的分布式锁也没必要使用Java提供的同步机制了</li>
</ul>
<h1 id="缓存和数据库的数据一致性（读写策略）"><a href="#缓存和数据库的数据一致性（读写策略）" class="headerlink" title="缓存和数据库的数据一致性（读写策略）"></a>缓存和数据库的数据一致性（读写策略）</h1><h2 id="旁路缓存模式（Cache-Aside-Pattern）"><a href="#旁路缓存模式（Cache-Aside-Pattern）" class="headerlink" title="　旁路缓存模式（Cache Aside Pattern）"></a>　旁路缓存模式（Cache Aside Pattern）</h2><ul>
<li>适用场景：需要同时维系DB和cache，读操作较多</li>
<li>写步骤<ul>
<li>先更新DB</li>
<li>然后删除cache</li>
</ul>
</li>
<li>读步骤<ul>
<li>从cache中读数据，读到就直接返回</li>
<li>如果从cache中读不到，就从DB中读取数据返回</li>
<li>再将数据放到cache中<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2></li>
</ul>
</li>
<li>旁路缓存模式下数据一致性问题是无法避免的（无法完全保证DB和缓存的一致性。</li>
<li>可以先删cache再更新DB吗<ul>
<li>不可以。因为这样可能会造成数据库（DB）和缓存（Cache）数据不一致的问题。</li>
<li>例如，两个对同一数据的并发操作，一个是更新操作，另一个是查询操作。更新操作删除缓存后，查询操作没有命中缓存，然后查询操作到数据库中读出了旧数据并将旧数据写入缓存，最后更新操作更新了数据库。此时缓存中的旧数据成为了脏数据（和当前数据库内的值不一致了），如果没有过期的话很可能一直脏下去。</li>
</ul>
</li>
<li>我就是要先删缓存再更新DB有什么解决办法吗？<ul>
<li>延时双删策略：先删除cache，然后更新数据库，隔一定时间后再次删除cache，在这段时间内造成的缓存脏数据就会被删除。但是这个间隔时间需要自行进行评估。</li>
</ul>
</li>
<li>这种方式就没有问题吗<ul>
<li>理论上也会出现导致数据不一致的case：一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大（至少比先删cache再更新数据库要小得多）。</li>
</ul>
</li>
<li>写操作的时候为什么要删除cache，而不是写cache（？<ul>
<li>写操作频繁的时候删除cache确实会影响缓存命中率而导致性能下降。选择更新cache的方式需要考虑安全问题。并发的写操作也可能导致脏数据。</li>
<li>例如：写操作A更新了数据库 -&gt; 写操作B更新了数据库 -&gt; 写操作B更新了缓存 -&gt; 写操作A更新了缓存</li>
</ul>
</li>
<li>如果更新数据库成功而删除缓存失败？<ul>
<li>增加cache更新重试机制：如果cache服务当前不可用，就存入队列中等缓存服务可用的时候再将缓存中的key删除。</li>
</ul>
</li>
</ul>
<h2 id="读写穿透模式（Read-Write-Through-Pattern）"><a href="#读写穿透模式（Read-Write-Through-Pattern）" class="headerlink" title="读写穿透模式（Read/Write Through Pattern）"></a>读写穿透模式（Read/Write Through Pattern）</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:31:43" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<ul>
<li>[x] OS里进程持有的”资源”具体有哪些？</li>
<li>[x] 进程切换需要完成哪些工作？（为什么说进程切换开销大？</li>
<li>[x] 线程切换需要完成哪些工作？</li>
</ul>
<h1 id="操作系统基础概念"><a href="#操作系统基础概念" class="headerlink" title="操作系统基础概念"></a>操作系统基础概念</h1><ul>
<li>管理计算机软硬件资源的程序</li>
<li>屏蔽了底层硬件的复杂性，对裸机进行了扩展</li>
<li>操作系统内核是OS的核心部分，负责进程调度（应用程序管理），内存管理，外部设备（硬件设备）管理，文件系统管理<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2></li>
<li>用户态：用户态运行的进程可以直接读取用户程序的数据。</li>
<li>内核态：内核态运行的进程可以不受限制地访问计算机的任何资源。</li>
<li>用户的程序中凡是请求系统资源的操作都需要通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成这些操作。</li>
</ul>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ul>
<li>进程：是程序的一次运行，是对运行中的程序的描述。</li>
<li>线程：也是对运行中的程序的描述，但是粒度小于进程。</li>
<li>进程是资源分配的最小单位，线程是CPU执行时间分配的最小单位。</li>
<li>同一进程下的多个线程可以共享进程的资源。</li>
<li>资源：地址空间，快表，文件描述符（fd）</li>
</ul>
<h2 id="进程持有的资源究竟是什么"><a href="#进程持有的资源究竟是什么" class="headerlink" title="进程持有的资源究竟是什么"></a>进程持有的资源究竟是什么</h2><ul>
<li>进程映像：进程执行的上下文环境。是序列化的一个进程运行状态，主要用于进程调度和恢复。<ul>
<li>进程控制块(PCB)<ul>
<li>进程标识符</li>
<li>CPU通用寄存器的内容，例如PSW、PC</li>
<li>进程调度的状态（ready、suspended、…）、调度优先级信息、进程等待的事件</li>
<li>进程结构信息：子进程标识符…</li>
<li>内存管理信息：页表、段表…</li>
<li>I/O状态信息：被分配的设备、I/O缓冲区地址…</li>
</ul>
</li>
<li>进程执行的程序（指令）</li>
<li>进程执行时所用的数据</li>
<li>进程栈：用户栈和内核栈</li>
</ul>
</li>
<li>内存区域（虚拟内存空间）：包括了可执行代码、数据段、调用栈、堆内存</li>
<li>被分配给进程的资源描述符，例如文件描述符fd</li>
<li>处理器状态（处理器执行上下文），例如寄存器的内容</li>
</ul>
<h2 id="进程控制块与线程控制块？-Thread-Control-Block-TCB"><a href="#进程控制块与线程控制块？-Thread-Control-Block-TCB" class="headerlink" title="进程控制块与线程控制块？(Thread Control Block, TCB)"></a>进程控制块与线程控制块？(Thread Control Block, TCB)</h2><ul>
<li>线程控制块有与PCB相似的字段：<ul>
<li>寄存器值</li>
<li>栈指针</li>
<li>程序计数器</li>
<li>调度状态</li>
</ul>
</li>
<li>线程控制块(可能)特有的内容<ul>
<li>线程标识符(ID)</li>
<li>指向所属进程（控制块）的指针（？？）</li>
</ul>
</li>
</ul>
<h2 id="进程切换（上下文切换）的开销"><a href="#进程切换（上下文切换）的开销" class="headerlink" title="进程切换（上下文切换）的开销"></a>进程切换（上下文切换）的开销</h2><ul>
<li>切换虚拟地址空间（加载下一个线程的页表）</li>
<li>切换内核栈</li>
<li>切换硬件上下文。最显著的开销是保存寄存器中的内容</li>
</ul>
<h2 id="线程切换的开销"><a href="#线程切换的开销" class="headerlink" title="线程切换的开销"></a>线程切换的开销</h2><ul>
<li>不需要切换虚拟地址空间，其余与线程一致。</li>
</ul>
<h2 id="为什么进程切换比线程切换的开销大"><a href="#为什么进程切换比线程切换的开销大" class="headerlink" title="为什么进程切换比线程切换的开销大"></a>为什么进程切换比线程切换的开销大</h2><ul>
<li>进程切换涉及到虚拟地址空间的切换，而线程切换不涉及这个切换，因为同一进程的不同线程使用相同的虚拟地址空间和地址映射规则。将虚拟地址转换为物理地址需要查找页表，而到内存中查找页表是较慢的过程，因此通常使用快表来加速页表查询。当进行进程切换后页表也要切换，此时快表的内容就会失效，地址转换就会变慢。</li>
</ul>
<h2 id="进程的7状态模型"><a href="#进程的7状态模型" class="headerlink" title="进程的7状态模型"></a>进程的7状态模型</h2><p>创建、就绪、运行、阻塞、就绪挂起、阻塞挂起、结束</p>
<h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ul>
<li>各个进程有不同的地址空间，一个进程的内存空间对于另一个内存而言是无法访问的。因此进程间要交换数据需要通过内核，进程1将数据从用户空间拷贝到内核空间，然后进程2再从内核空间将数据读取走。<h3 id="管道-匿名管道"><a href="#管道-匿名管道" class="headerlink" title="管道/匿名管道"></a>管道/匿名管道</h3></li>
<li>管道中数据只能向一个方向流动，需要双方交换数据时需要建立两个管道。</li>
<li>只能用于父子进程或者兄弟进程之间进行通信</li>
<li>单独构成一种独立的文件系统。管道对于管道两端的进程而言是一个文件，但它并不是普通的文件，不属于某种文件系统，只存在于内存中。</li>
<li>本质是一个内核缓冲区，进程以FIFO的方式在这个缓冲区中存取数据。</li>
<li>缓冲区的大小是有限的，需要进行生产/消费同步</li>
<li>传送的是无格式字节流，通信双方需要约定<h3 id="具名管道"><a href="#具名管道" class="headerlink" title="具名管道"></a>具名管道</h3></li>
<li>与匿名管道相比，提供了一个路径名与之关联，以具名管道文件的形式存在于系统中，因此不相关的进程只要可以访问该路径就能通过有名管道相互通信。</li>
<li>严格遵循FIFO。</li>
<li>有名管道的名字存放于文件系统，内容存放在内存中。<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3></li>
<li>Linux系统中进程通信的机制，信号可以在任何时候发给某一进程而不需要知道其状态。（相比之下，管道在创建/发送的时候可能需要对方进程的存在，否则就会阻塞）</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
<li>是在软件层次上对中断的一种模拟，是一种异步通信方式。<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3></li>
<li>消息的链表，存在于内存中，由消息队列标识符标识。</li>
<li>允许一个或多个进程向他写入或读取消息</li>
<li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。</li>
<li>消息队列可以随机查询，可以按消息的类型读取<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3></li>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li>
<li>需要同步机制（如信号量）达到进程间同步和互斥<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3></li>
<li>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</li>
<li>对信号量值的测试和减1操作应该是原子的<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3></li>
<li>socket是一种通信机制，使用这种机制，进程通信可以在单机上运行，也可以跨网络进行，即通过网络让不同计算机上的进程进行通信。</li>
</ul>
<h2 id="线程间同步方式"><a href="#线程间同步方式" class="headerlink" title="线程间同步方式"></a>线程间同步方式</h2><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><ul>
<li>用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。互斥量是一种特殊的信号量（最多允许一个线程访问资源）</li>
<li>事件（Event）：通过通知操作（wait/notify，await/signal）来保持线程同步。</li>
</ul>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul>
<li>FCFS</li>
<li>SJF</li>
<li>时间片轮转RR</li>
<li>多级反馈队列：除了最低级的队列都使用FCFS，高优先级的队列中没有进程时才会选取低优先级队列中的进程，得到时间片并使用完毕的线程需要降到低一级的优先级队列。最低级的队列使用时间片轮转算法进行调度。</li>
<li>优先级调度</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul>
<li>内存的分配与回收、内存地址映射：将逻辑地址转换为物理地址。<h2 id="内存管理的方式"><a href="#内存管理的方式" class="headerlink" title="内存管理的方式"></a>内存管理的方式</h2></li>
<li>为每个进程分配单块连续的内存空间。-&gt; 内存碎片</li>
<li>页式内存管理：将主存分为大小相等且固定的页，按页为进程分配内存，内存空间可以是不连续的。减少了内存碎片，通过页表完成逻辑地址到物理地址的映射。</li>
<li>段式内存管理：将分配给进程的内存空间进行分段，每段赋予逻辑信息(主程序段、子程序段、数据段、（堆）栈段)。通过段表完成逻辑地址到物理地址的映射。</li>
<li>段页式内存管理：先将主存进行分页，在此基础上定义段，每段包含若干页。</li>
</ul>
<h2 id="页式内存管理中的快表"><a href="#页式内存管理中的快表" class="headerlink" title="页式内存管理中的快表"></a>页式内存管理中的快表</h2><p>两个问题：</p>
<ul>
<li>地址转换要快</li>
<li>地址空间大，要使用恰当的数据结构完成地址转换。</li>
<li>快表：页表的一部分，放在cache中，命中时只需要一次访存即可完成内存访问。未命中时需要到内存中查询页表，至少需要两次才能完成内存访问。快表还可以利用程序的局部性原理，因此快表的性能很好。</li>
<li>多级页表：避免把全部页表放进内存占用过多空间，不需要的页表可以置换到外存（硬盘）中。</li>
</ul>
<h2 id="页式内存管理和段式内存管理的区别和联系"><a href="#页式内存管理和段式内存管理的区别和联系" class="headerlink" title="页式内存管理和段式内存管理的区别和联系"></a>页式内存管理和段式内存管理的区别和联系</h2><ul>
<li>共同：<ul>
<li>都为了提高内存利用率，减少内存碎片</li>
<li>都是离散存储的，进程使用的内存地址都可以不连续。</li>
</ul>
</li>
<li>区别：<ul>
<li>页的大小是固定的，由OS决定。段的大小取决于当前运行的程序。</li>
<li>分页仅仅是为了满足OS更好地管理内存的需求。段通常是逻辑信息的单位，对用户程序进行分段可以满足用户分段装入/换出的需求。</li>
</ul>
</li>
</ul>
<h2 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h2><ul>
<li>因为用户程序每次运行时被装入内存的位置有可能是不一样的，用户程序每次运行的进程可能都获得了不同的物理地址空间，因此用户程序声明地址时一般只使用统一的逻辑地址。物理地址就是真实物理内存的地址，是内存单元真正的地址。</li>
<li>用户程序直接访问和修改真实内存地址可能会有意无意地破坏OS或者其它程序。</li>
<li>使用统一的虚拟地址，用户编写程序时无需考虑程序被装入内存时的真实位置，不需要担心程序中编写的内存地址是否被其它程序所拥有，同时也不需要知道OS为进程分配的内存是否连续，内存管理的复杂性一定程度上可以通过使用逻辑地址对编写用户程序的程序员进行屏蔽。</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ul>
<li>内存与外存的速度与价格差距。</li>
<li>通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</li>
<li>理论支持：程序的局部性原理。<ul>
<li>时间局部性：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li>空间局部性：空间局部性 ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
<li>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟存储器。</li>
</ul>
</li>
</ul>
<h2 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h2><ul>
<li>内存和外存</li>
<li>缺页中断：如果需要执行的指令或需要的数据尚未在内存 -&gt; 由处理器通知OS将页/段调入到内存，然后继续执行程序</li>
<li>地址转换<h3 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h3>建立在分页管理之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能和页面置换功能</strong>。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，<strong>仅装入当前要执行的部分页即可运行</strong>。假如在作业运行的过程中发现要访问的页面不在内存，则<strong>由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存</strong>，同时操作系统也可以将暂时不用的页面置换到外存中。<h3 id="请求分段存储管理"><a href="#请求分段存储管理" class="headerlink" title="请求分段存储管理"></a>请求分段存储管理</h3>建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。<h3 id="请求段页式存储管理"><a href="#请求段页式存储管理" class="headerlink" title="请求段页式存储管理"></a>请求段页式存储管理</h3></li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul>
<li>OPT：无法实现，衡量标准</li>
<li>FIFO</li>
<li>LRU</li>
<li>LFU：为每个页维护使用计数</li>
</ul>
<h2 id="CPU寻址"><a href="#CPU寻址" class="headerlink" title="CPU寻址"></a>CPU寻址</h2><p>CPU需要将虚拟地址转换为物理地址才能访问到真正的物理内存。完成这一地址转换的硬件是CPU的内存管理单元(MMU)。</p>
<h1 id="并发-多任务"><a href="#并发-多任务" class="headerlink" title="并发/多任务"></a>并发/多任务</h1><h2 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li>Linux下（其它OS不知道）的内核级线程本质是轻量级进程，多个轻量级进程被OS进行调度的时候就当成进程进行调度，创建线程就像创建进程一样需要创建“进程控制块”之类的数据结构让OS感知其存在，不过在这个数据结构中可以标识这个轻量级进程所属的“组”（所属的进程）<ul>
<li>于是在同一个“组”中进行轻量级进程的切换的时候可以节省一些操作。<ul>
<li>内存寻址所需要的段表/页表/各种表应该是不同地址空间不一样的，每个进程的逻辑地址到物理地址应该有不同的映射规则。如果切换前后的轻量级进程属于同一个进程，那就不用进行页表切换了。至于快表中的内容在进程切换的时候是直接丢弃还是放进PCB之类的数据结构不得而知，但是在轻量级线程之间切换应该也不用对快表进行过多的操作了。</li>
<li>（除了地址空间和代码段，暂时想不出还有什么轻量级进程之间可以共享的资源，打开的文件描述符集合是可以在轻量级进程之间共享的吗？感觉应该可以，那么这些文件描述符需要进行互斥访问吗。）</li>
</ul>
</li>
<li>但是有些操作是省不了的<ul>
<li>栈内存区切换，但是由于同一进程内地址空间是一样的，改个指针应该没什么开销？</li>
<li>“运行上下文”的保存和切换，包括一些进程运行时放置在寄存器里的数据，最典型的是程序计数器</li>
</ul>
</li>
</ul>
</li>
<li>对于让应用级线程和用户级线程进行一一对应的程序（HotSpot VM似乎就是这样的），在用户态创建一个线程需要进行系统调用让OS创建一个轻量级进程。进行线程切换等于让OS进行轻量级进程的切换。</li>
<li>协程的概念：连轻量级进程的创建和切换的开销都不想负担，在一个轻量级进程里创建多个用户级线程。要阻塞的操作（IO）尽量使用异步方式，不让整个轻量级进程被阻塞。在一个轻量级线程里维护协程共有的资源和协程私有的资源（可能存在的协程栈和协程计数器？）<ul>
<li>要利用多核怎么办：多对多映射，创建多个轻量级进程，每个轻量级进程负责多个协程</li>
</ul>
</li>
</ul>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h3><ul>
<li>保存文件元信息的数据结构：每一块的地址，文件所有者，创建时间，权限，大小</li>
<li>索引可以是多级的，Inode中的地址存放的可能是次一级的Inode</li>
<li>Block：实际文件的内容。一个block只能包含一个文件的信息。</li>
</ul>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul>
<li>普通文件-</li>
<li>目录文件d</li>
<li>块设备文件b：随机读写，如磁盘</li>
<li>字符设备文件c：字符流。/dev/null：所有内容被忽略</li>
<li>管道文件p：一头流入另一头流出</li>
<li>套接字s：socket</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/%E8%AE%A1%E7%BD%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/%E8%AE%A1%E7%BD%91/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:32:14" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<ul>
<li>[x] TCP状态图</li>
<li>[x] TIME_WAIT/CLOSE_WAIT大量出现是为什么，怎么解决</li>
<li>[x] TCP为什么慢</li>
<li>[ ] HTTP/2</li>
<li>[x] 能不能用UDP代替TCP(QUIC协议)</li>
</ul>
<h1 id="协议分层（TCP-IP协议栈）"><a href="#协议分层（TCP-IP协议栈）" class="headerlink" title="协议分层（TCP/IP协议栈）"></a>协议分层（TCP/IP协议栈）</h1><ul>
<li>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。我们把应用层交互的数据单元称为报文。</li>
<li>传输层(transport layer)的主要任务就是负责向<strong>两台主机进程之间的通信</strong>提供通用的数据传输服务。应用进程利用该服务传送应用层报文。</li>
<li>运输层主要使用以下两种协议:<ul>
<li>传输控制协议 TCP（Transmission Control Protocol）—提供面向连接的，可靠的数据传输服务。</li>
<li>用户数据协议 UDP（User Datagram Protocol）—提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ul>
</li>
<li>网络层/网际层：在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 </li>
<li>网络接口层（数据链路层/物理层）：数据链路层：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。物理层：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</li>
</ul>
<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><ul>
<li>网络层只会向上提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</li>
</ul>
<h2 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h2><ul>
<li>LISTEN: 等待远程TCP应用程序的连接建立请求</li>
<li>SYN_SENT: 发送连接请求（SYN）后等待来自远程端点的确认。</li>
<li>SYN_REVD: 当前端点已经接收到连接请求并发送确认。该端点正在等待最终确认(ACK)，TCP第二次握手后服务端所处的状态。</li>
<li>ESTABLISHED: 客户端发出ACK后的状态，服务端接收到客户端ACK的状态，TCP连接完全建立。</li>
<li>FIN_WAIT_1: 发出FIN后，等待远程端点对FIN的ACK</li>
<li>FIN_WAIT_2: 收到远程端点对自己发出的FIN的ACK，等待来自远程TCP端点的连接中止请求(FIN)。</li>
<li>TIME_WAIT: 收到远程端点的FIN，向远程端点发送ACK，等待2MSL以确保远程端点收到ACK，随后关闭连接进入CLOSED状态</li>
<li>CLOSING: 发出FIN后，在等待远程端点对FIN的ACK时收到远程端点的FIN，进入该状态（同时关闭）。此时接收到远程端点的ACK会进入TIME_WAIT状态。<br><img src="./pics/network/TCPstatemachine.png" alt="TCPStateMachine"></li>
</ul>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li>TCP的三次握手：<ol>
<li>发起者 SYN seq = x</li>
<li>接受者收到SYN seq = x，发回ACK x + 1 SYN seq = y。此时接收者的TCP状态切换为SYN RECEIVED，创建一个子连接加入到SYN_RCVD队列（半连接队列）</li>
<li>发起者收到ACK x + 1 SYN seq = y，发回ACK y + 1 seq = x + 1</li>
<li>接受者收到ACK x + 1 seq = y + 1，将2中创建的子连接移动到ESTABLISHED队列（全连接队列，accept队列）</li>
<li>接受者端用户程序调用accept()时，将连接从ESTABLISHED队列取出</li>
</ol>
</li>
</ul>
<h3 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h3><ul>
<li>总而言之，TCP双方建立连接时采用三次握手是为了感知双方的存在，同时确认双方的发送/接收能力是否正常。<strong>同时，还可以在这个阶段交换一些参数</strong></li>
<li>第一次握手：发起者发送SYN x，在本次握手无法确认任何事。而接受者收到SYN x可以确定发起者的发送能力正常，接受者的接收能力正常。</li>
<li>第二次握手，接受者发送SYN y ACK x + 1，在本次接受者无法确认任何事，发起者收到SYN y ACK x + 1可以确定发起者的发送能力正常，发起者的接收能力正常，接收者的发送能力和接收能力都正常。此时发起者完成了对接受者的感知，而接受者尚未完成对发起者的感知。</li>
<li>第三次握手，发起者发送ACK y + 1，接受者接收到ACK y + 1后可以确认发起者的接受能力正常，接受者的发送能力正常。至此接受者也完成了对发起者的感知。</li>
</ul>
<h3 id="为什么第二次握手需要设置SYN-1"><a href="#为什么第二次握手需要设置SYN-1" class="headerlink" title="为什么第二次握手需要设置SYN = 1"></a>为什么第二次握手需要设置SYN = 1</h3><p>意义不同。接收端传回发送端所发送的ACK是为了告诉发送端端，接收到的信息确实就是所发送的信号了，这表明从发送端到服务端的通信是正常的。而回传SYN则是为了建立并确认从接收端到发送端的通信。</p>
<h2 id="TCP-vs-UDP-TCP为什么慢"><a href="#TCP-vs-UDP-TCP为什么慢" class="headerlink" title="TCP vs UDP(TCP为什么慢)"></a>TCP vs UDP(TCP为什么慢)</h2><ul>
<li>TCP: 要连接，要释放，无广播。因为要确保可靠传输，需要有序传输，确认机制，流量控制（发送方和接收方的速度同步），拥塞控制（网络状态差时减少发送），增加了很多开销。</li>
<li>UDP：无连接，不需要确认，不提供可靠交付，即时性强</li>
</ul>
<h2 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h2><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。-&gt; 粘包问题</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。（有序传输）</li>
<li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li>拥塞控制： 当网络拥塞时，减少数据的发送。</li>
<li>ARQ协议（自动重传请求）： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h2 id="ARQ协议：确认机制"><a href="#ARQ协议：确认机制" class="headerlink" title="ARQ协议：确认机制"></a>ARQ协议：确认机制</h2><ul>
<li>在OSI模型的数据链路层和传输层都使用的错误纠正协议之一。通过确认和超时两个机制在不可靠的基础上实现可靠的信息传输。<h3 id="停止-等待ARQ"><a href="#停止-等待ARQ" class="headerlink" title="停止-等待ARQ"></a>停止-等待ARQ</h3>每发完一个分组就停止发送等待对方确认（等待ACK的序号）。过了一段时间后没有得到ACK确认就重发，直到收到确认。<br>优点是简单，缺点是信道利用率低，等待时间长。</li>
<li>维护超时计时器，超时未确认则重传发送过的分组（自动重传ARQ）。如果收到重复分组则丢弃，但要再次发送确认。确认消息丢失或确认消息迟到都会导致重传，对重复的数据和重复的确认的处理是相同的，都是丢弃，重复数据会发送确认。</li>
</ul>
<h3 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h3><ul>
<li>发送方维护一个发送窗口，发送窗口内的分组连续发送出去而不需要等待确认，接收方采用累计确认，确认按序到达的最后一个分组，表明在此之前的所有分组都正确地收到了。</li>
<li>优点：信道利用率高</li>
<li>缺点：有时接收方无法向发送方反映正确收到的所有分组的信息。发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h2 id="TCP流量控制：滑动窗口"><a href="#TCP流量控制：滑动窗口" class="headerlink" title="TCP流量控制：滑动窗口"></a>TCP流量控制：滑动窗口</h2><ul>
<li>流量控制：控制发送方的发送速率，保证接收方来得及接收。</li>
</ul>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。（需要对比流量控制）<br>维护拥塞窗口，根据网络的拥塞程度动态变化，发送方将发送窗口调整为拥塞窗口和接收窗口中较小的一个。</p>
<ul>
<li>慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大<strong>发送窗口</strong>，也就是<strong>由小到大逐渐增大拥塞窗口数值</strong>。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li>拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li>快重传与快恢复（Fast Retransmit and Recovery，FRR）：如果不使用快重传，数据包丢失时TCP将会使用定时器来要求传输暂停，这段时间内没有新的或复制的数据包被发送。如果使用FRR，接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1。此时客户端会进入<code>TIME-WAIT</code>状态，等待2MSL（最长报文段寿命）</li>
<li>服务端收到ACK报文确认后会直接关闭TCP连接，客户端等待2MSL后也会关闭TCP连接</li>
</ul>
<h3 id="为什么要等待2MSL"><a href="#为什么要等待2MSL" class="headerlink" title="为什么要等待2MSL"></a>为什么要等待2MSL</h3><ul>
<li>MSL(Maximum Segment Lifetime)：最大报文段寿命。</li>
<li>第一，防止客户端发送的最后一个ACK报文丢失。在这种情况下，服务端收不到客户端发送的最后一个ACK，会再次发送释放连接报文。<ul>
<li>其实这一目的并不十分重要，并且2MSL也并不是最保守的一个估计值。最保守的估计值应该是一直等待到对方的超时重传次数全部用完再加一个MSL。第一个目标虽然重要，但并不十分关键，因为既然已经到了关闭连接的最后一步，说明在这个TCP连接上的所有用户数据已经完成可靠传输，所以要不要完美的关闭这个连接其实已经不是那么关键了。</li>
</ul>
</li>
<li>第二，如果不等待2MSL（不存在TIME_WAIT）状态，假如双方关闭连接后又经过三次握手建立了一个新的连接，使用的IP地址和端口和这个先前的连接完全相同，并且原先的连接中还有数据报残存在网络中，这样残存的数据报有可能成功到达通信的某一方，通信的某一方有可能接收到上一个连接残存的数据。为了防止这一点，TCP定义了TIME_WAIT状态，让释放连接的一方的socket等待2MSL后再接受同一个socket（同一个四元组）建立连接的请求。这足以让<strong>两个方向</strong>上的旧数据都过期。<ul>
<li>回忆四次挥手的最后两次：<ol>
<li>TCP的一端发送FIN报文后如果收不到对端针对该FIN的ACK，则会反复多次重传FIN报文（应该回有一个超时时间</li>
<li>被动关闭（第二次发送FIN报文的一端）处于<code>LAST-ACK</code>状态在收到最后一个ACK之后不会发送任何报文，立即进入<code>CLOSED</code>状态。</li>
<li>主动关闭的一端在收到FIN报文后回复ACK并进入<code>TIME-WAIT</code>状态。</li>
<li>处于<code>TIME_WAIT</code>状态的一端在收到重传的FIN时会重新计时</li>
</ol>
</li>
<li>假设A刚对B发出的FIN发回ACK，进入了<code>TIME_WAIT</code>状态，而B正处于<code>LAST_ACK</code>状态。B在收到最后一个ACK之前会重传FIN直至超时。<ul>
<li>如果ACK在网络中丢失，B会一直重传FIN直到超时。如果B的FIN能被A接收，那么计时器重置，双方的状态都不变。如果B的FIN始终无法传达到A，那么A在经历2MSL后状态会变为<code>CLOSED</code>，B会重传FIN到超时，在此之前都处于<code>LAST_ACK</code>状态。</li>
<li>如果ACK被B接收到，从A发送到B接收经历了时间t，则必有<code>0 &lt;= t &lt;= MSL</code>。最极端的情况是，当<code>t = MSL</code>时，B在收到ACK的瞬间重传了一次FIN，那么这个FIN需要被丢弃，让A再等一个MSL即可让这个FIN失效。因此A至少需要等2MSL。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="为什么TCP的初始序列号-Sequence-Number-需要是随机的"><a href="#为什么TCP的初始序列号-Sequence-Number-需要是随机的" class="headerlink" title="为什么TCP的初始序列号(Sequence Number)需要是随机的"></a>为什么TCP的初始序列号(Sequence Number)需要是随机的</h2><ul>
<li>为了防范针对TCP的攻击：IP欺骗<ul>
<li>首先回忆一下，TCP连接的双方都要生成一个初始序列号。</li>
<li>对于一对相互信任的主机A和B，主机C如果知道了主机B的IP，在TCP初始序列号可预测的情况下，可以冒充主机B与主机A建立TCP连接</li>
<li>具体流程: 主机C使用主机B的IP向主机A发送TCP SYN，主机A会将它的SYN + ACK发给主机B，主机B此时不会理会（因为不是它发起的连接）。此时主机C无从得知主机A发出的SYN + ACK的序列号，但是如果TCP初始序列号非随机（可预测），则主机C就可以直接构造出正确的序列号与主机A建立TCP连接。在建立之后主机A就会正常接收来自主机C的消息了。</li>
</ul>
</li>
</ul>
<h2 id="TCP-Backlog，netstat中的RECV-Q和SEND-Q"><a href="#TCP-Backlog，netstat中的RECV-Q和SEND-Q" class="headerlink" title="TCP Backlog，netstat中的RECV-Q和SEND-Q"></a>TCP Backlog，netstat中的RECV-Q和SEND-Q</h2><h3 id="TCP的全连接队列和半连接队列"><a href="#TCP的全连接队列和半连接队列" class="headerlink" title="TCP的全连接队列和半连接队列"></a>TCP的全连接队列和半连接队列</h3><ul>
<li>半连接队列：SYN_RCVD队列</li>
<li>全连接队列：accept队列</li>
</ul>
<h3 id="backlog参数会影响什么，怎么影响"><a href="#backlog参数会影响什么，怎么影响" class="headerlink" title="backlog参数会影响什么，怎么影响"></a>backlog参数会影响什么，怎么影响</h3><ul>
<li>backlog是系统调用listen中的一个参数，能够影响半连接队列和全连接队列的长度</li>
<li>能够影响上述两个队列长度的还有<code>/proc/sys/net/core/somaxconn</code>, <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>这两个参数</li>
<li>全连接队列的长度上限为<code>min(backlog, somaxconn)</code></li>
<li>半连接队列的长度上限为<code>roundup_pow_of_two(max(8, min(tcp_max_syn_backlog, min(backlog, somaxconn))) + 1)</code>，其中<code>roundup_pow_of_two(n)</code>是指大于等于<code>n</code>且最接近<code>n</code>的2的x次幂（返回2的x次幂的值）。</li>
<li>tcp_max_syn_backlog - INTEGER<br>Maximal number of remembered connection requests, which have not<br>received an acknowledgment from connecting client.<br>The minimal value is 128 for low memory machines, and it will<br>increase in proportion to the memory of machine.<br>If server suffers from overload, try increasing this number.<br>根据大意是指半连接队列的最大长度。</li>
<li>somaxconn - INTEGER<br>Limit of socket listen() backlog, known in userspace as SOMAXCONN.<br>Defaults to 128.  See also tcp_max_syn_backlog for additional tuning<br>for TCP sockets.</li>
<li>那为什么实际计算队列长的时候那么奇怪呢（</li>
</ul>
<h3 id="netstat中的RECV-Q和SEND-Q"><a href="#netstat中的RECV-Q和SEND-Q" class="headerlink" title="netstat中的RECV-Q和SEND-Q"></a>netstat中的RECV-Q和SEND-Q</h3><ul>
<li>连接建立（ESTABLISHED）时，RECV-Q指的是连接到该socket的用户程序还没有复制（到用户空间）的字节数，SEND-Q指的是远端主机还没有确认收到的字节数。</li>
<li>在侦听状态中(LISTENING),RECV-Q指的是当前的SYN BACKLOG（since 2.6.18），SEND-Q指的是当前SYN BACKLOG的最大值。</li>
<li>根据文档，SYN backlog就是半连接队列（</li>
</ul>
<h2 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h2><ul>
<li>TCP会对用户数据进行调整后封装发送。这样会导致用户多次发送的数据被封装在一个TCP报文中，或者用户一次发送的数据被拆分成多个TCP报文；或者先被发送的数据需要等待一段时间，才能跟后面被发送的数据一起组成报文被发送出去。因为TCP是面向流的协议，同时为了解决大量小报文的情况下包头比负载大导致传输性价比太低的问题，TCP会对用户数据进行重新调整。</li>
<li>如果开发者需要解决数据被合并发送的问题，需要对应用层协议进行重新设计，例如让应用层协议数据以特定的标志开头，在应用层协议头表明该协议数据的长度，以便于在处理字节流时重新获取完整的包数据。</li>
<li>如果开发者希望让数据立级发送而不是等待，可以设置<code>TCP_NODELAY</code>来尝试解决。</li>
</ul>
<h2 id="TIME-WAIT大量出现"><a href="#TIME-WAIT大量出现" class="headerlink" title="TIME_WAIT大量出现"></a>TIME_WAIT大量出现</h2><h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p><code>netstat -an | grep TIME_WAIT</code></p>
<h3 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h3><ul>
<li><code>TIME_WAIT</code>只会出现在主动发起四次挥手的一方。原因之一可能是因为HTTP服务器没有设置<code>keepalive</code>，导致每发送一个响应就要断开连接。</li>
<li>还有谁用TCP连接？数据库…例如redis…MySQL…</li>
</ul>
<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><h2 id="建立TCP连接与ARP的关系"><a href="#建立TCP连接与ARP的关系" class="headerlink" title="建立TCP连接与ARP的关系"></a>建立TCP连接与ARP的关系</h2><p>应用接受用户提交的数据，触发TCP建立连接，TCP的第一个SYN报文通过connect函数到达IP层，IP层通过查询路由表：</p>
<ul>
<li>如果目的IP和自己在同一个网段：<ul>
<li>当IP层的ARP高速缓存表中存在目的IP对应的MAC地址时，则调用网络接口send函数（参数为IP Packet和目的MAC））将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去；</li>
<li>当IP层的ARP高速缓存表中不存在目的IP对应的MAC地址时，则IP层将TCP的SYN缓存下来，发送ARP广播请求目的IP的MAC，收到ARP应答之后，将应答之中的<code>&lt;IP地址，对应的MAC&gt;</code>对缓存在本地ARP高速缓存表中，然后完成TCP SYN的IP封装，调用网络接口send函数（参数为IP Packet和目的MAC））将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去。</li>
</ul>
</li>
<li>如果目的IP地址和自己不在同一个网段，就需要将包发送给默认网关，这需要知道默认网关的MAC地址：<ul>
<li>当IP层的ARP高速缓存表中存在默认网关对应的MAC地址时，则调用网络接口send函数（参数为IP Packet和默认网关的MAC）将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC</li>
<li>当IP层的ARP高速缓存表中不存在默认网关对应的MAC地址时，则IP层将TCP的SYN缓存下来，发送ARP广播请求默认网关的MAC，收到ARP应答之后，将应答之中的&lt;默认网关地址，对应的MAC&gt;对缓存在本地ARP高速缓存表中，然后完成TCP SYN的IP封装，调用网络接口send函数（参数为IP Packet和默认网关的MAC）将数据提交给网络接口，网络接口完成Ethernet Header + IP + CRC的封装，并发送出去。</li>
</ul>
</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="输入URL-gt-页面加载完成"><a href="#输入URL-gt-页面加载完成" class="headerlink" title="输入URL -&gt; 页面加载完成"></a>输入URL -&gt; 页面加载完成</h2><h3 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h3><ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP响应报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><ul>
<li>唯一标识是IP地址，但是IP地址不方便记忆，在用户友好和可用性中做权衡 -&gt; 域名到IP地址的解析（DNS解析）</li>
<li>DNS解析：递归查询。<ul>
<li>使用UDP协议</li>
<li>（host文件？） -&gt; 本地域名服务器 -&gt; 根域名服务器(com, net, …) -&gt; 顶级域名服务器 -&gt; （主）域名服务器</li>
</ul>
</li>
<li>DNS优化 -&gt; DNS缓存<ul>
<li>DNS存在多级缓存：浏览器缓存、系统缓存、路由器缓存、ISP（Internet Service Provider）服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存</li>
</ul>
</li>
<li>DNS负载均衡：让DNS返回一个合适的机器IP给用户。</li>
</ul>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>构建HTTP请求报文，通过TCP协议发送到服务器指定端口。HTTP -&gt; 80，HTTPS -&gt; 443</p>
<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">Request</span>-<span class="title">URL</span> <span class="title">HTTP</span>-<span class="title">Version</span> <span class="title">CRLF</span></span></span><br></pre></td></tr></table></figure>
<h4 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h4><p>允许客户端和服务器之间传递HTTP报文时携带附加信息和关于（客户端）自身的信息。<br>常见请求报头</p>
<ul>
<li>Cookie</li>
<li>With-Cridential</li>
</ul>
<p>自定报头：一般以<code>X-</code>开头</p>
<h4 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h4><p>发送的数据。</p>
<h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul>
<li><p>1xx：指示信息–表示请求已接收，继续处理。</p>
</li>
<li><p>2xx：成功–表示请求已被成功接收、理解、接受。</p>
<ul>
<li>200 OK</li>
<li>202 Accepted</li>
</ul>
</li>
<li><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p>
<ul>
<li>301 Moved Permanently：</li>
<li>302 Moved Temporarily</li>
<li>304 Not Modified：不包含消息体，客户端可以直接使用本地缓存的请求结果</li>
</ul>
</li>
<li><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p>
<ul>
<li>400 Bad Request：语义有误、参数错误</li>
<li>401 Unauthorized：需要进行用户验证</li>
<li>403 Forbidden：拒绝执行，通常可以表示权限不足</li>
<li>404 Not Found：指定的资源未找到</li>
</ul>
</li>
<li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<ul>
<li>500 Internal Server Error：一般是服务器源代码出错。</li>
</ul>
</li>
</ul>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p>常见响应报头</p>
<ul>
<li>expires：http1.0的缓存控制响应头，表示未来资源会过期的时间，用于实现强制缓存。过期前会在本地缓存数据库中读取信息，过期后则向服务器发送请求。</li>
<li>Cache-Control：HTTP1.1的缓存控制响应头，用于实现强制缓存（<code>max-age=xxx</code>）。<code>no-cache</code>使用协商缓存。<code>no-store</code>则禁用缓存</li>
<li>Last-Modified：http1.0的缓存控制响应头，用于实现协商缓存。第二次及之后的请求时浏览器会首先带上If-Modified-Since请求头去访问服务器，而服务器将其中携带的时间与资源修改时间匹配。若不一致，服务器返回新的资源并更新Last-Modified。若一致，则返回304状态码。</li>
<li>Etag：http1.1通过响应头的Etag字段(内容特征值)作为缓存标识。第一次请求时服务器将资源和Etag一并返回给浏览器。之后的请求时浏览器将Etag信息放到If-None-Match请求头去访问服务器。服务器收到请求后将服务器中的文件标识与浏览器发来的标识进行对比，如果不相同则返回新资源和新的Etag，否则返回304状态码。</li>
<li>Connection：设置为<code>Keep-Alive</code>可以告诉客户端本次HTTP请求结束后不需要关闭TCP连接，方便下次HTTP请求使用相同的TCP连接。</li>
</ul>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>返回的信息：HTML/CSS/JS/json…</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li>HTTP是明文传输的。HTTPS为HTTP的内容进行加密：HTTP + SSL/TLS</li>
<li>对称加密需要提前协商密钥，但是协商密钥的过程可能会被发现，密钥可能会泄露。</li>
<li>使用非对称加密无法防范中间人攻击：非对称加密需要通信双方生成密钥对并且交换公钥，中间人在交换公钥的过程中可以截获通信一方的公钥，将自己的公钥发给另一方。这样，中间人可以用自己的私钥对通信双方的通信内容进行解密，同时生成假消息发送给通信双方。此时问题在于通信双方如何确认对方的身份，如何确定发送的消息没有经过中间人篡改。并且，非对称加密的性能消耗高，一直使用非对称加密会降低应用的性能表现。</li>
<li>确定消息没有经过篡改：摘要算法（数字签名，单向哈希）<ul>
<li>甲方对消息明文使用单向哈希算法生成摘要，再使用<strong>自己的私钥</strong>对摘要进行加密，得到一个数字签名。</li>
<li>乙方对消息明文使用相同的单向哈希算法生成摘要，再使用<strong>甲方的公钥</strong>对数字签名进行解密，得到又一个摘要。如果这两个摘要是相等的，说明接收到的消息没有受到中间人篡改。</li>
<li>单向哈希算法可以进行协商。</li>
<li>但是，如果中间人彻底冒充了通信双方，即甲乙双方持有的是中间人的公钥，中间人持有甲乙双方的公钥，使用摘要算法也无法阻止消息被窃取和篡改：甲方持有的是中间人的公钥，因此无论是使用自己的私钥进行加密，还是用获得的公钥（中间人的公钥）进行加密，中间人都可以完成对消息内容的解密。不仅如此，因为乙方持有的也是中间人的公钥，所以中间人可以对消息内容进行篡改，然后用相同的单向哈希算法和他自己的私钥伪造数字签名再发送给乙方。乙方无法判断它在和甲方还是中间人通信。</li>
<li>还需要一种机制，证明通信双方没有被冒充，防止公钥被替换</li>
</ul>
</li>
<li>解决方案：证书中心（Certificate Authority，CA）<ul>
<li>让证书中心使用<strong>证书中心的私钥</strong>（保证了证书的来源是CA）对服务端的公钥和关于服务端的一些基本信息进行加密，生成<strong>数字证书</strong>。证书的内容包括证书颁发机构、服务端网址、用CA私钥加密后的服务端公钥，用<strong>CA私钥加密后的证书签名</strong>，证书签名是对服务端网址等服务端基本信息使用单向哈希算法生成的签名。</li>
<li>在通信双方的公钥交换阶段，服务端直接返回证书，客户端收到证书后对证书的真伪进行验证。各大浏览器和OS已经维护了所有<strong>权威的</strong>证书机构的名称和公钥（至于非权威的，需要进行下载。。。比如12306），因此可以从本地找到对应的机构公钥，解密出证书签名。<strong>回想一下，这个证书签名是使用单向哈希算法对服务端的一些基本信息（比如服务端的域名）生成签名（摘要）得到的</strong>，因此客户端只需要使用同样的信息和同样的单向哈希算法计算出这个证书签名，并与解密得到的证书签名进行比对就可以确认证书的真伪了。</li>
<li>客户端确认了公钥的来源，就可以用CA的公钥解密得到服务端的公钥，并使用服务端的公钥加密<strong>客户端生成的对称加密密钥</strong>，发送给服务端。</li>
<li>最后，服务端得到了客户端生成的对称加密密钥，可以使用对称加密进行通信。</li>
<li>在这个通信过程中，由于<strong>数字证书</strong>中的<strong>证书签名</strong>是使用<strong>CA的私钥</strong>进行加密的，中间人无法使用自己的相关信息生成一个假的<strong>证书签名</strong>，因为中间人没有CA的私钥。</li>
</ul>
</li>
</ul>
<h3 id="HTTP长连接"><a href="#HTTP长连接" class="headerlink" title="HTTP长连接"></a>HTTP长连接</h3><ul>
<li>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</li>
<li>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入<code>Connection: keep-alive</code></li>
<li>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></li>
<li><p>TCP长连接：</p>
<ul>
<li>理论上，TCP连接可以一直保持下去。但是需要一种机制判断当前连接是否具有通信能力。</li>
<li>TCP keepalive 保活机制<ul>
<li>如果一段时间(<code>tcp_keepalive_time</code>)内某一连接不活跃，开启保活功能的一端会向对方发送一个保活探测报文。</li>
<li>如果对方正常存活且连接有效，对端会对探测报文进行响应，发送端如果能收到报文则可以判断TCP连接正常，此时重置保活时间计数器。</li>
<li>若由于网络原因或其他原因导致，发送端无法正常收到保活探测报文的响应。那么在一定探测时间间隔（<code>tcp_keepalive_intvl</code>）后，将继续发送保活探测报文。直到收到对端的响应，或者达到配置的探测循环次数上限（<code>tcp_keepalive_probes</code>）都没有收到对端响应，这时对端会被认为不可达，TCP连接随存在但已失效，需要将连接做中断处理。</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP长连接：</p>
<ul>
<li>开启<code>keep-alive</code>之后，服务器再响应后不会直接断开TCP连接，而是将TCP连接维持一段时间。在这段时间内，如果同一客户端再次发起HTTP请求，便可以复用此TCP连接向服务端发请求，并重置timeout时间计数器，再接下来一段时间还可以继续服用。如果一段时间后没有发送HTTP请求，则可以关闭TCP连接。</li>
</ul>
</li>
<li><p>为什么有了TCP keepalive还需要HTTP keep-alive？</p>
<ul>
<li>如果双方节点和网络不出问题，连接双方不主动释放连接的话，理论上TCP连接可以<strong>永远维持下去</strong>，而维护大量的TCP连接显然是非常消耗资源的。</li>
<li>但是，什么时候维持连接是合适的，什么时候应该断开连接，TCP协议是不知道的，TCP只知道“能不能维持当前连接”，至于维持和断开连接的时机判断<strong>更取决于应用层</strong>，不同应用层协议对应的场景不同，可能会有不同的策略。</li>
</ul>
</li>
</ul>
<h2 id="HTTP-1-0-vs-1-1"><a href="#HTTP-1-0-vs-1-1" class="headerlink" title="HTTP 1.0 vs 1.1"></a>HTTP 1.0 vs 1.1</h2><ol>
<li>HTTP1.0默认使用短连接，不复用TCP连接。HTTP/1.1默认使用长连接。有非流水线方式和流水线方式。流水线：客户端收到HTTP响应报文之前就可以发送新的请求报文。非流水线：一定要收到前一个响应才可以发送下一个请求。</li>
<li>新增错误状态响应码</li>
<li>缓存处理：更多可选的缓存头</li>
<li>带宽优化和网络连接的使用：<code>range</code>请求头，只请求资源的某个部分，返回码是206.</li>
</ol>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><ol>
<li>Server Push: 在clinet请求之前server就将资源发送给client。例如在clinet请求index.html时将js和css文件一并发送。</li>
</ol>
<h2 id="HTTP3-0-QUIC协议-能不能用UDP代替TCP"><a href="#HTTP3-0-QUIC协议-能不能用UDP代替TCP" class="headerlink" title="HTTP3.0/QUIC协议/能不能用UDP代替TCP"></a>HTTP3.0/QUIC协议/能不能用UDP代替TCP</h2><h1 id="URI-vs-URL"><a href="#URI-vs-URL" class="headerlink" title="URI vs URL"></a>URI vs URL</h1><ul>
<li>URI：资源的唯一标识</li>
<li>URL：资源的唯一定位符，一种具体的URI，提供访问该资源的方式（即协议）</li>
</ul>
<h1 id="如何保存用户状态？"><a href="#如何保存用户状态？" class="headerlink" title="如何保存用户状态？"></a>如何保存用户状态？</h1><p>Cookie - Session</p>
<ul>
<li>Session：在服务端记录用户状态。那么当一个连接到来时，服务器如何判断这个连接对应的是哪一个用户？-&gt; 给客户端一个对应Session的Session ID，让客户端后续发送请求时携带这个Session ID。</li>
<li>客户端要怎么保存这个Session ID -&gt; 存放在Cookie中。</li>
<li>不要再Cookie中保存敏感用户信息。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/JVM/" class="post-title-link" itemprop="url">JVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:33:32" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<h1 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><h4 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h4><ul>
<li>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4></li>
<li>生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</li>
<li>实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</li>
<li>局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li>
<li><code>StackOverflowError</code>: 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code>错误。</li>
<li><code>OutOfMemoryError</code>: 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出<code>OutOfMemoryError</code>错误。<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4></li>
<li>拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li>
<li>也会出现<code>StackOverflowError</code>和<code>OutOfMemoryError</code>错误。</li>
</ul>
<h3 id="线程共享："><a href="#线程共享：" class="headerlink" title="线程共享："></a>线程共享：</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul>
<li>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>几乎</strong>所有的对象实例以及数组都在这里分配内存。</li>
<li>逃逸分析/栈上分配: 如果某些方法中的对象引用没有被返回，或者未被外面使用，对象可以直接在栈上分配内存。</li>
<li>分代垃圾回收：<ul>
<li>JDK &lt; 7：新生代、老年代、方法区（HotSpot 永久代）</li>
<li>JDK 7: JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代 。</li>
<li>JDK &gt;= 8: 移除堆中的方法区（永久代）、将除了<code>StringTable</code>以外的运行时常量池内容移动到直接内存中的元空间（Metaspace）</li>
<li>Eden区、From Survivor区、To Survivor区</li>
</ul>
</li>
<li><code>OutOfMemoryError: GC Overhead Limit Exceeded</code>: JVM花太多时间执行垃圾回收并且只能回收很少垃圾</li>
<li><code>java.lang.OutOfMemoryError: Java heap space</code>: 创建新对象时堆内存空间不足存放新创建的对象（和配置的内存大小有关，和本机物理内存无关）<h4 id="（逻辑上的）方法区"><a href="#（逻辑上的）方法区" class="headerlink" title="（逻辑上的）方法区"></a>（逻辑上的）方法区</h4></li>
<li>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>JDK &gt;= 8: <code>StringTable</code>存放于堆内存，其余内容存放于直接内存（元空间）</li>
<li>为什么要将永久代替换为元空间？<ul>
<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。（当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code>）</li>
<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由<code>MaxPermSize</code>控制了, 而可以只由由系统的实际可用空间来控制（也可以用参数进行限制，默认为unlimited），这样能加载的类就更多了。</li>
</ul>
</li>
<li>运行时常量池：</li>
</ul>
<h4 id="直接内存（非运行时数据区的一部分）"><a href="#直接内存（非运行时数据区的一部分）" class="headerlink" title="直接内存（非运行时数据区的一部分）"></a>直接内存（非运行时数据区的一部分）</h4><ul>
<li>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致<code>OutOfMemoryError</code>错误出现。</li>
<li>NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。</li>
<li>不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</li>
</ul>
<h2 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h2><h3 id="1-类加载检查"><a href="#1-类加载检查" class="headerlink" title="1.类加载检查"></a>1.类加载检查</h3><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="2-分配内存"><a href="#2-分配内存" class="headerlink" title="2.分配内存"></a>2.分配内存</h3><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><ol>
<li>指针碰撞<ul>
<li>适用场景：堆内存规整、没有碎片</li>
<li>原理：用过的内存全部整合到一边、没用过的放在另一边，中间有个分界值指针、只要向着没用过的内存方向将该指针移动内存大小位置即可</li>
<li>对应的GC收集器：Serial、ParNew</li>
</ul>
</li>
<li>空闲列表<ul>
<li>适用：堆内存不规整</li>
<li>原理：JVM维护列表，列表记录哪些内存块可用，分配时找出足够大的内存块为对象分配并更新列表</li>
<li>GC收集器：CMS<h4 id="内存分配的线程安全问题"><a href="#内存分配的线程安全问题" class="headerlink" title="内存分配的线程安全问题"></a>内存分配的线程安全问题</h4>分配内存的操作需要保证原子性。</li>
</ul>
</li>
<li>CAS：一种乐观锁的实现，冲突则重试</li>
<li>TLAB：为每个线程预先在Eden区分配一部分内存，优先使用TLAB内存，TLAB内存不够用时再通过CAS+重试的方法进行内存分配。</li>
</ol>
<h3 id="3-初始化零值"><a href="#3-初始化零值" class="headerlink" title="3.初始化零值"></a>3.初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（默认值？）（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="4-设置对象头"><a href="#4-设置对象头" class="headerlink" title="4.设置对象头"></a>4.设置对象头</h3><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="5-执行init方法"><a href="#5-执行init方法" class="headerlink" title="5.执行init方法"></a>5.执行init方法</h3><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行<code>new</code>指令之后会接着执行<code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在内存中的布局：对象头、实例数据、对齐填充。<br>Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p>
<p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="对象的访问定位（如何通过引用访问一个具体对象）"><a href="#对象的访问定位（如何通过引用访问一个具体对象）" class="headerlink" title="对象的访问定位（如何通过引用访问一个具体对象）"></a>对象的访问定位（如何通过引用访问一个具体对象）</h2><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><ul>
<li>Java 堆中划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；（一次间接地址）</li>
<li>优点：移动对象不需要改变引用，只需要改变句柄池中到对象实例数据的指针。<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3></li>
<li>如果使用直接指针，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li>
<li>优点：速度快，少一次指针定位</li>
</ul>
<h2 id="String常量池"><a href="#String常量池" class="headerlink" title="String常量池"></a>String常量池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abcd&quot;</span>;<span class="comment">//先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新的对象，如果常量池中没有这个字符串常量，则也要创建一个</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新的对象，注意new关键字一定会在堆上创建新的对象</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="GC的三个任务"><a href="#GC的三个任务" class="headerlink" title="GC的三个任务"></a>GC的三个任务</h2><ul>
<li>确定回收目标（哪些是垃圾）</li>
<li>确定回收时机</li>
<li>怎么回收</li>
</ul>
<h2 id="堆内存的区域划分"><a href="#堆内存的区域划分" class="headerlink" title="堆内存的区域划分"></a>堆内存的区域划分</h2><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>存放新生对象，一般占1/3，由于频繁创建对象，会频繁触发MinorGC进行垃圾回收。</p>
<ul>
<li>Eden区：新对象的出生地（如果新对象占用内存很大会直接分配到老年代）。Eden区内存不够的时候会触发MinorGC，对新生代进行一次垃圾回收</li>
<li>Survivor From：上一次GC的幸存者，作为这一次GC的被扫描者</li>
<li>Survivor To：保留一次MinorGC过程中的幸存者</li>
</ul>
<h4 id="MinorGC的过程（复制算法）"><a href="#MinorGC的过程（复制算法）" class="headerlink" title="MinorGC的过程（复制算法）"></a>MinorGC的过程（复制算法）</h4><ol>
<li>将Eden区和Survivor From区域中经历过GC而存活的对象复制到Survivor To区域，如果有对象的年龄到达了进入老年代的标准，则移动到老年代区。复制的同时将这些对象的年龄+1。如果Survivor To空间不足则直接移动到老年代</li>
<li>然后清空Eden区和Survivor From区</li>
<li>将Survivor From区和Survivor To区的角色互换，原本的Survivor To区会成为下一次GC的Survivor From区</li>
</ol>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>主要存放生命周期长的内存对象。因为对象较为稳定所以Major GC不会频繁执行。一般情况下，进行Minor GC使得新生代对象需要移动到老年代，导致老年代空间不足时才触发。如果找不到足够大的连续空间分配给新创建的较大对象时也会提前触发一次Major GC。</p>
<h4 id="Major-GC的过程（标记-清除算法）"><a href="#Major-GC的过程（标记-清除算法）" class="headerlink" title="Major GC的过程（标记-清除算法）"></a>Major GC的过程（标记-清除算法）</h4><p>首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p>
<h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果有任何与之关联的引用，即引用计数为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。但是该方法难以处理循环引用的情况。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>通过GC Roots对象为起点进行搜索，节点走过的路径为引用链。GC Roots就是一组必须活跃的引用。当一个对象到GC Roots没有任何引用链相连的话，证明此对象是不可用的。</p>
<ul>
<li>可以作为GC Roots的对象<ul>
<li>虚拟机栈中（栈帧中的本地变量表）的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象（<code>static final</code>…)</li>
<li>所有被同步锁持有的对象</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul>
<li>标记-清除：内存碎片</li>
<li>标记-整理</li>
<li>标记-复制：实现简单效率高，但是内存可用空间减小。存活对象增多的时候复制开销大（因此适合对象生命周期不长的新生代）</li>
<li>分代收集：新生代多数采取复制算法。老年代可能使用标记-整理</li>
</ul>
<h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><ul>
<li>在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3>在Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java 内存泄漏的主要原因之一。</li>
</ul>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用需要用SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。应用场景：内存cache，性能不足的设备上的多任务（多应用、后台应用）。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用需要用WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM 的内存空间是否足够，总会回收该对象占用的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<ul>
<li><code>WeakHashMap</code>: 不使用的Key会被移除。更准确地说，不会阻止垃圾回收器将Key进行回收。</li>
</ul>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用需要PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。<br>设置虚引用关联的唯一目的就是在这个对象被收集器回收的时候收到一个系统通知，或者后续添加进一步的处理。允许<code>finalize()</code>方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。对虚引用调用<code>get()</code>会返回null。</p>
<h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>对象在被GC后会被添加到引用队列中。</p>
<h2 id="被判定为需要回收的对象的回收时机"><a href="#被判定为需要回收的对象的回收时机" class="headerlink" title="被判定为需要回收的对象的回收时机"></a>被判定为需要回收的对象的回收时机</h2><p>要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。<br>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。（在finalize方法上强行将引用挂到一个可达对象上可以抢救一个对象，但是下次GC若被判定为需要回收，则不会再次调用finalize方法）</p>
<ul>
<li>finalize方法并不推荐使用。JVM不会保证等到finalize方法执行完成。</li>
</ul>
<h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><ul>
<li>方法区（“永久代”）并不是不会进行垃圾回收。方法区GC的主要对象是废弃常量和无用的类。<h3 id="运行时常量池的垃圾回收"><a href="#运行时常量池的垃圾回收" class="headerlink" title="运行时常量池的垃圾回收"></a>运行时常量池的垃圾回收</h3>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</li>
</ul>
<h3 id="如何判断无用的类"><a href="#如何判断无用的类" class="headerlink" title="如何判断无用的类"></a>如何判断无用的类</h3><ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的<code>ClassLoader</code>已经被回收。</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</li>
</ul>
<h2 id="垃圾收集器（重点是CMS和G1）"><a href="#垃圾收集器（重点是CMS和G1）" class="headerlink" title="垃圾收集器（重点是CMS和G1）"></a>垃圾收集器（重点是CMS和G1）</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p>
<p>新生代采用标记-复制算法，老年代采用标记-整理算法。<br><img src="./pics/GC-Serial.png" alt="GCSerial"></p>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<p>会暂停用户线程（Stop The World），适用与科学计算、大数据处理等弱交互场景。</p>
<p>新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<ul>
<li>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。<br><img src="./pics/GCParNew.png" alt="GCParNew"></li>
</ul>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 那么它有什么特别之处呢？（Parallel Scavenge无法与CMS配合工作）<br>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。（降低总的停顿时间 vs 降低单次停顿需要的时间）所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。<br>此为JDK1.8的默认收集器。</p>
<p>新生代采用标记-复制算法，老年代采用标记-整理算法。</p>
<h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<h3 id="CMS（Concurrent-Mark-Sweep，也是用于老年代的垃圾收集器）"><a href="#CMS（Concurrent-Mark-Sweep，也是用于老年代的垃圾收集器）" class="headerlink" title="CMS（Concurrent Mark Sweep，也是用于老年代的垃圾收集器）"></a>CMS（Concurrent Mark Sweep，也是用于老年代的垃圾收集器）</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。是一种标记-清除算法的实现。</p>
<ul>
<li>工作过程<ul>
<li>初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快</li>
<li>并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录（由于用户程序的并发运行，一部分被标记为不可达的对象又可达了），这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li>
<li>并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
<li>并发重置（？）<br><img src="./pics/GC-CMS.png" alt="GCCMS"></li>
</ul>
</li>
<li>优点：并发收集、低停顿</li>
<li>缺点：<ul>
<li>对CPU资源敏感</li>
<li>无法处理浮动垃圾：并发标记过程中，由于用户线程继续运行，可能会产生新的垃圾（这种现象成为Mutation， Mutator Problems），这部分垃圾并没有被GC线程识别（标记成了活动对象，不会被回收），称为浮动垃圾。而重新标记阶段的作用只是修改并发标记获得的不可达对象，没有办法处理，只能等到下一次GC再进行。</li>
<li>标记清除算法会产生内存碎片</li>
</ul>
</li>
</ul>
<h3 id="G1（Garbage-First，新生代、老年代都可以，from-Java-8）"><a href="#G1（Garbage-First，新生代、老年代都可以，from-Java-8）" class="headerlink" title="G1（Garbage-First，新生代、老年代都可以，from Java 8）"></a>G1（Garbage-First，新生代、老年代都可以，from Java 8）</h3><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征</p>
<ul>
<li>特点<ul>
<li>并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以<strong>不需要其他收集器配合</strong>就能独立管理整个 GC 堆，但是还是保留了分代的概念。<ul>
<li>G1并没有将堆划分为连续的新生代（以及其中的Eden区，Survivor0区，Survivor1区）、老年代，而是将堆划分为若干个区域（Region）。</li>
<li>这些Region的一部分包含新生代，负责新生代的GC仍然采用暂停所有应用线程的方式（Stop The World），将存活对象复制到老年代或者Survivor To空间。</li>
<li>这些Region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另一个区域完成了清理工作。这意味着在正常的处理过程中G1完成了（一部分）堆的压缩。解决了CMS的内存碎片问题。</li>
<li>G1中有一种特殊区域：Humongous区。之前的做法是将巨型对象分配到老年代，但是如果该对象生存时间短就会对GC产生负面影响。G1为此专门划分了Humongous区来存放巨型对象。G1会寻找一个或连续的H分区来存储巨型对象，有时候可能会启用Full GC。</li>
</ul>
</li>
<li>空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。不会产生内存碎片。</li>
<li>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
<li>G1 收集器在后台<strong>维护了一个优先列表</strong>，每次<strong>根据允许的收集时间，优先选择回收价值最大的 Region</strong>(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。<h3 id="工作过程（类似于CMS"><a href="#工作过程（类似于CMS" class="headerlink" title="工作过程（类似于CMS"></a>工作过程（类似于CMS</h3></li>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收<h3 id="G1收集器的Young-GC-Minor-GC"><a href="#G1收集器的Young-GC-Minor-GC" class="headerlink" title="G1收集器的Young GC/Minor GC"></a>G1收集器的Young GC/Minor GC</h3>针对Eden进行收集，当Eden区空间耗尽会触发。<br><img src="./pics/GC-G1MinorGC.png" alt="G1YoungGC"><br><img src="./pics/GC-G1MinorGCAfter.png" alt="G1YoungGCAfter"><h3 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h3></li>
</ul>
</li>
<li><code>-XX:+UseG1GC</code></li>
<li><code>-XX:G1HeapRegionSize=N</code>: G1划分单个区域的大小</li>
<li><code>-XX:MaxGCPauseMillis=N</code>: 最大GC停顿时间，JVM追求尽可能小于该值（对G1的STW时间进行预测</li>
<li><code>-XX:InitiatingHeapOccupancyPercent=N</code>: 堆占用达到多少的时候触发GC</li>
<li><code>-XX:ConcGCThreads=N</code>: 并发GC使用的线程数</li>
<li><code>-XX:G1ReservePercent=N</code>: 作为空闲空间的预留内存百分比，降低目标空间的溢出风险</li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 上分配，<strong>当 Eden 空间不够时，发起 Minor GC</strong>。</p>
<h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<h3 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。<br>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<ul>
<li>新生代使用标记-复制算法，Survivor From区和Eden区存活的对象都需要复制到Survivor To区，而Survivor To区的空间是比较小的。这需要老年代进行担保，将Survivor无法容纳的对象放到老年代。这要求老年代有足够的空间容纳这些对象，需要用某些方式估计晋升到老年代对象的大小。</li>
<li>如果老年代可以容纳当前新生代的所有对象，即使遇到最极端的情况（新生代的对象全部存活），可以断定本次Minor GC肯定是安全的。</li>
<li>如果上述条件不满足，则Minor GC有失败风险，需要确定是否冒险进行Minor GC。如果<code>HandlePromotionFailure = true</code>，说明可以冒险进行Minor GC，则使用另一种方式对晋升老年代的对象大小进行评估，即参考晋升老年代对象的平均大小。如果还是空间不足，则只能进行Full GC，让老年代腾出空间。</li>
</ul>
<h2 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<h3 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h3><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<h3 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h3 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<h3 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<h3 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h2 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h2><h3 id="Java-heap-space"><a href="#Java-heap-space" class="headerlink" title="Java heap space"></a>Java heap space</h3><h3 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h3><h3 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h3><p>GC耗时过长且回收效果差（回收了很小一部分堆内存）。</p>
<h3 id="DirectBufferMemory"><a href="#DirectBufferMemory" class="headerlink" title="DirectBufferMemory"></a>DirectBufferMemory</h3><ul>
<li>NIO: 可以直接分配堆外内存（OS的本地内存，<strong>不属于GC的管辖范围</strong>，不需要内存拷贝（Java堆和Native堆之间）所以速度较快）</li>
<li>错误表示堆外内存耗尽<h3 id="unable-to-create-native-thread"><a href="#unable-to-create-native-thread" class="headerlink" title="unable to create native thread"></a>unable to create native thread</h3></li>
<li>一个进程中创建了太多线程。线程的上限和OS有关。<h3 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h3>加载太多类。</li>
</ul>
<h1 id="Java内存泄漏"><a href="#Java内存泄漏" class="headerlink" title="Java内存泄漏"></a>Java内存泄漏</h1><ul>
<li>内存溢出：内存溢出是指没有足够的内存空间可供程序使用，出现OutOfMemoryError。内存中加载的数据量过于庞大，静态集合类中对对象的引用使用完未清空等。</li>
<li>内存泄漏：申请内存后无法及时释放内存空间，造成可达但没有用的对象，这些对象不会被GC，依然占用内存空间。内存泄漏最终会导致内存溢出。<ul>
<li>可能的场景：全局（静态）的集合（长生命周期对象持有短生命周期对象的强引用 -&gt; <code>WeakHashMap</code>），Key使用强引用，不关闭数据库连接。</li>
</ul>
</li>
<li>如何判断分析：频繁出现Full GC。<ul>
<li>进行堆转储并分析堆内对象的大小。<ul>
<li>JVM参数：<code>-XX:+HeapDumpOnOutOfMemoryError</code></li>
<li><code>jmap -dump:format=b file=[文件名] [pid]</code></li>
<li>JMX: 使用Jconsole找到名为<code>HotSpotDiagnostic</code>的MBean，即可完成堆转储。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="类文件结构（？）"><a href="#类文件结构（？）" class="headerlink" title="类文件结构（？）"></a>类文件结构（？）</h1><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><h2 id="类加载过程-跟对象创建过程进行一下区别和联系"><a href="#类加载过程-跟对象创建过程进行一下区别和联系" class="headerlink" title="类加载过程(跟对象创建过程进行一下区别和联系)"></a>类加载过程(跟对象创建过程进行一下区别和联系)</h2><ul>
<li>加载、连接（验证、准备、解析）、初始化<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3>类加载过程的第一步，主要完成下面3件事情：</li>
</ul>
<ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口<br>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class 文件获取，这里既可以从ZIP 包中读取（比如从jar 包和war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP 文件转换成对应的Class 类）。</li>
</ol>
<ul>
<li>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的<code>loadClass()</code>方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p>
<ol>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
<li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 <code>value</code> 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 <code>fianl</code> 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li>
</ol>
<h3 id="解析（？）"><a href="#解析（？）" class="headerlink" title="解析（？）"></a>解析（？）</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p>
<p>符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>
<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程。</p>
<p>对于<code>&lt;clinit&gt;()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p>
<p>对于初始化阶段，虚拟机严格规范了必须对类进行初始化的情况(只有主动去使用类才会初始化类)：</p>
<ol>
<li>当遇到 <code>new</code> 、 <code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code> 这4条直接码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul>
<li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li>
<li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>
<li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li>
<li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li>
</ul>
</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 如果类没初始化，需要触发其初始化。</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li>
<li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。</li>
<li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载类即该类的Class对象被GC。<br>卸载类需要满足3个要求:</p>
<ol>
<li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li><strong>该类的类加载器的实例已被GC</strong><br>所以，在JVM生命周期内，由<strong>jvm自带的类加载器加载的类是不会被卸载的</strong>。但是由我们自定义的类加载器加载的类是可能被卸载的。<br>jdk自带的BootstrapClassLoader,ExtClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</li>
</ol>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>所有的类都由类加载器加载，加载的作用就是将 .class文件加载到内存。</p>
<h2 id="JVM内置ClassLoader"><a href="#JVM内置ClassLoader" class="headerlink" title="JVM内置ClassLoader"></a>JVM内置ClassLoader</h2><p>JVM 中内置了三个重要的 ClassLoader，除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p>
<ul>
<li>BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。(<code>java.xxx.*</code>、<code>java.util.*</code>、<code>java.io</code>…)</li>
<li>ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。(<code>javax.*</code>…)</li>
<li>AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li>
</ul>
<h2 id="为什么要自定义ClassLoader？"><a href="#为什么要自定义ClassLoader？" class="headerlink" title="为什么要自定义ClassLoader？"></a>为什么要自定义ClassLoader？</h2><ul>
<li>Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。</li>
<li>JVM运行时并不会一次性加载所需要的全部类，它是按需加载（懒加载、延迟加载）。比如你在调用某个类的静态方法时，首先这个类肯定是需要被加载的，但是并不会触及这个类的实例字段，那么实例字段的类别 Class 就可以暂时不必去加载，但是它可能会加载静态字段相关的类别，因为静态方法会访问静态字段。而实例字段的类别需要等到你实例化对象的时候才可能会加载。</li>
<li>程序在运行过程中，遇到了一个未知的类，它会选择哪个 ClassLoader 来加载它呢？虚拟机的策略是使用调用者 Class 对象的 ClassLoader 来加载当前未知的类。何为调用者 Class 对象？就是在遇到这个未知的类时，虚拟机肯定正在运行一个方法调用（静态方法或者实例方法），这个方法挂在哪个类上面，那这个类就是调用者 Class 对象。前面我们提到每个 Class 对象里面都有一个 classLoader 属性记录了当前的类是由谁来加载的。</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>每一个类都有一个对应它的类加载器。系统中的<code>ClassLoder</code>在协同工作的时候会默认使用<strong>双亲委派模型</strong>。每一个ClassLoader的实例都有一个父类加载器的引用。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的<code>loadClass()</code>处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。<br><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code>。 <code>ExtClassLoader</code>的父类加载器为<code>null</code>，<code>null</code>并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code> 。</p>
<ul>
<li>When loading a class, a class loader first “delegates” the search for the class to its parent class loader before attempting to find the class itself.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;<span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">//抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<code>loadClass()</code> 方法是加载目标类的入口，它首先会查找当前 <code>ClassLoader</code> 以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 <code>findClass()</code> 让自定义加载器自己来加载目标类。<code>ClassLoader</code> 的 <code>findClass()</code> 方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用 <code>defineClass()</code> 方法将字节码转换成 Class 对象。</li>
</ul>
<h2 id="为什么要使用双亲委派模型"><a href="#为什么要使用双亲委派模型" class="headerlink" title="为什么要使用双亲委派模型"></a>为什么要使用双亲委派模型</h2><ul>
<li>双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（<strong>JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类</strong>），当父类加载器已经加载该类的时候，没有必要让子ClassLoader再加载一次。保证了 Java 的核心 API 不被篡改（？）。</li>
<li>如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</li>
<li>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。</li>
</ul>
<h2 id="钻石依赖问题-为什么JVM不只根据类名来区分不同类"><a href="#钻石依赖问题-为什么JVM不只根据类名来区分不同类" class="headerlink" title="钻石依赖问题(为什么JVM不只根据类名来区分不同类?)"></a>钻石依赖问题(为什么JVM不只根据类名来区分不同类?)</h2><ul>
<li>钻石依赖问题：软件依赖导致同一个软件包的两个版本需要共存而不能冲突。</li>
<li>Maven怎么解决钻石依赖：扁平化依赖管理<ul>
<li>依赖于JVM的默认懒加载策略。</li>
<li>从多个冲突的版本中选一个。如果不同版本之间的兼容性很糟糕，则程序无法正常编译运行。</li>
</ul>
</li>
<li>ClassLoader的解决方案：使用不同的ClassLoader加载不同版本的软件包。位于不同的ClassLoader中名称一样的类实际上是不同的类。<ul>
<li>只能使用反射或者接口的形式进行动态调用。</li>
</ul>
</li>
<li>ClassLoader：相当于命名空间，一定程度上起到类隔离的作用。</li>
</ul>
<h2 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="headerlink" title="如何打破双亲委派机制"></a>如何打破双亲委派机制</h2><ul>
<li>自定义加载器需要继承<code>ClassLoader</code>(除了<code>BootstrapClassLoader</code>所有的类加载器都继承自<code>ClassLoader</code>)</li>
<li>自定义加载器的话，需要继承 ClassLoader 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</li>
</ul>
<h2 id="Class-forName-vs-ClassLoader-loadClass"><a href="#Class-forName-vs-ClassLoader-loadClass" class="headerlink" title="Class.forName vs ClassLoader.loadClass"></a>Class.forName vs ClassLoader.loadClass</h2><p>这两个方法都可以用来加载目标类，它们之间有一个小小的区别，那就是 <code>Class.forName()</code> 方法可以获取原生类型的 Class，而 <code>ClassLoader.loadClass()</code> 则会报错。</p>
<h2 id="经典应用场景"><a href="#经典应用场景" class="headerlink" title="经典应用场景"></a>经典应用场景</h2><ul>
<li>Tomcat：<ul>
<li>保证同一个服务器的两个Web应用的Java类库互相隔离。</li>
<li>保证同一个服务器的两个Web应用程序的Java类库又可以共享（？？？）</li>
<li>保证服务器尽可能保证自身安全，不受到web应用的影响。</li>
<li>JSP的HotSwap？</li>
</ul>
</li>
<li>OSGi？</li>
</ul>
<h1 id="JVM-命令"><a href="#JVM-命令" class="headerlink" title="JVM 命令"></a>JVM 命令</h1><h2 id="JVM的参数类型"><a href="#JVM的参数类型" class="headerlink" title="JVM的参数类型"></a>JVM的参数类型</h2><h3 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h3><h3 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h3><ul>
<li>解释执行</li>
<li>第一次就编译成本地代码</li>
<li>混合模式<h3 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h3><ul>
<li>-XX:+/-: 开启/关闭某个属性值</li>
<li>K-V设值类型：-XX:MetspaceSize=blabla</li>
<li>堆内存大小</li>
</ul>
</li>
<li>初始： -Xms= 等价于 -XX:InitialHeapSiZE：</li>
<li>最大： -Xmx= 等价于 -XX:MaxlHeapSiZE：</li>
<li>最小： -Xmn<ul>
<li>栈内存大小</li>
</ul>
</li>
<li>-Xss：单个线程栈的大小<h2 id="查看运行中的java程序"><a href="#查看运行中的java程序" class="headerlink" title="查看运行中的java程序"></a>查看运行中的java程序</h2><ul>
<li>jps：查看进程号</li>
<li>jinfo ：查看运行参数 <code>jinfo -flag [设置] &lt;进程号&gt;</code><h2 id="查看JVM默认值"><a href="#查看JVM默认值" class="headerlink" title="查看JVM默认值"></a>查看JVM默认值</h2></li>
<li>-XX:+PrintFlagsInitial<h2 id="查看被修改过的JVM参数"><a href="#查看被修改过的JVM参数" class="headerlink" title="查看被修改过的JVM参数"></a>查看被修改过的JVM参数</h2></li>
<li>-XX:+PrintFlagFinal<h2 id="查看（默认）JVM命令"><a href="#查看（默认）JVM命令" class="headerlink" title="查看（默认）JVM命令"></a>查看（默认）JVM命令</h2></li>
<li>-XX:PrintCommandLineFlags</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-26 23:30:01 / 修改时间：23:31:52" itemprop="dateCreated datePublished" datetime="2021-03-26T23:30:01+08:00">2021-03-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%98%A5%E6%8B%9B%E5%A4%8D%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">春招复习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>
<p>Todos:</p>
<ul>
<li>[x] AQS</li>
<li>[x] <code>volatile</code></li>
<li>[x] <code>synchronized</code>锁升级机制</li>
<li>[x] monitor对象</li>
<li>[x] <code>ThreadLocal</code></li>
<li>[ ] 线程安全的懒汉式单例模式</li>
</ul>
<h1 id="虚假唤醒问题"><a href="#虚假唤醒问题" class="headerlink" title="虚假唤醒问题"></a>虚假唤醒问题</h1><ul>
<li><code>await()</code> / <code>wait()</code>需要放进循环中</li>
</ul>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ul>
<li>控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。<h2 id="为什么要用"><a href="#为什么要用" class="headerlink" title="为什么要用"></a>为什么要用</h2></li>
<li>线程复用，降低线程创建和销毁，降低资源消耗</li>
<li>提高响应速度，任务到达时任务可以不需要等到线程创建就可以立即执行</li>
<li>提高线程的可管理性，无限制地创建线程会消耗系统资源。使用线程池可以对线程进行统一分配和监控。<h2 id="7大参数"><a href="#7大参数" class="headerlink" title="7大参数"></a>7大参数</h2></li>
<li><code>corePoollSize</code></li>
<li><code>maximumPoolSize</code></li>
<li><code>keepAliveTime</code>: 多余线程的存活时间</li>
<li><code>TimeUnit</code></li>
<li><code>workQueue</code></li>
<li><code>threadFactory</code></li>
<li><code>handler</code>: 拒绝策略<br><img src="pics/微信截图_20210308002121.png" alt="ThreadPool"><h2 id="工作顺序"><a href="#工作顺序" class="headerlink" title="工作顺序"></a>工作顺序</h2>工作队列满才会创建非核心线程，工作队列不满时不会将新任务提交给非核心线程。线程在一定时间(<code>keepAliveTime</code>)没接收到任务后就会被停止，最终线程池会收缩到<code>corePoolSize</code>的大小。<br><img src="pics/threadPool.png" alt="ThreadPoolWorking"></li>
</ul>
<h2 id="4大拒绝策略"><a href="#4大拒绝策略" class="headerlink" title="4大拒绝策略"></a>4大拒绝策略</h2><p>拒绝策略触发的时机：任务数大于<code>corePoolSize</code>时会将任务放入队列缓冲区，填满了缓冲区后会判断当前任务书是否大于<code>maxPoolSize</code>，如果小于会新建线程处理，大于时会触发拒绝策略。</p>
<ul>
<li>CallerRunsPolicy（调用者运行）：触发拒绝策略时只要线程池没有关闭就交给提交任务的当前线程处理。（不允许失败、并发量小的场景）</li>
<li>AbortPolicy（中止策略）：触发拒绝策略时直接抛出拒绝执行的异常，打断当前的执行流程。</li>
<li>DiscardPolicy（丢弃策略）：触发拒绝策略时悄悄丢弃最新提交的任务，不抛出任何异常。</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</li>
</ul>
<h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><h2 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h2><ul>
<li>释放锁时，该线程对于的本地内存中的共享变量会刷新到主存中</li>
<li>获取锁时，该线程的本地内存会被设置为无效，被monitor保护的临界区代码必须从主内存中读取共享变量。</li>
</ul>
<h2 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h2><h3 id="什么是monitor"><a href="#什么是monitor" class="headerlink" title="什么是monitor"></a>什么是monitor</h3><p>JVM基于进入和退出monitor对象来实现同步。同步代码块采用添加<code>monitorenter</code>和<code>monitorexit</code>实现，同步方法使用<code>ACC_SYNCHRONIZED</code>标记符实现。monitor对象存在于每个对象的对象头中。<br>线程执行<code>monitorenter</code>时，会尝试获取monitor的所有权。如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。<br>线程执行<code>monitorexit</code>时，对monitor进行释放，此时线程必须是monitor的持有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>Java对象的内存布局：对象头、实例数据、对齐填充。对象头主要包括<code>Mark Word</code>标记字段和<code>Class Pointer</code>类型指针。</p>
<ul>
<li>Class Pointer 是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>Mark Word 用于存储对象自身的运行时数据，比如哈希码、锁状态标识、GC年龄等信息。Mark Word里存储的数据会随着锁标志位的变化而变化<ul>
<li>无锁(01)：hashcode、分代年龄、是否是偏向锁(0)</li>
<li>偏向锁(01): 偏向线程ID、偏向时间戳、对象分代年龄、是否偏向锁(1)</li>
<li>轻量级锁(00)：指向栈中锁记录的指针</li>
<li>重量级锁(10): 指向互斥量（重量级锁）的指针</li>
</ul>
</li>
</ul>
<h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><ul>
<li>锁升级机制：无锁、偏向锁、轻量级锁、重量级锁</li>
<li>锁的状态变化是单向的，不会降级，只会升级。<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4>所谓自旋锁，就是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。<br>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。<br>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</li>
</ul>
<h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>自旋的次数不固定，由前一次在同一个锁上自旋的时间和锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p>
<h4 id="锁清除"><a href="#锁清除" class="headerlink" title="锁清除"></a>锁清除</h4><p>JVM检测不到共享数据竞争时就会对这些同步锁进行锁清除。</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。例如将循环内的加锁操作转移到循环外。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。<br>偏向锁是在单线程执行同步代码块时使用的机制，如果在多线程并发的环境下（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请），则一定会转化为轻量级锁或者重量级锁。<br>当一个线程访问同步块并获取锁时，会在对象头（Mark Word）和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要花费CAS操作来争夺锁资源，只需要检查是否为偏向锁、锁标识为以及ThreadID即可。</p>
<ol>
<li>检测对象头的Mark Word字段判断是否为偏向锁状态</li>
<li>若为偏向锁状态，则判断线程ID是否为当前线程ID，如果是则执行同步代码块</li>
<li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁（怎么竞争？），竞争成功，则将Mark Word的线程ID替换为当前线程ID</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况。等待到达全局安全点（没有字节码正在执行）后，获得偏向锁的线程被挂起，偏向锁<strong>升级</strong>为轻量级锁<br>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。</li>
</ol>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>当多个线程竞争偏向锁时就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<ol>
<li>线程进入同步块时，如果同步对象锁状态为无锁状态（无锁和偏向锁都是<code>01</code>），虚拟机首先在当前线程的栈帧中建立一个名为Lock Record的空间，用于存储锁对象目前的Mark Word的拷贝。</li>
<li>将对象头中的Mark Word复制到Lock Record中。</li>
<li>复制成功后，虚拟机使用CAS操作尝试将对象Mark Word中的Lock Word（此时对象头Mark Word的内容）更新为指向当前当前线程Lock Record（线程栈帧中的空间）的指针，并将Lock Record里的owner指针指向对象Mark Word。</li>
<li>如果这个更新动作成功了，那么当前线程就拥有了该对象的锁。此时对象Mark Word的锁标志位被设置为<code>00</code>，表示对象处于轻量级锁定状态。</li>
<li>如果更新操作失败，JVM首先检查对象Mark Word中的Lock Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有此对象锁，可以进入同步块。否则进入<strong>自旋状态</strong>，如果自旋结束时仍未获得锁，轻量级锁就要升级为重量级锁，锁状态值变为<code>10</code>。<br>对于轻量级锁，其性能提升的依据是 “对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</li>
</ol>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>使用监视器锁，其本质依赖操作系统提供的Mutex Lock，因此需要进行系统调用，即完成从用户态到内核态的转换，因此这个成本非常高。</p>
<h1 id="Lock和Synchronized的区别"><a href="#Lock和Synchronized的区别" class="headerlink" title="Lock和Synchronized的区别"></a>Lock和Synchronized的区别</h1><ul>
<li><code>synchronized</code>是关键字，由JVM提供支持，底层通过<code>monitor</code>对象来完成（<code>monitorenter</code>/<code>monitorexit</code>），<code>wait</code>/<code>notify</code>方法也依赖monitor对象，因此这两个方法也只能在<code>synchronized</code>代码块中才能正常调用。<code>Lock</code>是具体类，当然<code>await</code>和<code>signal</code>也需要持有锁的时候调用，否则会抛出<code>IllegalMonitorStateException</code>异常。</li>
<li><code>synchronized</code>不需要手动释放锁，而<code>Lock</code>需要</li>
<li><code>synchronized</code>不可中断，除非抛出异常或者正常运行完成</li>
<li><code>ReentrantLock</code>可以中断<ul>
<li>超时方法<code>tryLock</code></li>
<li>调用<code>interrupt()</code>可以中断</li>
</ul>
</li>
<li><code>synchronized</code>是非公平锁，<code>Lock</code>可以是公平的。</li>
<li><code>ReentrantLock</code>可以绑定多个条件<code>Condition</code>，实现按照不同的需要分组唤醒线程，而<code>synchronized</code>只能随机唤醒一个线程或全部唤醒。</li>
</ul>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><ul>
<li>用于创建锁和其它同步类的基本线程阻塞原语</li>
<li><code>LockSupport</code>为<strong>每个</strong>使用它的线程提供一个permit（类似于<code>Semaphore</code>)，调用<code>park</code>方法时如果permit可用则立即返回并消耗这个permit，否则<strong>可能</strong>阻塞（类似于上限为1的信号量，重复<code>unpark</code>不会累积，最初调用<code>park</code>会直接阻塞，猜测初值应该为0）。调用<code>unpark</code>则可以释放permit。要保证对<code>LockSupport</code>的可靠使用，需要依靠<code>volatile</code>或原子变量来控制何时调用<code>park</code>或<code>unpark</code>。提供了阻塞和唤醒线程的功能。</li>
<li><code>park</code>会在调用线程被中断(interrupted)的时候返回，也支持超时机制，<strong>也可能在任何时候没有任何原因地返回</strong>。因此一般在循环中调用<code>park</code>以重新检测条件。这可以被视为一种优化的忙等待机制。</li>
<li>一般不直接使用而是用于构造高阶的同步机制。</li>
<li><strong>唤醒(unpark)可以在park之前进行</strong>，此时<code>park</code>不会被阻塞。<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2></li>
<li>通过<code>Unsafe</code>类中的native方法实现</li>
<li>permit默认为0</li>
<li>每次<code>park</code>都必须消耗一个permit（即使是连续调用），而每次调用<code>unpark</code>会将permit设置为1，但是上限为1，达到上限后不会累计。</li>
</ul>
<h1 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h1><h2 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h2><ul>
<li><code>java.util.concurrent.locks.AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer</code></li>
<li>用于构建锁和其它同步器组件。内置FIFO队列来完成获取资源的线程的排队工作，并通过（原子的）<code>int</code>类型的变量来表示持有锁的状态。</li>
<li><code>ReentrantLock</code>, <code>CountDownLatch</code>, <code>ReentrantRewriteLock</code>, <code>Semaphore</code>等类的实现都需要使用。</li>
<li>屏蔽（封装）了同步状态管理、阻塞线程、排队等操作：如果共享资源被占用，就需要一定的阻塞-等待-唤醒机制来保证锁的分配。将暂时获取不到锁的线程加入队列中，这个队列就是AQS的抽象表现。请求资源的线程 -&gt; 队列的结点。</li>
<li>支持两种同步方式：共享式、独占式</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>虚拟双向链表实现的队列</li>
<li>使用<code>volatile</code>的<code>int</code>类型成员变量<code>state</code>来表示同步状态。通过CAS完成对该状态的维护。</li>
<li><p>基于模板方法模式，使用者继承该类需要重写指定的方法。然后将AQS组合在自定义同步组件的实现中，并调用其模板方法，模板方法会调用使用者重写的方法。</p>
<ul>
<li><code>protected boolean tryAcquire(int arg)</code>: 独占式地获取同步状态（获取资源），成功返回true，否则返回false</li>
<li><code>protected boolean tryRelease(int arg)</code>: 独占式地释放同步状态（释放资源），等待中的其他线程此时有机会获取到同步状态</li>
<li><code>protected int tryAcquireShared(int arg)</code>: 共享式地获取同步状态，返回值大于等于0时成功，否则失败</li>
<li><code>protected boolean tryReleaseShared(int arg)</code>: 共享式地释放同步状态，成功true，失败false</li>
<li><code>protected boolean isHeldExclusively()</code>: 是否在独占模式下被线程占用。</li>
</ul>
</li>
<li><p>核心方法: <code>acquireQueued</code></p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3></li>
<li><code>volatile</code>的<code>int</code>类型成员变量。0: 可用，&gt;= 1: 占用中。<h3 id="AQS本身"><a href="#AQS本身" class="headerlink" title="AQS本身"></a>AQS本身</h3></li>
<li>通过自旋等待</li>
<li>CLH队列的变种：双端队列 </li>
<li>对队列的原子操作：尾部入队，头部出队。当一个节点的前驱结点释放资源时，该节点会被通知。<h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3></li>
<li><code>static final Node SHARED</code>/<code>static final Node EXCLUSIVE</code>: 线程等待锁的模式：共享/独占</li>
<li><code>volatile int waitState</code>成员变量：Node的等待状态<ul>
<li>0：初始化时的默认值</li>
<li>CANCELLED/1: 已经取消了对锁的请求</li>
<li>CONDITION/-2: 在等待队列中，等待唤醒</li>
<li>PROPAGATE/-3: SHARED状态下才会使用</li>
<li>SIGNAL/-1: 线程已经准备好了</li>
</ul>
</li>
<li><code>volatile Node prev</code>/<code>volatile Node next</code>: 前驱/后继节点</li>
<li><code>volatile Thread thread</code>: 与当前节点关联的排队中的节点</li>
</ul>
<h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 首先调用使用者重写的tryAcquire方法。如果返回true，说明获取同步状态成功，后面的逻辑不再执行。</span></span><br><span class="line">    <span class="comment">//    如果返回false，说明获取同步状态失败，需要继续执行</span></span><br><span class="line">    <span class="comment">// 2. 构造独占式同步节点，通过addWaiter方法将此节点添加到同步队列的尾部。此时可能有多个线程节点试图加入同步队列尾部，</span></span><br><span class="line">    <span class="comment">//    需要保证线程安全。</span></span><br><span class="line">    <span class="comment">// 3. 该节点在队列中尝试获取同步状态(acquireQueued)，如果获取不到则阻塞节点线程(selfInterrput)，直到被前驱结点唤醒</span></span><br><span class="line">    <span class="comment">//    或者被中断</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addWaiter</code>方法：构造一个Node节点并添加到队列尾部<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);<span class="comment">//构造结点</span></span><br><span class="line">    <span class="comment">//指向尾结点tail</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果尾结点不为空，CAS快速尝试在尾部添加，若CAS设置成功，返回；否则进入enq方法。</span></span><br><span class="line">    <span class="comment">// 尾节点为空也需要进入enq方法</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS操作</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>enq</code>方法：如果队尾为空，通过CAS方法尝试创建一个节点作为头结点（和当前的为节点）。如果队列不为空，则通过CAS尝试将当前节点连接到尾节点。如果失败则一直自旋等待。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">//如果队列为空，创建结点，同时被head和tail引用</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="comment">//cas设置尾结点，不成功就一直重试</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><code>acquireQueued</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程是否成功获得锁</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前线程是否被阻塞过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 不停自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 找到当前结点的前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱结点是头结点，才tryAcquire，其他结点是没有机会tryAcquire的。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取同步状态成功，将当前结点设置为头结点。</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 方便GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有获取到同步状态，通过shouldParkAfterFailedAcquire判断是否应该阻塞，parkAndCheckInterrupt用来阻塞线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>shouldParkAfterFailedAcquire</code>: 判断当前节点线程是否应该被阻塞，主要根据前驱节点（<code>node.predecessor()</code>）的状态进行判断。</p>
<ul>
<li>如果前驱节点的状态为<code>SIGNAL</code>，说明前驱节点准备好要获得锁，当前线程可以安全地被<code>LockSupport.park()</code></li>
<li>如果前驱节点的状态为<code>CANCELLED</code>，说明前驱节点已经取消了对锁的获取，前驱节点已经是无效节点。需要在链表中从后往前遍历，找到一个非<code>CANCELLED</code>状态的节点，将当前线程的节点设置为它的后继节点。</li>
<li>如果前驱节点为其它状态(<code>CONDITION</code>, <code>PROPAGATE</code>)，则将前驱节点的状态通过CAS设置为<code>SIGNAL</code>。</li>
<li><code>parkAndCheckInterrupt</code>：使用<code>LockSupport.park(this)</code>阻塞当前线程。并返回<code>Thread.interrupted()</code>。</li>
</ul>
<p><strong>acquire方法的逻辑总结</strong></p>
<ol>
<li>首先调用用户实现的<code>tryAcquire</code>尝试获得同步状态，成功则直接返回，失败则继续</li>
<li>如果等待链表的头结点不为空，使用CAS方法构造一个节点加入同步队列中。如果头结点为空或CAS失败，则不停自旋重复这个过程直到成功。</li>
<li>加入队列后的节点线程进入自旋状态。如果前驱节点是头结点，则尝试获取同步状态。否则，判断当前节点是否可以阻塞。</li>
<li>如果前驱节点的状态为<code>SIGNAL</code>，则可以阻塞当前线程。如果前驱节点的状态为<code>CANCELLED</code>，找到链表最尾端的一个状态为<code>SIGNAL</code>的节点，将当前节点设为其后继节点。如果前驱节点的状态为其它状态，则将其状态设置为<code>SIGNAL</code>。</li>
</ol>
<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>线程释放同步状态的方法。</p>
<ol>
<li>调用使用者重写的<code>tryRelease</code>方法，如果成功则调用<code>unparkSuccessor</code>唤醒其后继节点，如果失败则返回false</li>
<li><code>unparkSuccessor</code>首先会将当前节点的等待状态通过CAS设置为初始值0。如果当前节点的后继节点不为空且状态不为<code>CANCELLED</code>，调用<code>LockSupport.unpark(node.next.thread)</code>唤醒后继节点。否则，从尾向头寻找一个处于正常阻塞状态的节点(<code>waitStatus &lt;= 0</code>)，将其唤醒。</li>
</ol>
<h4 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h4><p>调用用户实现的<code>tryAcquireShared</code>，将判断条件从<code>true</code>/<code>false</code>改为剩余资源是否&gt;=0即可</p>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><ul>
<li>Lock接口的实现类：聚合一个队列同步器的子类(<code>Sync extends AbstractQueuedSynchronizer</code>)完成线程访问控制</li>
</ul>
<h3 id="案例-ReentrantLock"><a href="#案例-ReentrantLock" class="headerlink" title="案例 ReentrantLock"></a>案例 ReentrantLock</h3><ul>
<li>公平锁：先判断<code>hasQueuedPredecessors()</code></li>
<li>尝试加锁 -&gt; 加锁失败进入阻塞队列 -&gt; 线程阻塞</li>
<li>加锁(<code>lock()</code>)，对AQS的<code>state</code>进行CAS，如果成功，则调用<code>setExclusiveOwnerThread(thread)</code>， 否则调用<code>acquire(int)</code></li>
<li><code>tryAcquire()</code>: 模板，由子类实现</li>
</ul>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><ul>
<li>轻量级的同步机制<h2 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h2></li>
<li><code>volatile</code>保证了不同线程对共享变量操作的可见性。一个线程修改了<code>volatile</code>修饰的变量，当修改写回主内存时，另一个线程会立即看到最新的值。</li>
<li>主内存和工作内存的一致性问题：写数据时通知其它CPU将该变量的缓存行设为无效状态，其它CPU需要读取时发现缓存失效，则需要从内存中重新读取。<ul>
<li>如何发现数据失效：嗅探总线上传播的数据检查当前缓存值是否过期。</li>
</ul>
</li>
<li><code>volatile</code>写的内存语义：对一个<code>volatile</code>变量进行写操作时，该线程对应的本地内存中的共享变量值会刷新到主内存，然后通知其它CPU缓存失效。</li>
<li><code>volatile</code>读的内存语义：对一个<code>volatile</code>变量进行读操作时，该线程对应的本地内存会被置为无效，线程将会从主存中读取共享变量。</li>
<li>内存语义的实现：内存屏障策略。<h2 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h2></li>
<li>修改<code>volatile</code>变量需要将变量从主内存读取到线程的工作内存，在工作内存中修改变量值，然后将工作内存的变量值写回主内存。</li>
<li>但是对单个<code>volatile</code>变量的读和<strong>赋值</strong>操作可以被视为有原子性。<h2 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h2></li>
<li>JMM规则下的问题：编译器/JIT/微处理器允许对每个线程内的代码进行重排序。<ul>
<li>单线程下的执行结果不能被改变：遵守<code>as-if-serial</code>语义</li>
</ul>
</li>
<li>而在每个线程内不存在数据依赖性的指令在全局的指令执行顺序中可能是存在数据依赖性的。<ul>
<li>举个例子<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A</span> = <span class="number">0</span>, <span class="attr">B</span> = <span class="number">0</span></span><br><span class="line">Thread1: <span class="attr">r2</span> = A -&gt; <span class="attr">B</span> = <span class="number">1</span></span><br><span class="line">Thread2: <span class="attr">r1</span> = B -&gt; <span class="attr">A</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">执行顺序可能被重排为</span><br><span class="line">Thread1: <span class="attr">B</span> = <span class="number">1</span> -&gt; <span class="attr">r2</span> = A</span><br><span class="line">Thread2: <span class="attr">A</span> = <span class="number">2</span> -&gt; <span class="attr">r1</span> = B</span><br><span class="line"></span><br><span class="line">执行结果就可能变成<span class="attr">r2</span> = <span class="number">2</span>, <span class="attr">r1</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数据争用(data race):<ul>
<li>一个线程里有对一个变量的写操作</li>
<li>另一个线程里有对同一个变量的读操作</li>
<li>读写操作没有通过同步机制进行排序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>volatile</code>关键字实现了禁止指令重排序的优化，避免多线程环境下出现乱序执行的情况</li>
<li>内存屏障：任何指令不能和内存屏障指令重排序</li>
<li>对<code>volatile</code>变量的写操作前插入<code>StoreStore</code>内存屏障，禁止该内存屏障前后的写操作进行重排序；对<code>volatile</code>变量的写操作后加入<code>StoreLoad</code>屏障，禁止改内存屏障之前的写操作和</li>
</ul>
<h2 id="线程安全的懒汉式单例模式"><a href="#线程安全的懒汉式单例模式" class="headerlink" title="线程安全的懒汉式单例模式"></a>线程安全的懒汉式单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不对instance字段加volatile修饰符会怎样？</span></span><br><span class="line">    <span class="comment">// 对象构造并不是原子操作，它需要分配对象内存，调用构造器方法执行初始化，然后将对象引用赋值给变量。</span></span><br><span class="line">    <span class="comment">// 但是上述三个步骤可能发生重排序，比如可以先将对象引用赋值给变量，然后调用构造器的构造方法进行初始化。</span></span><br><span class="line">    <span class="comment">// 这样其它线程在检查instance是否为空时，能够判断instance是一个有指向的引用，因此判断instance != null</span></span><br><span class="line">    <span class="comment">// 但是实际上对象并没有完成初始化，其它线程可能会拿到一个“半成品”</span></span><br><span class="line">    <span class="comment">// volatile会制止该对象在初始化期间的指令重排序。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查，如果此时instance已经非空了，那单例肯定已经被创建，可以直接返回单例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 别的线程可能已经进入过一次synchronized代码块并对单例进行初始化，为了避免这种情况，我们需要进行二次检查</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag;或者作为触发器，实现轻量级同步。</li>
<li>volatile的读写操作不需要加锁，因此成本低。但是只能用作于属性。</li>
<li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主存中读取。</li>
<li>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</li>
</ul>
<h1 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS(Compare and Swap)"></a>CAS(Compare and Swap)</h1><ul>
<li>线程将工作内存中的内容写回主内存前先比较其期望值和主内存的真实值（比如，比较线程在读入时和当前主内存中变量的值是否相同），如果真实值和期望值相同，将新值写回主内存，否则表明该变量在当前线程读入工作内存后曾经被其他内存修改，不写回主内存。</li>
</ul>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><ul>
<li>Java无法直接访问底层系统，sun.misc.Unsafe相当于一个后门，可以直接直接操作特定内存的数据。</li>
<li>CAS是一条并发原语。比较是否为预期值的并决定是否更改的过程是原子的。</li>
<li><code>AtomicInteger.getAndIncrement()</code>: 1. 先从主内存中直接读出变量值，2. 然后使用CAS判断内存中变量的当前值是否等于期望值（刚从主内存读出来的值），如果是，则将修改后的值写回主内存。注意，1是原子的，2是原子的，1+2整个操作并不是原子的。如果在2.中发现内存中的当前值不等于期望值，则<strong>进行自旋等待(while一直循环)</strong>。（这是一种乐观锁）</li>
</ul>
<h2 id="缺点？"><a href="#缺点？" class="headerlink" title="缺点？"></a>缺点？</h2><ul>
<li>循环时间长，开销大。如果CAS失败会一直进行自旋，可能会对CPU带来较大的开销。</li>
<li>只能保证<strong>一个</strong>共享变量的原子操作。如果需要对多个共享变量进行原子操作，必须加锁。</li>
<li>ABA问题：<ul>
<li>问题描述：<ul>
<li>线程A从主内存读取变量到工作内存中，此时变量值为A。读取完毕后线程A因为某些原因被挂起</li>
<li>线程B从主内存读取同一个变量到工作内存中，变量值为A，通过CAS将主内存中的变量值修改为B</li>
<li>线程B再次通过CAS将主内存中的变量值修改为B</li>
<li>线程A恢复运行，希望将对变量的修改写入主内存，并且此时比较能够通过，线程A会认为变量并未经过修改</li>
<li><strong>虽然变量的值看上去并没有变化，但是此时数据的语义很可能已经发生变化</strong>。例如本来应该只发生一次的更改发生了多次。</li>
</ul>
</li>
<li>原子引用<code>AtomicReference&lt;V&gt;</code>: 让任意自定义类型实现类似<code>AtomicInteger</code>的功能</li>
<li>如何规避ABA问题：新增版本号机制<ul>
<li>可以直接使用时间戳作为版本号：<code>AtomicStampedReference&lt;V&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="CopyOnWriteArrayList（写时复制）"><a href="#CopyOnWriteArrayList（写时复制）" class="headerlink" title="CopyOnWriteArrayList（写时复制）"></a>CopyOnWriteArrayList（写时复制）</h3><ul>
<li>数据使用<code>volatile</code>的数组进行保存</li>
<li>写时先获得锁，然后进行复制，在复制后的数组上进行写（并扩容），最后将原数组的引用指向新数组。</li>
</ul>
<h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><ul>
<li>公平锁：FIFO（获取锁的顺序就是申请锁的顺序）；非公平锁：获取锁的顺序不一定是申请锁的顺序，可能会造成优先级反转或者饥饿现象。</li>
<li><code>ReentrantLock</code>默认是非公平锁，可以通过在构造函数中对<code>fair</code>参数传入<code>true</code>让实例成为公平锁。<ul>
<li>公平：FIFO</li>
<li>非公平：直接尝试获得锁，如果尝试失败则才在队列中进行排队。有点：吞吐量大。<code>synchronized</code>是一种非公平锁。</li>
</ul>
</li>
</ul>
<h2 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h2><ul>
<li>同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁。线程可以进入任何一个它已经拥有的锁同步着的代码块。</li>
<li>例如：对于同一个对象内的<code>synchronized</code>方法，当前线程已经进入了一个<code>synchronized</code>方法内，说明该线程已经获得当前对象的对象锁，因此该线程在释放该锁之前同样可以调用该对象的其它<code>synchronized</code>方法。</li>
<li>最大的作用是避免死锁。</li>
<li>实现：计数 -&gt; 加锁和解锁的操作需要配对</li>
</ul>
<h2 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h2><ul>
<li>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。好处是（在等待时间可能不长时）减少线程上下文切换的消耗，缺点是循环会消耗CPU。</li>
</ul>
<h2 id="互斥锁-排他锁-共享锁"><a href="#互斥锁-排他锁-共享锁" class="headerlink" title="互斥锁/排他锁 共享锁"></a>互斥锁/排他锁 共享锁</h2><ul>
<li>读读相容，独写不相容，写写不相容</li>
</ul>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ul>
<li>接口：<code>BlockingQueue</code></li>
<li>常见实现：<br><img src="./pics/微信截图_20210307223627.png" alt="BlockingQueue"></li>
<li><code>SynchronousQueue</code></li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h4><ul>
<li><code>Segment&lt;K, V&gt;</code>: 将每个HashMap的Entry进行分组。记录需要插入HashMap需要先定位插入的Segment，再在Segment中定位插入的位置。相当于将原本的每个Entry分组。该类继承于<code>ReentrantLock</code>，因此具有获得可重入锁的功能。</li>
<li>执行put操作的时候，先进行第一次hash来定位segment的位置，如果segment还没有初始化即通过CAS进行赋值。然后进行第二次hash操作，找到响应的HashEntry的位置。之后调用继承自<code>ReentrantLock</code>的可超时方法<code>tryLock</code>尝试获取该Segment的锁。如果成功则在Segment中进行插入或修改。如果不成功，则当前线程会以自旋的方式继续调用<code>tryLock()</code>尝试获得锁。当前线程自旋超过指定的次数就会被挂起，等待被唤醒。</li>
<li>执行get操作不需要加锁。</li>
<li>执行size操作时，由于可能存在并发的线程正在插入数据，因此得到的size可能不等于实际的size。<ul>
<li>先尝试不加锁多次计算<code>ConcurrentHashMap</code>的size，比较多次计算的结果，如果一致就认为当前没有并发的插入操作，计算结果是准确的。</li>
<li>如果不一致，则为每个Segment加锁，然后计算size并返回。</li>
</ul>
</li>
</ul>
<h4 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h4><ul>
<li>摒弃<code>Segment</code>的概念，直接使用Node数组，将Segment锁变为节点锁。</li>
<li>执行put操作的时候，通过一次hash来定位Node的位置，如果该Node还没有初始化即通过CAS进行赋值。如果该Node已经初始化，则使用<code>synchronized</code>关键字来获得该Node的对象锁，成功获得锁后再在该Node中定位插入/修改的位置。</li>
</ul>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><ul>
<li><strong>非阻塞</strong>的线程安全队列</li>
<li>使用链表作为底层数据结构，使用CAS来实现线程安全（？）</li>
</ul>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。<br>ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。</p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。</p>
<p>PriorityBlockingQueue 并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p>
<p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>为每个线程提供一份独有的副本变量，多个线程互不干扰。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，即每个线程有一个自己的<code>ThreadLocalMap</code>。<br>该Map的元素是<code>Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，即继承了<code>ThreadLocal&lt;?&gt;</code>的一个弱引用。每个线程在向<code>ThreadLocal</code>里放值的时候，其实都在向自己的<code>ThreadLocalMap</code>里存值。读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现线程隔离。<code>ThreadLocalMap</code>类似于<code>HashMap</code>的结构，同样以数组结构存储数据。<br><img src="./pics/multi-thread/threadlocal.jpg" alt="threadLocal"><br><code>ThreadLocal</code>的<code>set</code>方法：用<code>Thread.currentThread()</code>通过<code>getMap(Thread)</code>方法取出当前线程对应的<code>ThreadLocalMap</code>。如果map为空则创建一个，如果不为空则将值加入map。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由<code>createMap</code>方法可以看出，<code>ThreadLocalMap</code>是线程对象（<code>Thread</code>）的一个成员变量。</p>
<h3 id="ThreadLocalMap使用的Hash算法，如何解决冲突"><a href="#ThreadLocalMap使用的Hash算法，如何解决冲突" class="headerlink" title="ThreadLocalMap使用的Hash算法，如何解决冲突"></a>ThreadLocalMap使用的Hash算法，如何解决冲突</h3><p><code>ThreadLocalMap</code>不使用链表来解决哈希冲突，而是使用线性探测法。</p>
<h3 id="为什么key要用ThreadLocal对象的弱引用"><a href="#为什么key要用ThreadLocal对象的弱引用" class="headerlink" title="为什么key要用ThreadLocal对象的弱引用"></a>为什么key要用ThreadLocal对象的弱引用</h3><p>回忆弱引用的定义：下一次GC时如果<strong>只有</strong>弱引用，则该对象一定会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry的定义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment"> * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment"> * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment"> * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment"> * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment"> * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当还有线程正在使用某个<code>ThreadLocal</code>对象时，这些线程的栈中会保留一个指向这一<code>ThreadLocal</code>对象的强引用。如果没有线程要使用这个<code>ThreadLocal</code>对象了（每个线程都将指向<code>ThreadLocal</code>对象的引用置为null），这个<code>ThreadLocal</code>对象就应该被垃圾回收。<br>如果某个线程没有完全结束，那么这个线程对应的<code>Thread</code>对象也不会被GC。而<code>Thread</code>对象里存在对<code>ThreadLocalMap</code>的引用（强引用）。如果<code>ThreadLocalMap</code>的key是对<code>ThreadLocal</code>的强引用，只要使用过这个<code>ThreadLocal</code>对象的线程没有都结束（还存在<code>Thread</code>对象未被GC），根据可达性分析，<code>ThreadLocal</code>对象会被视为可达，因为<code>ThreadLocalMap</code>持有对<code>ThreadLocal</code>的强引用，此时<code>ThreadLocal</code>对象不会被GC。如果<code>ThreadLocalMap</code>持有的是对<code>ThreadLocal</code>的弱引用，则此时<code>ThreadLocal</code>对象只存在弱引用，可以被GC。</p>
<h3 id="Entry中key的内存泄漏问题"><a href="#Entry中key的内存泄漏问题" class="headerlink" title="Entry中key的内存泄漏问题"></a>Entry中key的内存泄漏问题</h3><p>即使<code>ThreadLocal</code>被GC，Entry中对value的引用是强引用，因此key被GC时value不会被GC，但这个value永远不会被访问到了。并且除非所有使用过这个<code>ThreadLocal</code>的线程都退出，GC算法会把整个<code>ThreadLocalMap</code>GC，此时<code>ThreadLocal</code>才会被GC。Java为了尽可能减小这种内存泄漏的影响，在get方法和set方法中会清除<code>ThreadLocalMap</code>中key为null的value。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/25/Nginx-Learning-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/25/Nginx-Learning-Notes/" class="post-title-link" itemprop="url">Nginx-Learning-Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-25 10:19:38 / 修改时间：12:36:23" itemprop="dateCreated datePublished" datetime="2020-12-25T10:19:38+08:00">2020-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nginx学习笔记"><a href="#Nginx学习笔记" class="headerlink" title="Nginx学习笔记"></a>Nginx学习笔记</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h2><ul>
<li>nginx有一个master进程和多个worker进程。master进程的主要目的是读取并应用配置文件，并维护worker进程。worker进程会负责实际的请求处理。</li>
</ul>
<h2 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h2><p>nginx由多个模块组成，而这些模块由配置文件中的指令进行控制。指令被分为简单指令(单纯的一条指令，分号结尾)和块级指令(由花括号<code>&#123;&#125;</code>包裹)`。如果一个块级指令能够将其它指令包裹在它的花括号中，那么他被称为一个上下文(context)。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在CentOS 7上安装nginx<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install yum-utils</span><br></pre></td></tr></table></figure><br>创建<code>/etc/yum.repos.d/nginx.repo</code>文件，文件内容为:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[nginx-stable]</span></span><br><span class="line"><span class="attr">name</span>=nginx stable repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[nginx-mainline]</span></span><br><span class="line"><span class="attr">name</span>=nginx mainline repo</span><br><span class="line"><span class="attr">baseurl</span>=http://nginx.org/packages/mainline/centos/<span class="variable">$releasever</span>/<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">gpgkey</span>=https://nginx.org/keys/nginx_signing.key</span><br><span class="line"><span class="attr">module_hotfixes</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>默认情况下，nginx packages使用<code>nginx-stable</code>repository。如果要切换到<code>mainline</code>，则运行以下命令:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --enable nginx-mainline</span><br></pre></td></tr></table></figure><br>随后，安装nginx<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y nginx</span><br></pre></td></tr></table></figure></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>
<h3 id="使用-s参数控制nginx"><a href="#使用-s参数控制nginx" class="headerlink" title="使用-s参数控制nginx"></a>使用<code>-s</code>参数控制nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ngingx -s SIGNAL</span><br><span class="line">``` </span><br><span class="line">* `stop`: 快速关闭</span><br><span class="line">* `quit`: graceful shutdown，会等待worker进程完成当前请求的处理。</span><br><span class="line">* `reload`: 重新加载配置文件，不必重启就可以让配置生效</span><br><span class="line">  * 当master接收到这一信号时，它会检查新配置文件的语法正确性，并应用这一配置。如果这一步成功，master会启动新的worker进程并向旧的worker进程发送消息让他们关闭。否则，master会回滚更改并继续使用旧的配置来工作。旧的进程在接受到shutdown信息后会停止接受新请求，将当前的请求处理完后才退出。</span><br><span class="line">* `reopen`: 重新打开日志文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 提供静态内容</span></span></span><br><span class="line">在配置文件中的`http`块级指令中编写`server`块级指令。在`server`中加入`location`块级指令。</span><br></pre></td></tr></table></figure>
<p>http {<br>    server {</p>
<pre><code>    # 定义URI匹配规则(最长匹配)
    location / &#123;
        # 静态内容的根目录
        root /data/www;
    &#125;
&#125;
</code></pre><p>}<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 配置代理服务器</span><br><span class="line">nginx的常见应用之一就是作为代理服务器，接受请求并将其转发给被代理的服务器，从被代理的服务器获取响应，然后将响应发送给客户端。配置方法是在`location`块级指令中加入`proxy_pass`指令。`location`指定的URI匹配可以编写正则表达式来表示更灵活的匹配规则，正则表达式以`~`开头</span><br></pre></td></tr></table></figure><br>server {<br>    location / {<br>        proxy_pass <a target="_blank" rel="noopener" href="http://localhost:8080">http://localhost:8080</a>;<br>    }<br>    location ~ .(gif|jpg|png)$ {<br>        root /data/images;<br>    }<br>}<br>```</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/24/Docker-Learning-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/24/Docker-Learning-Notes/" class="post-title-link" itemprop="url">Docker学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-24 15:59:41" itemprop="dateCreated datePublished" datetime="2020-12-24T15:59:41+08:00">2020-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-25 17:40:48" itemprop="dateModified" datetime="2020-12-25T17:40:48+08:00">2020-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="Why-Docker"><a href="#Why-Docker" class="headerlink" title="Why Docker?"></a>Why Docker?</h2><h2 id="Docker镜像-Images"><a href="#Docker镜像-Images" class="headerlink" title="Docker镜像(Images)"></a>Docker镜像(Images)</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>一个镜像是一个只读的模板，它包含了创建一个Docker容器的命令。要创建一个新的Docker镜像，编写Dockerfile然后build即可。<br>当运行一个Docker容器时，容器使用一个隔离的文件系统。这一文件系统由容器的镜像来提供。因为镜像包括了容器的文件系统，所以镜像必须包括运行一个应用所需要的所有东西，包括依赖、配置项、脚本、二进制文件等。镜像也包括容器的其它配置，比如环境变量，一个用于运行的默认命令，以及其它元信息。</p>
<h3 id="层-layer-的概念"><a href="#层-layer-的概念" class="headerlink" title="层(layer)的概念"></a>层(layer)的概念</h3><p>在Dockerfile的每条命令都会为镜像创建一个层(Layer)。当修改Dockerfile并rebuild一个镜像时，只有被修改的层需要rebuild。</p>
<h2 id="Docker容器-Container"><a href="#Docker容器-Container" class="headerlink" title="Docker容器(Container)"></a>Docker容器(Container)</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>一个容器是一个镜像的可运行实例，是一个被松散地隔离开的进程。可以通过Docker CLI或Docker API来进行创建(create)、运行(start)、停止(stop)、移动(move)或删除(delete)。默认情况下，一个容器和其它容器以及宿主机是隔离的。一个容器由用于创建它的镜像以及创建时或运行时提供的配置选项来定义。</p>
<h1 id="常用命令及工作流程"><a href="#常用命令及工作流程" class="headerlink" title="常用命令及工作流程"></a>常用命令及工作流程</h1><h2 id="Docker镜像加速"><a href="#Docker镜像加速" class="headerlink" title="Docker镜像加速"></a>Docker镜像加速</h2><p>对于Windows 10，在Docker Desktop里修改<code>registry-mirrors</code>即可。阿里云会提供Docker镜像加速服务（容器镜像服务）。</p>
<h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><h3 id="Build-an-Image"><a href="#Build-an-Image" class="headerlink" title="Build an Image"></a>Build an Image</h3><p>在Dockerfile的同一目录下运行<code>docker build</code>命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [-t IMAGE_NAME] [DOCKERFILE_DIRECTORY]</span><br></pre></td></tr></table></figure></p>
<h3 id="查看所有的Image"><a href="#查看所有的Image" class="headerlink" title="查看所有的Image"></a>查看所有的Image</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><h3 id="Start-a-Container"><a href="#Start-a-Container" class="headerlink" title="Start a Container"></a>Start a Container</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARGS]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p: 端口映射</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d: detached mode</span></span><br><span class="line">docker run -dp 3000:3000 getting-started</span><br></pre></td></tr></table></figure>
<h3 id="查看Container运行情况"><a href="#查看Container运行情况" class="headerlink" title="查看Container运行情况"></a>查看Container运行情况</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<h3 id="Stop-a-Container"><a href="#Stop-a-Container" class="headerlink" title="Stop a Container"></a>Stop a Container</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop CONTAINER_ID</span><br></pre></td></tr></table></figure>
<h3 id="Remove-a-Container"><a href="#Remove-a-Container" class="headerlink" title="Remove a Container"></a>Remove a Container</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm CONTAINER_ID</span><br><span class="line"><span class="meta">#</span><span class="bash"> Remove a running container</span></span><br><span class="line">docker rm -f CONTAINER_ID</span><br></pre></td></tr></table></figure>
<h2 id="Docker容器卷-Container-Volumes"><a href="#Docker容器卷-Container-Volumes" class="headerlink" title="Docker容器卷(Container Volumes)"></a>Docker容器卷(Container Volumes)</h2><p>每个容器都持有自己的暂存空间来创建、存储、修改和删除文件，任何容器内的改变都不会影响其它容器。一般情况下容器被删除时容器内所有文件都不复存在。可以使用容器卷(Container Volumes)来让容器的特定系统路径连接回宿主机。如果一个容器内的目录被挂载，在这一目录中的修改可以在宿主机上观察到。同时如果我们在容器重启时挂载相同的目录，就能在容器中看到相同的文件。</p>
<h3 id="具名容器卷-Named-Volume"><a href="#具名容器卷-Named-Volume" class="headerlink" title="具名容器卷(Named Volume)"></a>具名容器卷(Named Volume)</h3><p>可以认为这是一个数据桶，Docker会负责维护硬盘上的物理位置，用户只需要知道这个数据桶的名称，只要提供这个名称就能得到对应位置的正确数据。</p>
<h4 id="创建卷"><a href="#创建卷" class="headerlink" title="创建卷"></a>创建卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create VOLUME_NAME</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker volume create todo-db</span></span><br></pre></td></tr></table></figure>
<h4 id="为容器挂载卷"><a href="#为容器挂载卷" class="headerlink" title="为容器挂载卷"></a>为容器挂载卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -v VOLUME_NAME:DIRECTORY IMAGE</span><br><span class="line"><span class="meta">#</span><span class="bash"> VOLUME_NAME: 卷名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> DIRECOTRY: 将卷挂在到容器内的指定目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started</span></span><br></pre></td></tr></table></figure>
<h4 id="查看所有卷"><a href="#查看所有卷" class="headerlink" title="查看所有卷"></a>查看所有卷</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure>
<h4 id="查看指定卷的详细信息"><a href="#查看指定卷的详细信息" class="headerlink" title="查看指定卷的详细信息"></a>查看指定卷的详细信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect VOLUME_NAME</span><br><span class="line"><span class="meta">#</span><span class="bash"> VOLUME_NAME: 卷名，可以通过docker volume ls找到</span></span><br></pre></td></tr></table></figure>
<p>其中<code>Mountpoint</code>是数据在硬盘上存储的实际位置。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2020-12-25T15:31:19+08:00&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/todo-db/_data&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;todo-db&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="绑定挂载-Bind-Mount"><a href="#绑定挂载-Bind-Mount" class="headerlink" title="绑定挂载(Bind Mount)"></a>绑定挂载(Bind Mount)</h3><p>使用绑定挂载可以控制宿主机上的具体挂载点，bind mount通常用于为容器内的应用提供额外数据。bind mount不支持容器内容写入宿主目录，也不支持volume driver。<br>应用场景:在本地设置开发环境。开发机器不需要安装所有的构建工具和环境，而是可以通过Docker构建一个可以分发的开发环境并分发给开发人员(包括数据库开发环境也可以进行分发，但是数据库开发环境应该使用named volume)。</p>
<h2 id="Docker网络配置"><a href="#Docker网络配置" class="headerlink" title="Docker网络配置"></a>Docker网络配置</h2><h3 id="容器之间的通信"><a href="#容器之间的通信" class="headerlink" title="容器之间的通信"></a>容器之间的通信</h3><p>只要容器处于同一个Docker网络内，就可以进行通信。</p>
<h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker network create [ARGS] NETWORK_NAME</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以在ARGS中提供各种参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --driver=bridge 指定网络类型</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --subnet=192.168.6.0/24 指定子网划分</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --ip-range=192.168.6.0/24 指定IP范围</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --gateway=192.168.6.1 指定网关, 可以不提供</span></span><br></pre></td></tr></table></figure>
<h3 id="查看当前Docker网络"><a href="#查看当前Docker网络" class="headerlink" title="查看当前Docker网络"></a>查看当前Docker网络</h3><ul>
<li>如果要查看当前所有的网络<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 大概会出现四栏的表格：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> NETWORK ID    NAME    DRIVER    SCOPE</span></span><br></pre></td></tr></table></figure></li>
<li>如果要查看某个网络的详细情况（子网、默认网关等），可以使用<code>inspect</code>命令。可以看到连接到某一网络的所有容器信息，包括它们各自的IP地址。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect [NETWORK ID | NAME]</span><br></pre></td></tr></table></figure></li>
<li>节选一段返回信息。<strong>如果不想让Docker容器直接通过iptables进行端口映射，或者iptables的端口映射出现问题，可以通过使用nginx反向代理等手段，让请求直接转发到 容器IP:端口 上</strong><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Id&quot;</span>: <span class="string">&quot;ca18bdeb0aea357f983a90012ce2245670597495d3bc824f4d86f2cf81f75800&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Created&quot;</span>: <span class="string">&quot;2020-12-24T21:53:47.388294816+08:00&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;Options&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;Subnet&quot;</span>: <span class="string">&quot;192.168.5.0/24&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;Gateway&quot;</span>: <span class="string">&quot;192.168.5.1&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;AuxiliaryAddresses&quot;</span>: &#123;</span><br><span class="line">                        <span class="attr">&quot;DefaultGatewayIPv4&quot;</span>: <span class="string">&quot;192.168.5.2&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;a41a18d43c71e52843f07683d1f672e241afaa922510c46934da2bcd71caaf1e&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;vigilant_jang&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;fe6dcd7083dd9bc8484e77b96ecf7bb82b241d4d0b2069e7012a315fc09b48ef&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:a8:05:03&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.168.5.3/24&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;b484dc156df6f30de8f4c13fff4a8cfbe31177a475d66f69c6efb16dfa2af8f5&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;hardcore_goldberg&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;EndpointID&quot;</span>: <span class="string">&quot;50a6883e77447d0e21765f42daacbcaa0f435eea558e5d670ff785bec75e97da&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:a8:05:04&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.168.5.4/24&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;com.docker.network.bridge.default_bridge&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;com.docker.network.bridge.host_binding_ipv4&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;com.docker.network.bridge.name&quot;</span>: <span class="string">&quot;docker0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;com.docker.network.driver.mtu&quot;</span>: <span class="string">&quot;1500&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="在启动时让容器连接到指定网络"><a href="#在启动时让容器连接到指定网络" class="headerlink" title="在启动时让容器连接到指定网络"></a>在启动时让容器连接到指定网络</h3>在执行<code>docer run</code>时提供<code>--network</code>参数即可。还可以提供<code>--network-alias</code>来为该容器在该网络上指定host名称，其他容器可以使用Docker提供的DNS服务，使用这一主机名来与该容器通信。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --network todo-app --network-alias mysql \</span><br><span class="line">    -v todo-mysql-data:/var/lib/mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=secret \</span><br><span class="line">    -e MYSQL_DATABASE=todos \</span><br><span class="line">    mysql:5.7</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/18/Hadoop-Pseudo-Distributed-Helloword/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/18/Hadoop-Pseudo-Distributed-Helloword/" class="post-title-link" itemprop="url">Hadoop-Pseudo-Distributed-Helloword</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-18 16:03:39" itemprop="dateCreated datePublished" datetime="2020-10-18T16:03:39+08:00">2020-10-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/04/Algorithm-SumUp-TwoPointers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Freeman Huang">
      <meta itemprop="description" content="Self-talking of a noob">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Freeman's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/04/Algorithm-SumUp-TwoPointers/" class="post-title-link" itemprop="url">算法专题 - 双指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-04 17:34:41" itemprop="dateCreated datePublished" datetime="2020-10-04T17:34:41+08:00">2020-10-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-10 13:17:11" itemprop="dateModified" datetime="2020-10-10T13:17:11+08:00">2020-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>分类刷题归集，总结遇到的各种双指针问题</strong><br><strong>题目描述和编号来自Leetcode中文站</strong><br>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/10/04/Algorithm-SumUp-TwoPointers/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Freeman Huang</p>
  <div class="site-description" itemprop="description">Self-talking of a noob</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Freeman Huang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
